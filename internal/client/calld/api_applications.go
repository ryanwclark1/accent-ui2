/*
accent-calld

Control your calls from a REST API

API version: 1.0.0
Contact: help@accentvoice.io
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package calld

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"strings"
)

type ApplicationsAPI interface {

	/*
		AnswerApplicationCall Answer a call

		**Required ACL:** `calld.applications.{application_uuid}.calls.{call_id}.answer.update`

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param applicationUuid UUID of the application
		@param callId ID of the call
		@return ApplicationsAPIAnswerApplicationCallRequest
	*/
	AnswerApplicationCall(ctx context.Context, applicationUuid string, callId string) ApplicationsAPIAnswerApplicationCallRequest

	// AnswerApplicationCallExecute executes the request
	AnswerApplicationCallExecute(r ApplicationsAPIAnswerApplicationCallRequest) (*http.Response, error)

	/*
		CreateApplicationCallToNode Make a new call to the node

		**Required ACL:** `calld.applications.{application_uuid}.nodes.{node_uuid}.calls.create`

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param applicationUuid UUID of the application
		@param nodeUuid UUID of the node
		@return ApplicationsAPICreateApplicationCallToNodeRequest
	*/
	CreateApplicationCallToNode(ctx context.Context, applicationUuid string, nodeUuid string) ApplicationsAPICreateApplicationCallToNodeRequest

	// CreateApplicationCallToNodeExecute executes the request
	//  @return ApplicationCall
	CreateApplicationCallToNodeExecute(r ApplicationsAPICreateApplicationCallToNodeRequest) (*ApplicationCall, *http.Response, error)

	/*
		CreateApplicationCallToUser Initiate a call to a user and insert it in the node

		**Required ACL:** `calld.applications.{application_uuid}.nodes.{node_uuid}.calls.user.create`

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param applicationUuid UUID of the application
		@param nodeUuid UUID of the node
		@return ApplicationsAPICreateApplicationCallToUserRequest
	*/
	CreateApplicationCallToUser(ctx context.Context, applicationUuid string, nodeUuid string) ApplicationsAPICreateApplicationCallToUserRequest

	// CreateApplicationCallToUserExecute executes the request
	//  @return ApplicationCall
	CreateApplicationCallToUserExecute(r ApplicationsAPICreateApplicationCallToUserRequest) (*ApplicationCall, *http.Response, error)

	/*
		CreateApplicationCalls Make a new call to the application

		**Required ACL:** `calld.applications.{application_uuid}.calls.create`

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param applicationUuid UUID of the application
		@return ApplicationsAPICreateApplicationCallsRequest
	*/
	CreateApplicationCalls(ctx context.Context, applicationUuid string) ApplicationsAPICreateApplicationCallsRequest

	// CreateApplicationCallsExecute executes the request
	//  @return ApplicationCall
	CreateApplicationCallsExecute(r ApplicationsAPICreateApplicationCallsRequest) (*ApplicationCall, *http.Response, error)

	/*
		CreateApplicationNode Make a new node and add calls

		**Required ACL:** `calld.applications.{application_uuid}.nodes.create`

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param applicationUuid UUID of the application
		@return ApplicationsAPICreateApplicationNodeRequest
	*/
	CreateApplicationNode(ctx context.Context, applicationUuid string) ApplicationsAPICreateApplicationNodeRequest

	// CreateApplicationNodeExecute executes the request
	//  @return ApplicationNode
	CreateApplicationNodeExecute(r ApplicationsAPICreateApplicationNodeRequest) (*ApplicationNode, *http.Response, error)

	/*
		DeleteApplicationCall Hangup a call from the application

		**Required ACL:** `calld.applications.{application_uuid}.calls.{call_id}.delete`

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param applicationUuid UUID of the application
		@param callId ID of the call
		@return ApplicationsAPIDeleteApplicationCallRequest
	*/
	DeleteApplicationCall(ctx context.Context, applicationUuid string, callId string) ApplicationsAPIDeleteApplicationCallRequest

	// DeleteApplicationCallExecute executes the request
	DeleteApplicationCallExecute(r ApplicationsAPIDeleteApplicationCallRequest) (*http.Response, error)

	/*
		DeleteApplicationCallFromNode Remove call from the node

		**Required ACL:** `calld.applications.{application_uuid}.nodes.{node_uuid}.calls.{call_id}.delete`

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param applicationUuid UUID of the application
		@param nodeUuid UUID of the node
		@param callId ID of the call
		@return ApplicationsAPIDeleteApplicationCallFromNodeRequest
	*/
	DeleteApplicationCallFromNode(ctx context.Context, applicationUuid string, nodeUuid string, callId string) ApplicationsAPIDeleteApplicationCallFromNodeRequest

	// DeleteApplicationCallFromNodeExecute executes the request
	DeleteApplicationCallFromNodeExecute(r ApplicationsAPIDeleteApplicationCallFromNodeRequest) (*http.Response, error)

	/*
		DeleteApplicationNode Delete node and hangup all calls

		**Required ACL:** `calld.applications.{application_uuid}.nodes.{node_uuid}.delete` **Not implemented**

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param applicationUuid UUID of the application
		@param nodeUuid UUID of the node
		@return ApplicationsAPIDeleteApplicationNodeRequest
	*/
	DeleteApplicationNode(ctx context.Context, applicationUuid string, nodeUuid string) ApplicationsAPIDeleteApplicationNodeRequest

	// DeleteApplicationNodeExecute executes the request
	DeleteApplicationNodeExecute(r ApplicationsAPIDeleteApplicationNodeRequest) (*http.Response, error)

	/*
		DeletePlayback Stop and remove playback

		**Required ACL:** `calld.applications.{application_uuid}.playbacks.{playback_uuid}.delete`

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param applicationUuid UUID of the application
		@param playbackUuid ID of the playback
		@return ApplicationsAPIDeletePlaybackRequest
	*/
	DeletePlayback(ctx context.Context, applicationUuid string, playbackUuid string) ApplicationsAPIDeletePlaybackRequest

	// DeletePlaybackExecute executes the request
	DeletePlaybackExecute(r ApplicationsAPIDeletePlaybackRequest) (*http.Response, error)

	/*
		GetApplication Show an application

		**Required ACL:** `calld.applications.{application_uuid}.read`

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param applicationUuid UUID of the application
		@return ApplicationsAPIGetApplicationRequest
	*/
	GetApplication(ctx context.Context, applicationUuid string) ApplicationsAPIGetApplicationRequest

	// GetApplicationExecute executes the request
	//  @return Application
	GetApplicationExecute(r ApplicationsAPIGetApplicationRequest) (*Application, *http.Response, error)

	/*
		GetApplicationCalls List calls from the application

		**Required ACL:** `calld.applications.{application_uuid}.calls.read`

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param applicationUuid UUID of the application
		@return ApplicationsAPIGetApplicationCallsRequest
	*/
	GetApplicationCalls(ctx context.Context, applicationUuid string) ApplicationsAPIGetApplicationCallsRequest

	// GetApplicationCallsExecute executes the request
	//  @return ApplicationCalls
	GetApplicationCallsExecute(r ApplicationsAPIGetApplicationCallsRequest) (*ApplicationCalls, *http.Response, error)

	/*
		GetApplicationNodes List nodes from the application

		**Required ACL:** `calld.applications.{application_uuid}.nodes.read`

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param applicationUuid UUID of the application
		@return ApplicationsAPIGetApplicationNodesRequest
	*/
	GetApplicationNodes(ctx context.Context, applicationUuid string) ApplicationsAPIGetApplicationNodesRequest

	// GetApplicationNodesExecute executes the request
	//  @return ApplicationNodes
	GetApplicationNodesExecute(r ApplicationsAPIGetApplicationNodesRequest) (*ApplicationNodes, *http.Response, error)

	/*
		GetNode Show a node

		**Required ACL:** `calld.applications.{application_uuid}.nodes.{node_uuid}.read`

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param applicationUuid UUID of the application
		@param nodeUuid UUID of the node
		@return ApplicationsAPIGetNodeRequest
	*/
	GetNode(ctx context.Context, applicationUuid string, nodeUuid string) ApplicationsAPIGetNodeRequest

	// GetNodeExecute executes the request
	//  @return ApplicationNode
	GetNodeExecute(r ApplicationsAPIGetNodeRequest) (*ApplicationNode, *http.Response, error)

	/*
		GetSnoop View snooping parameters

		**Required ACL:** `calld.applications.{application_uuid}.snoops.{snoop_uuid}.read`

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param applicationUuid UUID of the application
		@param snoopUuid UUID of the snoop
		@return ApplicationsAPIGetSnoopRequest
	*/
	GetSnoop(ctx context.Context, applicationUuid string, snoopUuid string) ApplicationsAPIGetSnoopRequest

	// GetSnoopExecute executes the request
	//  @return ApplicationSnoop
	GetSnoopExecute(r ApplicationsAPIGetSnoopRequest) (*ApplicationSnoop, *http.Response, error)

	/*
		HoldApplicationCall Place a call on hold

		**Required ACL:** `calld.applications.{application_uuid}.calls.{call_id}.hold.start.update`

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param applicationUuid UUID of the application
		@param callId ID of the call
		@return ApplicationsAPIHoldApplicationCallRequest
	*/
	HoldApplicationCall(ctx context.Context, applicationUuid string, callId string) ApplicationsAPIHoldApplicationCallRequest

	// HoldApplicationCallExecute executes the request
	HoldApplicationCallExecute(r ApplicationsAPIHoldApplicationCallRequest) (*http.Response, error)

	/*
		InsertApplicationCallToNode Insert call to the node

		**Required ACL:** `calld.applications.{application_uuid}.nodes.{node_uuid}.calls.{call_id}.update`

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param applicationUuid UUID of the application
		@param nodeUuid UUID of the node
		@param callId ID of the call
		@return ApplicationsAPIInsertApplicationCallToNodeRequest
	*/
	InsertApplicationCallToNode(ctx context.Context, applicationUuid string, nodeUuid string, callId string) ApplicationsAPIInsertApplicationCallToNodeRequest

	// InsertApplicationCallToNodeExecute executes the request
	InsertApplicationCallToNodeExecute(r ApplicationsAPIInsertApplicationCallToNodeRequest) (*http.Response, error)

	/*
		ListApplicationSnoops List active snoops

		**Required ACL:** `calld.applications.{application_uuid}.snoops.read`

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param applicationUuid UUID of the application
		@return ApplicationsAPIListApplicationSnoopsRequest
	*/
	ListApplicationSnoops(ctx context.Context, applicationUuid string) ApplicationsAPIListApplicationSnoopsRequest

	// ListApplicationSnoopsExecute executes the request
	//  @return ApplicationSnoops
	ListApplicationSnoopsExecute(r ApplicationsAPIListApplicationSnoopsRequest) (*ApplicationSnoops, *http.Response, error)

	/*
		MuteApplicationCall Mute a call

		**Required ACL:** `calld.applications.{application_uuid}.calls.{call_id}.mute.start.update`

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param applicationUuid UUID of the application
		@param callId ID of the call
		@return ApplicationsAPIMuteApplicationCallRequest
	*/
	MuteApplicationCall(ctx context.Context, applicationUuid string, callId string) ApplicationsAPIMuteApplicationCallRequest

	// MuteApplicationCallExecute executes the request
	MuteApplicationCallExecute(r ApplicationsAPIMuteApplicationCallRequest) (*http.Response, error)

	/*
		PlayApplicationCall Play file to the call

		**Required ACL:** `calld.applications.{application_uuid}.calls.{call_id}.playbacks.create`
	URI examples: * sound:tt-weasels * digits:4188001234 * number:321 * characters:abc * tone:ring * recording:my-recording

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param applicationUuid UUID of the application
		@param callId ID of the call
		@return ApplicationsAPIPlayApplicationCallRequest
	*/
	PlayApplicationCall(ctx context.Context, applicationUuid string, callId string) ApplicationsAPIPlayApplicationCallRequest

	// PlayApplicationCallExecute executes the request
	//  @return ApplicationPlayback
	PlayApplicationCallExecute(r ApplicationsAPIPlayApplicationCallRequest) (*ApplicationPlayback, *http.Response, error)

	/*
		ResumeApplicationCall Resume a call that has been placed on hold

		**Required ACL:** `calld.applications.{application_uuid}.calls.{call_id}.hold.stop.update

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param applicationUuid UUID of the application
		@param callId ID of the call
		@return ApplicationsAPIResumeApplicationCallRequest
	*/
	ResumeApplicationCall(ctx context.Context, applicationUuid string, callId string) ApplicationsAPIResumeApplicationCallRequest

	// ResumeApplicationCallExecute executes the request
	ResumeApplicationCallExecute(r ApplicationsAPIResumeApplicationCallRequest) (*http.Response, error)

	/*
		SendApplicationCallDTMF Simulate a user pressing DTMF keys

		**Required ACL:** `calld.applications.{application_uuid}.calls.{call_id}.dtmf.update

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param applicationUuid UUID of the application
		@param callId ID of the call
		@return ApplicationsAPISendApplicationCallDTMFRequest
	*/
	SendApplicationCallDTMF(ctx context.Context, applicationUuid string, callId string) ApplicationsAPISendApplicationCallDTMFRequest

	// SendApplicationCallDTMFExecute executes the request
	SendApplicationCallDTMFExecute(r ApplicationsAPISendApplicationCallDTMFRequest) (*http.Response, error)

	/*
		SnoopApplicationCall Start snooping on a call

		**Required ACL:** `calld.applications.{application_uuid}.calls.{call_id}.snoops.create`
	The whisper mode indicate which part of the snooped channel can hear the snooper. Given Alice calls Bob and Charles snoops on Bob * none: No one can hear the snooper * both: Alice and Bob can hear Charles * in: Alice can hear Charles * out: Bob can hear Charles

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param applicationUuid UUID of the application
		@param callId ID of the call
		@return ApplicationsAPISnoopApplicationCallRequest
	*/
	SnoopApplicationCall(ctx context.Context, applicationUuid string, callId string) ApplicationsAPISnoopApplicationCallRequest

	// SnoopApplicationCallExecute executes the request
	//  @return ApplicationSnoop
	SnoopApplicationCallExecute(r ApplicationsAPISnoopApplicationCallRequest) (*ApplicationSnoop, *http.Response, error)

	/*
		StartApplicationCallMOH Starts playing a music on hold

		**Required ACL:** `calld.applications.{application_uuid}.calls.{call_id}.moh.{moh_uuid}.start.update`
	Starts playing a music on hold on a call. If the music on hold is interrupted for a playback or another
	action, the music on hold will not restart automatically after the interruption.

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param applicationUuid UUID of the application
		@param callId ID of the call
		@param mohUuid UUID of the music on hold
		@return ApplicationsAPIStartApplicationCallMOHRequest
	*/
	StartApplicationCallMOH(ctx context.Context, applicationUuid string, callId string, mohUuid string) ApplicationsAPIStartApplicationCallMOHRequest

	// StartApplicationCallMOHExecute executes the request
	StartApplicationCallMOHExecute(r ApplicationsAPIStartApplicationCallMOHRequest) (*http.Response, error)

	/*
		StartApplicationCallProgress Play the progress ringing tone

		**Required ACL:** `calld.applications.{application_uuid}.calls.{call_id}.progress.start.update` The progress ringing tone is the sound heard by a caller while the other party is ringing.

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param applicationUuid UUID of the application
		@param callId ID of the call
		@return ApplicationsAPIStartApplicationCallProgressRequest
	*/
	StartApplicationCallProgress(ctx context.Context, applicationUuid string, callId string) ApplicationsAPIStartApplicationCallProgressRequest

	// StartApplicationCallProgressExecute executes the request
	StartApplicationCallProgressExecute(r ApplicationsAPIStartApplicationCallProgressRequest) (*http.Response, error)

	/*
		StopApplicationCallMOH Stops playing a music on hold

		**Required ACL:** `calld.applications.{application_uuid}.calls.{call_id}.moh.{moh_uuid}.stop.update

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param applicationUuid UUID of the application
		@param callId ID of the call
		@return ApplicationsAPIStopApplicationCallMOHRequest
	*/
	StopApplicationCallMOH(ctx context.Context, applicationUuid string, callId string) ApplicationsAPIStopApplicationCallMOHRequest

	// StopApplicationCallMOHExecute executes the request
	StopApplicationCallMOHExecute(r ApplicationsAPIStopApplicationCallMOHRequest) (*http.Response, error)

	/*
		StopApplicationCallProgress Stop playing the progress ringing tone.

		**Required ACL:** `calld.applications.{application_uuid}.calls.{call_id}.progress.stop.update` The progress ringing tone is the sound heard by a caller while the other party is ringing. Limitation: this only works when the ringing tone is played by Accent through audio media (e.g. when using `/progress` after `/answer`). If the phone is emitting the ringing tone directly to the user, then it cannot be stopped, and the response code will still be 204.

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param applicationUuid UUID of the application
		@param callId ID of the call
		@return ApplicationsAPIStopApplicationCallProgressRequest
	*/
	StopApplicationCallProgress(ctx context.Context, applicationUuid string, callId string) ApplicationsAPIStopApplicationCallProgressRequest

	// StopApplicationCallProgressExecute executes the request
	StopApplicationCallProgressExecute(r ApplicationsAPIStopApplicationCallProgressRequest) (*http.Response, error)

	/*
		StopSnoop Stop snooping

		**Required ACL:** `calld.applications.{application_uuid}.snoops.{snoop_uuid}.delete`

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param applicationUuid UUID of the application
		@param snoopUuid UUID of the snoop
		@return ApplicationsAPIStopSnoopRequest
	*/
	StopSnoop(ctx context.Context, applicationUuid string, snoopUuid string) ApplicationsAPIStopSnoopRequest

	// StopSnoopExecute executes the request
	StopSnoopExecute(r ApplicationsAPIStopSnoopRequest) (*http.Response, error)

	/*
		UnmuteApplicationCall Unmute a call

		**Required ACL:** `calld.applications.{application_uuid}.calls.{call_id}.mute.stop.update`

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param applicationUuid UUID of the application
		@param callId ID of the call
		@return ApplicationsAPIUnmuteApplicationCallRequest
	*/
	UnmuteApplicationCall(ctx context.Context, applicationUuid string, callId string) ApplicationsAPIUnmuteApplicationCallRequest

	// UnmuteApplicationCallExecute executes the request
	UnmuteApplicationCallExecute(r ApplicationsAPIUnmuteApplicationCallRequest) (*http.Response, error)

	/*
		UpdateSnoop Change snooping parameters

		**Required ACL:** `calld.applications.{application_uuid}.snoops.{snoop_uuid}.update`

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param applicationUuid UUID of the application
		@param snoopUuid UUID of the snoop
		@return ApplicationsAPIUpdateSnoopRequest
	*/
	UpdateSnoop(ctx context.Context, applicationUuid string, snoopUuid string) ApplicationsAPIUpdateSnoopRequest

	// UpdateSnoopExecute executes the request
	UpdateSnoopExecute(r ApplicationsAPIUpdateSnoopRequest) (*http.Response, error)
}

// ApplicationsAPIService ApplicationsAPI service
type ApplicationsAPIService service

type ApplicationsAPIAnswerApplicationCallRequest struct {
	ctx             context.Context
	ApiService      ApplicationsAPI
	applicationUuid string
	callId          string
}

func (r ApplicationsAPIAnswerApplicationCallRequest) Execute() (*http.Response, error) {
	return r.ApiService.AnswerApplicationCallExecute(r)
}

/*
AnswerApplicationCall Answer a call

**Required ACL:** `calld.applications.{application_uuid}.calls.{call_id}.answer.update`

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param applicationUuid UUID of the application
	@param callId ID of the call
	@return ApplicationsAPIAnswerApplicationCallRequest
*/
func (a *ApplicationsAPIService) AnswerApplicationCall(ctx context.Context, applicationUuid string, callId string) ApplicationsAPIAnswerApplicationCallRequest {
	return ApplicationsAPIAnswerApplicationCallRequest{
		ApiService:      a,
		ctx:             ctx,
		applicationUuid: applicationUuid,
		callId:          callId,
	}
}

// Execute executes the request
func (a *ApplicationsAPIService) AnswerApplicationCallExecute(r ApplicationsAPIAnswerApplicationCallRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodPut
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ApplicationsAPIService.AnswerApplicationCall")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/applications/{application_uuid}/calls/{call_id}/answer"
	localVarPath = strings.Replace(localVarPath, "{"+"application_uuid"+"}", url.PathEscape(parameterValueToString(r.applicationUuid, "applicationUuid")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"call_id"+"}", url.PathEscape(parameterValueToString(r.callId, "callId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["accent_auth_token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Auth-Token"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 503 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApplicationsAPICreateApplicationCallToNodeRequest struct {
	ctx             context.Context
	ApiService      ApplicationsAPI
	body            *ApplicationCallRequestToExten
	applicationUuid string
	nodeUuid        string
}

// Call parameters
func (r ApplicationsAPICreateApplicationCallToNodeRequest) Body(body ApplicationCallRequestToExten) ApplicationsAPICreateApplicationCallToNodeRequest {
	r.body = &body
	return r
}

func (r ApplicationsAPICreateApplicationCallToNodeRequest) Execute() (*ApplicationCall, *http.Response, error) {
	return r.ApiService.CreateApplicationCallToNodeExecute(r)
}

/*
CreateApplicationCallToNode Make a new call to the node

**Required ACL:** `calld.applications.{application_uuid}.nodes.{node_uuid}.calls.create`

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param applicationUuid UUID of the application
	@param nodeUuid UUID of the node
	@return ApplicationsAPICreateApplicationCallToNodeRequest
*/
func (a *ApplicationsAPIService) CreateApplicationCallToNode(ctx context.Context, applicationUuid string, nodeUuid string) ApplicationsAPICreateApplicationCallToNodeRequest {
	return ApplicationsAPICreateApplicationCallToNodeRequest{
		ApiService:      a,
		ctx:             ctx,
		applicationUuid: applicationUuid,
		nodeUuid:        nodeUuid,
	}
}

// Execute executes the request
//
//	@return ApplicationCall
func (a *ApplicationsAPIService) CreateApplicationCallToNodeExecute(r ApplicationsAPICreateApplicationCallToNodeRequest) (*ApplicationCall, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *ApplicationCall
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ApplicationsAPIService.CreateApplicationCallToNode")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/applications/{application_uuid}/nodes/{node_uuid}/calls"
	localVarPath = strings.Replace(localVarPath, "{"+"application_uuid"+"}", url.PathEscape(parameterValueToString(r.applicationUuid, "applicationUuid")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"node_uuid"+"}", url.PathEscape(parameterValueToString(r.nodeUuid, "nodeUuid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("body is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["accent_auth_token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Auth-Token"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 503 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApplicationsAPICreateApplicationCallToUserRequest struct {
	ctx             context.Context
	ApiService      ApplicationsAPI
	body            *ApplicationCallRequestToUser
	applicationUuid string
	nodeUuid        string
}

// Parameters for the new call
func (r ApplicationsAPICreateApplicationCallToUserRequest) Body(body ApplicationCallRequestToUser) ApplicationsAPICreateApplicationCallToUserRequest {
	r.body = &body
	return r
}

func (r ApplicationsAPICreateApplicationCallToUserRequest) Execute() (*ApplicationCall, *http.Response, error) {
	return r.ApiService.CreateApplicationCallToUserExecute(r)
}

/*
CreateApplicationCallToUser Initiate a call to a user and insert it in the node

**Required ACL:** `calld.applications.{application_uuid}.nodes.{node_uuid}.calls.user.create`

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param applicationUuid UUID of the application
	@param nodeUuid UUID of the node
	@return ApplicationsAPICreateApplicationCallToUserRequest
*/
func (a *ApplicationsAPIService) CreateApplicationCallToUser(ctx context.Context, applicationUuid string, nodeUuid string) ApplicationsAPICreateApplicationCallToUserRequest {
	return ApplicationsAPICreateApplicationCallToUserRequest{
		ApiService:      a,
		ctx:             ctx,
		applicationUuid: applicationUuid,
		nodeUuid:        nodeUuid,
	}
}

// Execute executes the request
//
//	@return ApplicationCall
func (a *ApplicationsAPIService) CreateApplicationCallToUserExecute(r ApplicationsAPICreateApplicationCallToUserRequest) (*ApplicationCall, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *ApplicationCall
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ApplicationsAPIService.CreateApplicationCallToUser")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/applications/{application_uuid}/nodes/{node_uuid}/calls/user"
	localVarPath = strings.Replace(localVarPath, "{"+"application_uuid"+"}", url.PathEscape(parameterValueToString(r.applicationUuid, "applicationUuid")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"node_uuid"+"}", url.PathEscape(parameterValueToString(r.nodeUuid, "nodeUuid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("body is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["accent_auth_token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Auth-Token"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 503 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApplicationsAPICreateApplicationCallsRequest struct {
	ctx             context.Context
	ApiService      ApplicationsAPI
	body            *ApplicationCallRequestToExten
	applicationUuid string
}

// node parameters
func (r ApplicationsAPICreateApplicationCallsRequest) Body(body ApplicationCallRequestToExten) ApplicationsAPICreateApplicationCallsRequest {
	r.body = &body
	return r
}

func (r ApplicationsAPICreateApplicationCallsRequest) Execute() (*ApplicationCall, *http.Response, error) {
	return r.ApiService.CreateApplicationCallsExecute(r)
}

/*
CreateApplicationCalls Make a new call to the application

**Required ACL:** `calld.applications.{application_uuid}.calls.create`

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param applicationUuid UUID of the application
	@return ApplicationsAPICreateApplicationCallsRequest
*/
func (a *ApplicationsAPIService) CreateApplicationCalls(ctx context.Context, applicationUuid string) ApplicationsAPICreateApplicationCallsRequest {
	return ApplicationsAPICreateApplicationCallsRequest{
		ApiService:      a,
		ctx:             ctx,
		applicationUuid: applicationUuid,
	}
}

// Execute executes the request
//
//	@return ApplicationCall
func (a *ApplicationsAPIService) CreateApplicationCallsExecute(r ApplicationsAPICreateApplicationCallsRequest) (*ApplicationCall, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *ApplicationCall
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ApplicationsAPIService.CreateApplicationCalls")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/applications/{application_uuid}/calls"
	localVarPath = strings.Replace(localVarPath, "{"+"application_uuid"+"}", url.PathEscape(parameterValueToString(r.applicationUuid, "applicationUuid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("body is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["accent_auth_token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Auth-Token"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 503 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApplicationsAPICreateApplicationNodeRequest struct {
	ctx             context.Context
	ApiService      ApplicationsAPI
	body            *ApplicationNodeRequest
	applicationUuid string
}

// node parameters
func (r ApplicationsAPICreateApplicationNodeRequest) Body(body ApplicationNodeRequest) ApplicationsAPICreateApplicationNodeRequest {
	r.body = &body
	return r
}

func (r ApplicationsAPICreateApplicationNodeRequest) Execute() (*ApplicationNode, *http.Response, error) {
	return r.ApiService.CreateApplicationNodeExecute(r)
}

/*
CreateApplicationNode Make a new node and add calls

**Required ACL:** `calld.applications.{application_uuid}.nodes.create`

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param applicationUuid UUID of the application
	@return ApplicationsAPICreateApplicationNodeRequest
*/
func (a *ApplicationsAPIService) CreateApplicationNode(ctx context.Context, applicationUuid string) ApplicationsAPICreateApplicationNodeRequest {
	return ApplicationsAPICreateApplicationNodeRequest{
		ApiService:      a,
		ctx:             ctx,
		applicationUuid: applicationUuid,
	}
}

// Execute executes the request
//
//	@return ApplicationNode
func (a *ApplicationsAPIService) CreateApplicationNodeExecute(r ApplicationsAPICreateApplicationNodeRequest) (*ApplicationNode, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *ApplicationNode
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ApplicationsAPIService.CreateApplicationNode")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/applications/{application_uuid}/nodes"
	localVarPath = strings.Replace(localVarPath, "{"+"application_uuid"+"}", url.PathEscape(parameterValueToString(r.applicationUuid, "applicationUuid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("body is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["accent_auth_token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Auth-Token"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 503 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApplicationsAPIDeleteApplicationCallRequest struct {
	ctx             context.Context
	ApiService      ApplicationsAPI
	applicationUuid string
	callId          string
}

func (r ApplicationsAPIDeleteApplicationCallRequest) Execute() (*http.Response, error) {
	return r.ApiService.DeleteApplicationCallExecute(r)
}

/*
DeleteApplicationCall Hangup a call from the application

**Required ACL:** `calld.applications.{application_uuid}.calls.{call_id}.delete`

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param applicationUuid UUID of the application
	@param callId ID of the call
	@return ApplicationsAPIDeleteApplicationCallRequest
*/
func (a *ApplicationsAPIService) DeleteApplicationCall(ctx context.Context, applicationUuid string, callId string) ApplicationsAPIDeleteApplicationCallRequest {
	return ApplicationsAPIDeleteApplicationCallRequest{
		ApiService:      a,
		ctx:             ctx,
		applicationUuid: applicationUuid,
		callId:          callId,
	}
}

// Execute executes the request
func (a *ApplicationsAPIService) DeleteApplicationCallExecute(r ApplicationsAPIDeleteApplicationCallRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodDelete
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ApplicationsAPIService.DeleteApplicationCall")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/applications/{application_uuid}/calls/{call_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"application_uuid"+"}", url.PathEscape(parameterValueToString(r.applicationUuid, "applicationUuid")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"call_id"+"}", url.PathEscape(parameterValueToString(r.callId, "callId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["accent_auth_token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Auth-Token"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 503 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApplicationsAPIDeleteApplicationCallFromNodeRequest struct {
	ctx             context.Context
	ApiService      ApplicationsAPI
	applicationUuid string
	nodeUuid        string
	callId          string
}

func (r ApplicationsAPIDeleteApplicationCallFromNodeRequest) Execute() (*http.Response, error) {
	return r.ApiService.DeleteApplicationCallFromNodeExecute(r)
}

/*
DeleteApplicationCallFromNode Remove call from the node

**Required ACL:** `calld.applications.{application_uuid}.nodes.{node_uuid}.calls.{call_id}.delete`

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param applicationUuid UUID of the application
	@param nodeUuid UUID of the node
	@param callId ID of the call
	@return ApplicationsAPIDeleteApplicationCallFromNodeRequest
*/
func (a *ApplicationsAPIService) DeleteApplicationCallFromNode(ctx context.Context, applicationUuid string, nodeUuid string, callId string) ApplicationsAPIDeleteApplicationCallFromNodeRequest {
	return ApplicationsAPIDeleteApplicationCallFromNodeRequest{
		ApiService:      a,
		ctx:             ctx,
		applicationUuid: applicationUuid,
		nodeUuid:        nodeUuid,
		callId:          callId,
	}
}

// Execute executes the request
func (a *ApplicationsAPIService) DeleteApplicationCallFromNodeExecute(r ApplicationsAPIDeleteApplicationCallFromNodeRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodDelete
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ApplicationsAPIService.DeleteApplicationCallFromNode")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/applications/{application_uuid}/nodes/{node_uuid}/calls/{call_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"application_uuid"+"}", url.PathEscape(parameterValueToString(r.applicationUuid, "applicationUuid")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"node_uuid"+"}", url.PathEscape(parameterValueToString(r.nodeUuid, "nodeUuid")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"call_id"+"}", url.PathEscape(parameterValueToString(r.callId, "callId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["accent_auth_token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Auth-Token"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 503 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApplicationsAPIDeleteApplicationNodeRequest struct {
	ctx             context.Context
	ApiService      ApplicationsAPI
	applicationUuid string
	nodeUuid        string
}

func (r ApplicationsAPIDeleteApplicationNodeRequest) Execute() (*http.Response, error) {
	return r.ApiService.DeleteApplicationNodeExecute(r)
}

/*
DeleteApplicationNode Delete node and hangup all calls

**Required ACL:** `calld.applications.{application_uuid}.nodes.{node_uuid}.delete` **Not implemented**

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param applicationUuid UUID of the application
	@param nodeUuid UUID of the node
	@return ApplicationsAPIDeleteApplicationNodeRequest
*/
func (a *ApplicationsAPIService) DeleteApplicationNode(ctx context.Context, applicationUuid string, nodeUuid string) ApplicationsAPIDeleteApplicationNodeRequest {
	return ApplicationsAPIDeleteApplicationNodeRequest{
		ApiService:      a,
		ctx:             ctx,
		applicationUuid: applicationUuid,
		nodeUuid:        nodeUuid,
	}
}

// Execute executes the request
func (a *ApplicationsAPIService) DeleteApplicationNodeExecute(r ApplicationsAPIDeleteApplicationNodeRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodDelete
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ApplicationsAPIService.DeleteApplicationNode")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/applications/{application_uuid}/nodes/{node_uuid}"
	localVarPath = strings.Replace(localVarPath, "{"+"application_uuid"+"}", url.PathEscape(parameterValueToString(r.applicationUuid, "applicationUuid")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"node_uuid"+"}", url.PathEscape(parameterValueToString(r.nodeUuid, "nodeUuid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["accent_auth_token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Auth-Token"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 503 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApplicationsAPIDeletePlaybackRequest struct {
	ctx             context.Context
	ApiService      ApplicationsAPI
	applicationUuid string
	playbackUuid    string
}

func (r ApplicationsAPIDeletePlaybackRequest) Execute() (*http.Response, error) {
	return r.ApiService.DeletePlaybackExecute(r)
}

/*
DeletePlayback Stop and remove playback

**Required ACL:** `calld.applications.{application_uuid}.playbacks.{playback_uuid}.delete`

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param applicationUuid UUID of the application
	@param playbackUuid ID of the playback
	@return ApplicationsAPIDeletePlaybackRequest
*/
func (a *ApplicationsAPIService) DeletePlayback(ctx context.Context, applicationUuid string, playbackUuid string) ApplicationsAPIDeletePlaybackRequest {
	return ApplicationsAPIDeletePlaybackRequest{
		ApiService:      a,
		ctx:             ctx,
		applicationUuid: applicationUuid,
		playbackUuid:    playbackUuid,
	}
}

// Execute executes the request
func (a *ApplicationsAPIService) DeletePlaybackExecute(r ApplicationsAPIDeletePlaybackRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodDelete
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ApplicationsAPIService.DeletePlayback")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/applications/{application_uuid}/playbacks/{playback_uuid}"
	localVarPath = strings.Replace(localVarPath, "{"+"application_uuid"+"}", url.PathEscape(parameterValueToString(r.applicationUuid, "applicationUuid")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"playback_uuid"+"}", url.PathEscape(parameterValueToString(r.playbackUuid, "playbackUuid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["accent_auth_token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Auth-Token"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 503 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApplicationsAPIGetApplicationRequest struct {
	ctx             context.Context
	ApiService      ApplicationsAPI
	applicationUuid string
}

func (r ApplicationsAPIGetApplicationRequest) Execute() (*Application, *http.Response, error) {
	return r.ApiService.GetApplicationExecute(r)
}

/*
GetApplication Show an application

**Required ACL:** `calld.applications.{application_uuid}.read`

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param applicationUuid UUID of the application
	@return ApplicationsAPIGetApplicationRequest
*/
func (a *ApplicationsAPIService) GetApplication(ctx context.Context, applicationUuid string) ApplicationsAPIGetApplicationRequest {
	return ApplicationsAPIGetApplicationRequest{
		ApiService:      a,
		ctx:             ctx,
		applicationUuid: applicationUuid,
	}
}

// Execute executes the request
//
//	@return Application
func (a *ApplicationsAPIService) GetApplicationExecute(r ApplicationsAPIGetApplicationRequest) (*Application, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *Application
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ApplicationsAPIService.GetApplication")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/applications/{application_uuid}"
	localVarPath = strings.Replace(localVarPath, "{"+"application_uuid"+"}", url.PathEscape(parameterValueToString(r.applicationUuid, "applicationUuid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["accent_auth_token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Auth-Token"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 503 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApplicationsAPIGetApplicationCallsRequest struct {
	ctx             context.Context
	ApiService      ApplicationsAPI
	applicationUuid string
}

func (r ApplicationsAPIGetApplicationCallsRequest) Execute() (*ApplicationCalls, *http.Response, error) {
	return r.ApiService.GetApplicationCallsExecute(r)
}

/*
GetApplicationCalls List calls from the application

**Required ACL:** `calld.applications.{application_uuid}.calls.read`

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param applicationUuid UUID of the application
	@return ApplicationsAPIGetApplicationCallsRequest
*/
func (a *ApplicationsAPIService) GetApplicationCalls(ctx context.Context, applicationUuid string) ApplicationsAPIGetApplicationCallsRequest {
	return ApplicationsAPIGetApplicationCallsRequest{
		ApiService:      a,
		ctx:             ctx,
		applicationUuid: applicationUuid,
	}
}

// Execute executes the request
//
//	@return ApplicationCalls
func (a *ApplicationsAPIService) GetApplicationCallsExecute(r ApplicationsAPIGetApplicationCallsRequest) (*ApplicationCalls, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *ApplicationCalls
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ApplicationsAPIService.GetApplicationCalls")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/applications/{application_uuid}/calls"
	localVarPath = strings.Replace(localVarPath, "{"+"application_uuid"+"}", url.PathEscape(parameterValueToString(r.applicationUuid, "applicationUuid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["accent_auth_token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Auth-Token"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 503 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApplicationsAPIGetApplicationNodesRequest struct {
	ctx             context.Context
	ApiService      ApplicationsAPI
	applicationUuid string
}

func (r ApplicationsAPIGetApplicationNodesRequest) Execute() (*ApplicationNodes, *http.Response, error) {
	return r.ApiService.GetApplicationNodesExecute(r)
}

/*
GetApplicationNodes List nodes from the application

**Required ACL:** `calld.applications.{application_uuid}.nodes.read`

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param applicationUuid UUID of the application
	@return ApplicationsAPIGetApplicationNodesRequest
*/
func (a *ApplicationsAPIService) GetApplicationNodes(ctx context.Context, applicationUuid string) ApplicationsAPIGetApplicationNodesRequest {
	return ApplicationsAPIGetApplicationNodesRequest{
		ApiService:      a,
		ctx:             ctx,
		applicationUuid: applicationUuid,
	}
}

// Execute executes the request
//
//	@return ApplicationNodes
func (a *ApplicationsAPIService) GetApplicationNodesExecute(r ApplicationsAPIGetApplicationNodesRequest) (*ApplicationNodes, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *ApplicationNodes
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ApplicationsAPIService.GetApplicationNodes")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/applications/{application_uuid}/nodes"
	localVarPath = strings.Replace(localVarPath, "{"+"application_uuid"+"}", url.PathEscape(parameterValueToString(r.applicationUuid, "applicationUuid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["accent_auth_token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Auth-Token"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 503 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApplicationsAPIGetNodeRequest struct {
	ctx             context.Context
	ApiService      ApplicationsAPI
	applicationUuid string
	nodeUuid        string
}

func (r ApplicationsAPIGetNodeRequest) Execute() (*ApplicationNode, *http.Response, error) {
	return r.ApiService.GetNodeExecute(r)
}

/*
GetNode Show a node

**Required ACL:** `calld.applications.{application_uuid}.nodes.{node_uuid}.read`

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param applicationUuid UUID of the application
	@param nodeUuid UUID of the node
	@return ApplicationsAPIGetNodeRequest
*/
func (a *ApplicationsAPIService) GetNode(ctx context.Context, applicationUuid string, nodeUuid string) ApplicationsAPIGetNodeRequest {
	return ApplicationsAPIGetNodeRequest{
		ApiService:      a,
		ctx:             ctx,
		applicationUuid: applicationUuid,
		nodeUuid:        nodeUuid,
	}
}

// Execute executes the request
//
//	@return ApplicationNode
func (a *ApplicationsAPIService) GetNodeExecute(r ApplicationsAPIGetNodeRequest) (*ApplicationNode, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *ApplicationNode
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ApplicationsAPIService.GetNode")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/applications/{application_uuid}/nodes/{node_uuid}"
	localVarPath = strings.Replace(localVarPath, "{"+"application_uuid"+"}", url.PathEscape(parameterValueToString(r.applicationUuid, "applicationUuid")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"node_uuid"+"}", url.PathEscape(parameterValueToString(r.nodeUuid, "nodeUuid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["accent_auth_token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Auth-Token"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 503 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApplicationsAPIGetSnoopRequest struct {
	ctx             context.Context
	ApiService      ApplicationsAPI
	applicationUuid string
	snoopUuid       string
}

func (r ApplicationsAPIGetSnoopRequest) Execute() (*ApplicationSnoop, *http.Response, error) {
	return r.ApiService.GetSnoopExecute(r)
}

/*
GetSnoop View snooping parameters

**Required ACL:** `calld.applications.{application_uuid}.snoops.{snoop_uuid}.read`

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param applicationUuid UUID of the application
	@param snoopUuid UUID of the snoop
	@return ApplicationsAPIGetSnoopRequest
*/
func (a *ApplicationsAPIService) GetSnoop(ctx context.Context, applicationUuid string, snoopUuid string) ApplicationsAPIGetSnoopRequest {
	return ApplicationsAPIGetSnoopRequest{
		ApiService:      a,
		ctx:             ctx,
		applicationUuid: applicationUuid,
		snoopUuid:       snoopUuid,
	}
}

// Execute executes the request
//
//	@return ApplicationSnoop
func (a *ApplicationsAPIService) GetSnoopExecute(r ApplicationsAPIGetSnoopRequest) (*ApplicationSnoop, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *ApplicationSnoop
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ApplicationsAPIService.GetSnoop")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/applications/{application_uuid}/snoops/{snoop_uuid}"
	localVarPath = strings.Replace(localVarPath, "{"+"application_uuid"+"}", url.PathEscape(parameterValueToString(r.applicationUuid, "applicationUuid")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"snoop_uuid"+"}", url.PathEscape(parameterValueToString(r.snoopUuid, "snoopUuid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["accent_auth_token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Auth-Token"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 503 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApplicationsAPIHoldApplicationCallRequest struct {
	ctx             context.Context
	ApiService      ApplicationsAPI
	applicationUuid string
	callId          string
}

func (r ApplicationsAPIHoldApplicationCallRequest) Execute() (*http.Response, error) {
	return r.ApiService.HoldApplicationCallExecute(r)
}

/*
HoldApplicationCall Place a call on hold

**Required ACL:** `calld.applications.{application_uuid}.calls.{call_id}.hold.start.update`

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param applicationUuid UUID of the application
	@param callId ID of the call
	@return ApplicationsAPIHoldApplicationCallRequest
*/
func (a *ApplicationsAPIService) HoldApplicationCall(ctx context.Context, applicationUuid string, callId string) ApplicationsAPIHoldApplicationCallRequest {
	return ApplicationsAPIHoldApplicationCallRequest{
		ApiService:      a,
		ctx:             ctx,
		applicationUuid: applicationUuid,
		callId:          callId,
	}
}

// Execute executes the request
func (a *ApplicationsAPIService) HoldApplicationCallExecute(r ApplicationsAPIHoldApplicationCallRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodPut
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ApplicationsAPIService.HoldApplicationCall")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/applications/{application_uuid}/calls/{call_id}/hold/start"
	localVarPath = strings.Replace(localVarPath, "{"+"application_uuid"+"}", url.PathEscape(parameterValueToString(r.applicationUuid, "applicationUuid")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"call_id"+"}", url.PathEscape(parameterValueToString(r.callId, "callId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["accent_auth_token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Auth-Token"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 503 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApplicationsAPIInsertApplicationCallToNodeRequest struct {
	ctx             context.Context
	ApiService      ApplicationsAPI
	applicationUuid string
	nodeUuid        string
	callId          string
}

func (r ApplicationsAPIInsertApplicationCallToNodeRequest) Execute() (*http.Response, error) {
	return r.ApiService.InsertApplicationCallToNodeExecute(r)
}

/*
InsertApplicationCallToNode Insert call to the node

**Required ACL:** `calld.applications.{application_uuid}.nodes.{node_uuid}.calls.{call_id}.update`

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param applicationUuid UUID of the application
	@param nodeUuid UUID of the node
	@param callId ID of the call
	@return ApplicationsAPIInsertApplicationCallToNodeRequest
*/
func (a *ApplicationsAPIService) InsertApplicationCallToNode(ctx context.Context, applicationUuid string, nodeUuid string, callId string) ApplicationsAPIInsertApplicationCallToNodeRequest {
	return ApplicationsAPIInsertApplicationCallToNodeRequest{
		ApiService:      a,
		ctx:             ctx,
		applicationUuid: applicationUuid,
		nodeUuid:        nodeUuid,
		callId:          callId,
	}
}

// Execute executes the request
func (a *ApplicationsAPIService) InsertApplicationCallToNodeExecute(r ApplicationsAPIInsertApplicationCallToNodeRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodPut
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ApplicationsAPIService.InsertApplicationCallToNode")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/applications/{application_uuid}/nodes/{node_uuid}/calls/{call_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"application_uuid"+"}", url.PathEscape(parameterValueToString(r.applicationUuid, "applicationUuid")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"node_uuid"+"}", url.PathEscape(parameterValueToString(r.nodeUuid, "nodeUuid")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"call_id"+"}", url.PathEscape(parameterValueToString(r.callId, "callId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["accent_auth_token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Auth-Token"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 503 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApplicationsAPIListApplicationSnoopsRequest struct {
	ctx             context.Context
	ApiService      ApplicationsAPI
	applicationUuid string
}

func (r ApplicationsAPIListApplicationSnoopsRequest) Execute() (*ApplicationSnoops, *http.Response, error) {
	return r.ApiService.ListApplicationSnoopsExecute(r)
}

/*
ListApplicationSnoops List active snoops

**Required ACL:** `calld.applications.{application_uuid}.snoops.read`

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param applicationUuid UUID of the application
	@return ApplicationsAPIListApplicationSnoopsRequest
*/
func (a *ApplicationsAPIService) ListApplicationSnoops(ctx context.Context, applicationUuid string) ApplicationsAPIListApplicationSnoopsRequest {
	return ApplicationsAPIListApplicationSnoopsRequest{
		ApiService:      a,
		ctx:             ctx,
		applicationUuid: applicationUuid,
	}
}

// Execute executes the request
//
//	@return ApplicationSnoops
func (a *ApplicationsAPIService) ListApplicationSnoopsExecute(r ApplicationsAPIListApplicationSnoopsRequest) (*ApplicationSnoops, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *ApplicationSnoops
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ApplicationsAPIService.ListApplicationSnoops")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/applications/{application_uuid}/snoops"
	localVarPath = strings.Replace(localVarPath, "{"+"application_uuid"+"}", url.PathEscape(parameterValueToString(r.applicationUuid, "applicationUuid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["accent_auth_token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Auth-Token"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 503 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApplicationsAPIMuteApplicationCallRequest struct {
	ctx             context.Context
	ApiService      ApplicationsAPI
	applicationUuid string
	callId          string
}

func (r ApplicationsAPIMuteApplicationCallRequest) Execute() (*http.Response, error) {
	return r.ApiService.MuteApplicationCallExecute(r)
}

/*
MuteApplicationCall Mute a call

**Required ACL:** `calld.applications.{application_uuid}.calls.{call_id}.mute.start.update`

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param applicationUuid UUID of the application
	@param callId ID of the call
	@return ApplicationsAPIMuteApplicationCallRequest
*/
func (a *ApplicationsAPIService) MuteApplicationCall(ctx context.Context, applicationUuid string, callId string) ApplicationsAPIMuteApplicationCallRequest {
	return ApplicationsAPIMuteApplicationCallRequest{
		ApiService:      a,
		ctx:             ctx,
		applicationUuid: applicationUuid,
		callId:          callId,
	}
}

// Execute executes the request
func (a *ApplicationsAPIService) MuteApplicationCallExecute(r ApplicationsAPIMuteApplicationCallRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodPut
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ApplicationsAPIService.MuteApplicationCall")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/applications/{application_uuid}/calls/{call_id}/mute/start"
	localVarPath = strings.Replace(localVarPath, "{"+"application_uuid"+"}", url.PathEscape(parameterValueToString(r.applicationUuid, "applicationUuid")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"call_id"+"}", url.PathEscape(parameterValueToString(r.callId, "callId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["accent_auth_token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Auth-Token"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 503 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApplicationsAPIPlayApplicationCallRequest struct {
	ctx             context.Context
	ApiService      ApplicationsAPI
	body            *ApplicationPlayback
	applicationUuid string
	callId          string
}

// playback parameters
func (r ApplicationsAPIPlayApplicationCallRequest) Body(body ApplicationPlayback) ApplicationsAPIPlayApplicationCallRequest {
	r.body = &body
	return r
}

func (r ApplicationsAPIPlayApplicationCallRequest) Execute() (*ApplicationPlayback, *http.Response, error) {
	return r.ApiService.PlayApplicationCallExecute(r)
}

/*
PlayApplicationCall Play file to the call

**Required ACL:** `calld.applications.{application_uuid}.calls.{call_id}.playbacks.create`
URI examples: * sound:tt-weasels * digits:4188001234 * number:321 * characters:abc * tone:ring * recording:my-recording

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param applicationUuid UUID of the application
	@param callId ID of the call
	@return ApplicationsAPIPlayApplicationCallRequest
*/
func (a *ApplicationsAPIService) PlayApplicationCall(ctx context.Context, applicationUuid string, callId string) ApplicationsAPIPlayApplicationCallRequest {
	return ApplicationsAPIPlayApplicationCallRequest{
		ApiService:      a,
		ctx:             ctx,
		applicationUuid: applicationUuid,
		callId:          callId,
	}
}

// Execute executes the request
//
//	@return ApplicationPlayback
func (a *ApplicationsAPIService) PlayApplicationCallExecute(r ApplicationsAPIPlayApplicationCallRequest) (*ApplicationPlayback, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *ApplicationPlayback
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ApplicationsAPIService.PlayApplicationCall")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/applications/{application_uuid}/calls/{call_id}/playbacks"
	localVarPath = strings.Replace(localVarPath, "{"+"application_uuid"+"}", url.PathEscape(parameterValueToString(r.applicationUuid, "applicationUuid")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"call_id"+"}", url.PathEscape(parameterValueToString(r.callId, "callId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("body is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["accent_auth_token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Auth-Token"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 503 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApplicationsAPIResumeApplicationCallRequest struct {
	ctx             context.Context
	ApiService      ApplicationsAPI
	applicationUuid string
	callId          string
}

func (r ApplicationsAPIResumeApplicationCallRequest) Execute() (*http.Response, error) {
	return r.ApiService.ResumeApplicationCallExecute(r)
}

/*
ResumeApplicationCall Resume a call that has been placed on hold

**Required ACL:** `calld.applications.{application_uuid}.calls.{call_id}.hold.stop.update

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param applicationUuid UUID of the application
	@param callId ID of the call
	@return ApplicationsAPIResumeApplicationCallRequest
*/
func (a *ApplicationsAPIService) ResumeApplicationCall(ctx context.Context, applicationUuid string, callId string) ApplicationsAPIResumeApplicationCallRequest {
	return ApplicationsAPIResumeApplicationCallRequest{
		ApiService:      a,
		ctx:             ctx,
		applicationUuid: applicationUuid,
		callId:          callId,
	}
}

// Execute executes the request
func (a *ApplicationsAPIService) ResumeApplicationCallExecute(r ApplicationsAPIResumeApplicationCallRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodPut
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ApplicationsAPIService.ResumeApplicationCall")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/applications/{application_uuid}/calls/{call_id}/hold/stop"
	localVarPath = strings.Replace(localVarPath, "{"+"application_uuid"+"}", url.PathEscape(parameterValueToString(r.applicationUuid, "applicationUuid")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"call_id"+"}", url.PathEscape(parameterValueToString(r.callId, "callId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["accent_auth_token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Auth-Token"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 503 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApplicationsAPISendApplicationCallDTMFRequest struct {
	ctx             context.Context
	ApiService      ApplicationsAPI
	applicationUuid string
	callId          string
	digits          *string
}

// Digits to send via DTMF. Must contain only &#x60;0-9*#&#x60;.
func (r ApplicationsAPISendApplicationCallDTMFRequest) Digits(digits string) ApplicationsAPISendApplicationCallDTMFRequest {
	r.digits = &digits
	return r
}

func (r ApplicationsAPISendApplicationCallDTMFRequest) Execute() (*http.Response, error) {
	return r.ApiService.SendApplicationCallDTMFExecute(r)
}

/*
SendApplicationCallDTMF Simulate a user pressing DTMF keys

**Required ACL:** `calld.applications.{application_uuid}.calls.{call_id}.dtmf.update

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param applicationUuid UUID of the application
	@param callId ID of the call
	@return ApplicationsAPISendApplicationCallDTMFRequest
*/
func (a *ApplicationsAPIService) SendApplicationCallDTMF(ctx context.Context, applicationUuid string, callId string) ApplicationsAPISendApplicationCallDTMFRequest {
	return ApplicationsAPISendApplicationCallDTMFRequest{
		ApiService:      a,
		ctx:             ctx,
		applicationUuid: applicationUuid,
		callId:          callId,
	}
}

// Execute executes the request
func (a *ApplicationsAPIService) SendApplicationCallDTMFExecute(r ApplicationsAPISendApplicationCallDTMFRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodPut
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ApplicationsAPIService.SendApplicationCallDTMF")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/applications/{application_uuid}/calls/{call_id}/dtmf"
	localVarPath = strings.Replace(localVarPath, "{"+"application_uuid"+"}", url.PathEscape(parameterValueToString(r.applicationUuid, "applicationUuid")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"call_id"+"}", url.PathEscape(parameterValueToString(r.callId, "callId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.digits == nil {
		return nil, reportError("digits is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "digits", r.digits, "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["accent_auth_token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Auth-Token"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 503 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApplicationsAPISnoopApplicationCallRequest struct {
	ctx             context.Context
	ApiService      ApplicationsAPI
	body            *ApplicationSnoop
	applicationUuid string
	callId          string
}

// snoop parameters
func (r ApplicationsAPISnoopApplicationCallRequest) Body(body ApplicationSnoop) ApplicationsAPISnoopApplicationCallRequest {
	r.body = &body
	return r
}

func (r ApplicationsAPISnoopApplicationCallRequest) Execute() (*ApplicationSnoop, *http.Response, error) {
	return r.ApiService.SnoopApplicationCallExecute(r)
}

/*
SnoopApplicationCall Start snooping on a call

**Required ACL:** `calld.applications.{application_uuid}.calls.{call_id}.snoops.create`
The whisper mode indicate which part of the snooped channel can hear the snooper. Given Alice calls Bob and Charles snoops on Bob * none: No one can hear the snooper * both: Alice and Bob can hear Charles * in: Alice can hear Charles * out: Bob can hear Charles

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param applicationUuid UUID of the application
	@param callId ID of the call
	@return ApplicationsAPISnoopApplicationCallRequest
*/
func (a *ApplicationsAPIService) SnoopApplicationCall(ctx context.Context, applicationUuid string, callId string) ApplicationsAPISnoopApplicationCallRequest {
	return ApplicationsAPISnoopApplicationCallRequest{
		ApiService:      a,
		ctx:             ctx,
		applicationUuid: applicationUuid,
		callId:          callId,
	}
}

// Execute executes the request
//
//	@return ApplicationSnoop
func (a *ApplicationsAPIService) SnoopApplicationCallExecute(r ApplicationsAPISnoopApplicationCallRequest) (*ApplicationSnoop, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *ApplicationSnoop
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ApplicationsAPIService.SnoopApplicationCall")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/applications/{application_uuid}/calls/{call_id}/snoops"
	localVarPath = strings.Replace(localVarPath, "{"+"application_uuid"+"}", url.PathEscape(parameterValueToString(r.applicationUuid, "applicationUuid")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"call_id"+"}", url.PathEscape(parameterValueToString(r.callId, "callId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("body is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["accent_auth_token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Auth-Token"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 503 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApplicationsAPIStartApplicationCallMOHRequest struct {
	ctx             context.Context
	ApiService      ApplicationsAPI
	applicationUuid string
	callId          string
	mohUuid         string
}

func (r ApplicationsAPIStartApplicationCallMOHRequest) Execute() (*http.Response, error) {
	return r.ApiService.StartApplicationCallMOHExecute(r)
}

/*
StartApplicationCallMOH Starts playing a music on hold

**Required ACL:** `calld.applications.{application_uuid}.calls.{call_id}.moh.{moh_uuid}.start.update`
Starts playing a music on hold on a call. If the music on hold is interrupted for a playback or another
action, the music on hold will not restart automatically after the interruption.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param applicationUuid UUID of the application
	@param callId ID of the call
	@param mohUuid UUID of the music on hold
	@return ApplicationsAPIStartApplicationCallMOHRequest
*/
func (a *ApplicationsAPIService) StartApplicationCallMOH(ctx context.Context, applicationUuid string, callId string, mohUuid string) ApplicationsAPIStartApplicationCallMOHRequest {
	return ApplicationsAPIStartApplicationCallMOHRequest{
		ApiService:      a,
		ctx:             ctx,
		applicationUuid: applicationUuid,
		callId:          callId,
		mohUuid:         mohUuid,
	}
}

// Execute executes the request
func (a *ApplicationsAPIService) StartApplicationCallMOHExecute(r ApplicationsAPIStartApplicationCallMOHRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodPut
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ApplicationsAPIService.StartApplicationCallMOH")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/applications/{application_uuid}/calls/{call_id}/moh/{moh_uuid}/start"
	localVarPath = strings.Replace(localVarPath, "{"+"application_uuid"+"}", url.PathEscape(parameterValueToString(r.applicationUuid, "applicationUuid")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"call_id"+"}", url.PathEscape(parameterValueToString(r.callId, "callId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"moh_uuid"+"}", url.PathEscape(parameterValueToString(r.mohUuid, "mohUuid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["accent_auth_token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Auth-Token"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 503 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApplicationsAPIStartApplicationCallProgressRequest struct {
	ctx             context.Context
	ApiService      ApplicationsAPI
	applicationUuid string
	callId          string
}

func (r ApplicationsAPIStartApplicationCallProgressRequest) Execute() (*http.Response, error) {
	return r.ApiService.StartApplicationCallProgressExecute(r)
}

/*
StartApplicationCallProgress Play the progress ringing tone

**Required ACL:** `calld.applications.{application_uuid}.calls.{call_id}.progress.start.update` The progress ringing tone is the sound heard by a caller while the other party is ringing.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param applicationUuid UUID of the application
	@param callId ID of the call
	@return ApplicationsAPIStartApplicationCallProgressRequest
*/
func (a *ApplicationsAPIService) StartApplicationCallProgress(ctx context.Context, applicationUuid string, callId string) ApplicationsAPIStartApplicationCallProgressRequest {
	return ApplicationsAPIStartApplicationCallProgressRequest{
		ApiService:      a,
		ctx:             ctx,
		applicationUuid: applicationUuid,
		callId:          callId,
	}
}

// Execute executes the request
func (a *ApplicationsAPIService) StartApplicationCallProgressExecute(r ApplicationsAPIStartApplicationCallProgressRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodPut
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ApplicationsAPIService.StartApplicationCallProgress")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/applications/{application_uuid}/calls/{call_id}/progress/start"
	localVarPath = strings.Replace(localVarPath, "{"+"application_uuid"+"}", url.PathEscape(parameterValueToString(r.applicationUuid, "applicationUuid")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"call_id"+"}", url.PathEscape(parameterValueToString(r.callId, "callId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["accent_auth_token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Auth-Token"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 503 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApplicationsAPIStopApplicationCallMOHRequest struct {
	ctx             context.Context
	ApiService      ApplicationsAPI
	applicationUuid string
	callId          string
}

func (r ApplicationsAPIStopApplicationCallMOHRequest) Execute() (*http.Response, error) {
	return r.ApiService.StopApplicationCallMOHExecute(r)
}

/*
StopApplicationCallMOH Stops playing a music on hold

**Required ACL:** `calld.applications.{application_uuid}.calls.{call_id}.moh.{moh_uuid}.stop.update

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param applicationUuid UUID of the application
	@param callId ID of the call
	@return ApplicationsAPIStopApplicationCallMOHRequest
*/
func (a *ApplicationsAPIService) StopApplicationCallMOH(ctx context.Context, applicationUuid string, callId string) ApplicationsAPIStopApplicationCallMOHRequest {
	return ApplicationsAPIStopApplicationCallMOHRequest{
		ApiService:      a,
		ctx:             ctx,
		applicationUuid: applicationUuid,
		callId:          callId,
	}
}

// Execute executes the request
func (a *ApplicationsAPIService) StopApplicationCallMOHExecute(r ApplicationsAPIStopApplicationCallMOHRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodPut
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ApplicationsAPIService.StopApplicationCallMOH")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/applications/{application_uuid}/calls/{call_id}/moh/stop"
	localVarPath = strings.Replace(localVarPath, "{"+"application_uuid"+"}", url.PathEscape(parameterValueToString(r.applicationUuid, "applicationUuid")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"call_id"+"}", url.PathEscape(parameterValueToString(r.callId, "callId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["accent_auth_token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Auth-Token"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 503 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApplicationsAPIStopApplicationCallProgressRequest struct {
	ctx             context.Context
	ApiService      ApplicationsAPI
	applicationUuid string
	callId          string
}

func (r ApplicationsAPIStopApplicationCallProgressRequest) Execute() (*http.Response, error) {
	return r.ApiService.StopApplicationCallProgressExecute(r)
}

/*
StopApplicationCallProgress Stop playing the progress ringing tone.

**Required ACL:** `calld.applications.{application_uuid}.calls.{call_id}.progress.stop.update` The progress ringing tone is the sound heard by a caller while the other party is ringing. Limitation: this only works when the ringing tone is played by Accent through audio media (e.g. when using `/progress` after `/answer`). If the phone is emitting the ringing tone directly to the user, then it cannot be stopped, and the response code will still be 204.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param applicationUuid UUID of the application
	@param callId ID of the call
	@return ApplicationsAPIStopApplicationCallProgressRequest
*/
func (a *ApplicationsAPIService) StopApplicationCallProgress(ctx context.Context, applicationUuid string, callId string) ApplicationsAPIStopApplicationCallProgressRequest {
	return ApplicationsAPIStopApplicationCallProgressRequest{
		ApiService:      a,
		ctx:             ctx,
		applicationUuid: applicationUuid,
		callId:          callId,
	}
}

// Execute executes the request
func (a *ApplicationsAPIService) StopApplicationCallProgressExecute(r ApplicationsAPIStopApplicationCallProgressRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodPut
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ApplicationsAPIService.StopApplicationCallProgress")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/applications/{application_uuid}/calls/{call_id}/progress/stop"
	localVarPath = strings.Replace(localVarPath, "{"+"application_uuid"+"}", url.PathEscape(parameterValueToString(r.applicationUuid, "applicationUuid")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"call_id"+"}", url.PathEscape(parameterValueToString(r.callId, "callId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["accent_auth_token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Auth-Token"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 503 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApplicationsAPIStopSnoopRequest struct {
	ctx             context.Context
	ApiService      ApplicationsAPI
	applicationUuid string
	snoopUuid       string
}

func (r ApplicationsAPIStopSnoopRequest) Execute() (*http.Response, error) {
	return r.ApiService.StopSnoopExecute(r)
}

/*
StopSnoop Stop snooping

**Required ACL:** `calld.applications.{application_uuid}.snoops.{snoop_uuid}.delete`

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param applicationUuid UUID of the application
	@param snoopUuid UUID of the snoop
	@return ApplicationsAPIStopSnoopRequest
*/
func (a *ApplicationsAPIService) StopSnoop(ctx context.Context, applicationUuid string, snoopUuid string) ApplicationsAPIStopSnoopRequest {
	return ApplicationsAPIStopSnoopRequest{
		ApiService:      a,
		ctx:             ctx,
		applicationUuid: applicationUuid,
		snoopUuid:       snoopUuid,
	}
}

// Execute executes the request
func (a *ApplicationsAPIService) StopSnoopExecute(r ApplicationsAPIStopSnoopRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodDelete
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ApplicationsAPIService.StopSnoop")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/applications/{application_uuid}/snoops/{snoop_uuid}"
	localVarPath = strings.Replace(localVarPath, "{"+"application_uuid"+"}", url.PathEscape(parameterValueToString(r.applicationUuid, "applicationUuid")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"snoop_uuid"+"}", url.PathEscape(parameterValueToString(r.snoopUuid, "snoopUuid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["accent_auth_token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Auth-Token"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 503 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApplicationsAPIUnmuteApplicationCallRequest struct {
	ctx             context.Context
	ApiService      ApplicationsAPI
	applicationUuid string
	callId          string
}

func (r ApplicationsAPIUnmuteApplicationCallRequest) Execute() (*http.Response, error) {
	return r.ApiService.UnmuteApplicationCallExecute(r)
}

/*
UnmuteApplicationCall Unmute a call

**Required ACL:** `calld.applications.{application_uuid}.calls.{call_id}.mute.stop.update`

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param applicationUuid UUID of the application
	@param callId ID of the call
	@return ApplicationsAPIUnmuteApplicationCallRequest
*/
func (a *ApplicationsAPIService) UnmuteApplicationCall(ctx context.Context, applicationUuid string, callId string) ApplicationsAPIUnmuteApplicationCallRequest {
	return ApplicationsAPIUnmuteApplicationCallRequest{
		ApiService:      a,
		ctx:             ctx,
		applicationUuid: applicationUuid,
		callId:          callId,
	}
}

// Execute executes the request
func (a *ApplicationsAPIService) UnmuteApplicationCallExecute(r ApplicationsAPIUnmuteApplicationCallRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodPut
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ApplicationsAPIService.UnmuteApplicationCall")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/applications/{application_uuid}/calls/{call_id}/mute/stop"
	localVarPath = strings.Replace(localVarPath, "{"+"application_uuid"+"}", url.PathEscape(parameterValueToString(r.applicationUuid, "applicationUuid")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"call_id"+"}", url.PathEscape(parameterValueToString(r.callId, "callId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["accent_auth_token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Auth-Token"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 503 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApplicationsAPIUpdateSnoopRequest struct {
	ctx             context.Context
	ApiService      ApplicationsAPI
	body            *ApplicationSnoopPut
	applicationUuid string
	snoopUuid       string
}

// snoop parameters
func (r ApplicationsAPIUpdateSnoopRequest) Body(body ApplicationSnoopPut) ApplicationsAPIUpdateSnoopRequest {
	r.body = &body
	return r
}

func (r ApplicationsAPIUpdateSnoopRequest) Execute() (*http.Response, error) {
	return r.ApiService.UpdateSnoopExecute(r)
}

/*
UpdateSnoop Change snooping parameters

**Required ACL:** `calld.applications.{application_uuid}.snoops.{snoop_uuid}.update`

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param applicationUuid UUID of the application
	@param snoopUuid UUID of the snoop
	@return ApplicationsAPIUpdateSnoopRequest
*/
func (a *ApplicationsAPIService) UpdateSnoop(ctx context.Context, applicationUuid string, snoopUuid string) ApplicationsAPIUpdateSnoopRequest {
	return ApplicationsAPIUpdateSnoopRequest{
		ApiService:      a,
		ctx:             ctx,
		applicationUuid: applicationUuid,
		snoopUuid:       snoopUuid,
	}
}

// Execute executes the request
func (a *ApplicationsAPIService) UpdateSnoopExecute(r ApplicationsAPIUpdateSnoopRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodPut
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ApplicationsAPIService.UpdateSnoop")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/applications/{application_uuid}/snoops/{snoop_uuid}"
	localVarPath = strings.Replace(localVarPath, "{"+"application_uuid"+"}", url.PathEscape(parameterValueToString(r.applicationUuid, "applicationUuid")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"snoop_uuid"+"}", url.PathEscape(parameterValueToString(r.snoopUuid, "snoopUuid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return nil, reportError("body is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["accent_auth_token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Auth-Token"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 503 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

/*
accent-calld

Control your calls from a REST API

API version: 1.0.0
Contact: help@accentvoice.io
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package calld

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"strings"
)

type VoicemailsAPI interface {

	/*
		CheckUserVoicemailGreeting Check if greeting exists

		**Required ACL:** `calld.users.me.voicemails.greetings.{greeting}.read`

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param greeting The greeting
		@return VoicemailsAPICheckUserVoicemailGreetingRequest
	*/
	CheckUserVoicemailGreeting(ctx context.Context, greeting string) VoicemailsAPICheckUserVoicemailGreetingRequest

	// CheckUserVoicemailGreetingExecute executes the request
	CheckUserVoicemailGreetingExecute(r VoicemailsAPICheckUserVoicemailGreetingRequest) (*http.Response, error)

	/*
		CheckVoicemailGreeting Check if greeting exists

		**Required ACL:** `calld.voicemails.{voicemail_id}.greetings.{greeting}.read`

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param voicemailId The voicemail's ID
		@param greeting The greeting
		@return VoicemailsAPICheckVoicemailGreetingRequest
	*/
	CheckVoicemailGreeting(ctx context.Context, voicemailId int32, greeting string) VoicemailsAPICheckVoicemailGreetingRequest

	// CheckVoicemailGreetingExecute executes the request
	CheckVoicemailGreetingExecute(r VoicemailsAPICheckVoicemailGreetingRequest) (*http.Response, error)

	/*
		CopyUserVoicemailGreeting Copy a custom greeting

		**Required ACL:** `calld.users.me.voicemails.greetings.{greeting}.copy.create`

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param greeting The greeting
		@return VoicemailsAPICopyUserVoicemailGreetingRequest
	*/
	CopyUserVoicemailGreeting(ctx context.Context, greeting string) VoicemailsAPICopyUserVoicemailGreetingRequest

	// CopyUserVoicemailGreetingExecute executes the request
	CopyUserVoicemailGreetingExecute(r VoicemailsAPICopyUserVoicemailGreetingRequest) (*http.Response, error)

	/*
		CopyVoicemailGreeting Copy a custom greeting

		**Required ACL:** `calld.voicemails.{voicemail_id}.greetings.{greeting}.copy.create`

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param voicemailId The voicemail's ID
		@param greeting The greeting
		@return VoicemailsAPICopyVoicemailGreetingRequest
	*/
	CopyVoicemailGreeting(ctx context.Context, voicemailId int32, greeting string) VoicemailsAPICopyVoicemailGreetingRequest

	// CopyVoicemailGreetingExecute executes the request
	CopyVoicemailGreetingExecute(r VoicemailsAPICopyVoicemailGreetingRequest) (*http.Response, error)

	/*
		CreateUserVoicemailGreeting Create a custom greeting

		**Required ACL:** `calld.users.me.voicemails.greetings.{greeting}.create`

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param greeting The greeting
		@return VoicemailsAPICreateUserVoicemailGreetingRequest
	*/
	CreateUserVoicemailGreeting(ctx context.Context, greeting string) VoicemailsAPICreateUserVoicemailGreetingRequest

	// CreateUserVoicemailGreetingExecute executes the request
	CreateUserVoicemailGreetingExecute(r VoicemailsAPICreateUserVoicemailGreetingRequest) (*http.Response, error)

	/*
		CreateVoicemailGreeting Create a custom greeting

		**Required ACL:** `calld.voicemails.{voicemail_id}.greetings.{greeting}.create`

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param voicemailId The voicemail's ID
		@param greeting The greeting
		@return VoicemailsAPICreateVoicemailGreetingRequest
	*/
	CreateVoicemailGreeting(ctx context.Context, voicemailId int32, greeting string) VoicemailsAPICreateVoicemailGreetingRequest

	// CreateVoicemailGreetingExecute executes the request
	CreateVoicemailGreetingExecute(r VoicemailsAPICreateVoicemailGreetingRequest) (*http.Response, error)

	/*
		DeleteUserVoicemailGreeting Delete a custom greeting

		**Required ACL:** `calld.users.me.voicemails.greetings.{greeting}.delete`

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param greeting The greeting
		@return VoicemailsAPIDeleteUserVoicemailGreetingRequest
	*/
	DeleteUserVoicemailGreeting(ctx context.Context, greeting string) VoicemailsAPIDeleteUserVoicemailGreetingRequest

	// DeleteUserVoicemailGreetingExecute executes the request
	DeleteUserVoicemailGreetingExecute(r VoicemailsAPIDeleteUserVoicemailGreetingRequest) (*http.Response, error)

	/*
		DeleteUserVoicemailMessage Delete a mesage

		**Required ACL:** `calld.users.me.voicemails.messages.{message_id}.delete`

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param messageId The message's ID
		@return VoicemailsAPIDeleteUserVoicemailMessageRequest
	*/
	DeleteUserVoicemailMessage(ctx context.Context, messageId string) VoicemailsAPIDeleteUserVoicemailMessageRequest

	// DeleteUserVoicemailMessageExecute executes the request
	DeleteUserVoicemailMessageExecute(r VoicemailsAPIDeleteUserVoicemailMessageRequest) (*http.Response, error)

	/*
		DeleteVoicemailGreeting Delete a custom greeting

		**Required ACL:** `calld.voicemails.{voicemail_id}.greetings.{greeting}.delete`

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param voicemailId The voicemail's ID
		@param greeting The greeting
		@return VoicemailsAPIDeleteVoicemailGreetingRequest
	*/
	DeleteVoicemailGreeting(ctx context.Context, voicemailId int32, greeting string) VoicemailsAPIDeleteVoicemailGreetingRequest

	// DeleteVoicemailGreetingExecute executes the request
	DeleteVoicemailGreetingExecute(r VoicemailsAPIDeleteVoicemailGreetingRequest) (*http.Response, error)

	/*
		DeleteVoicemailMessage Delete a mesage

		**Required ACL:** `calld.voicemails.{voicemail_id}.messages.{message_id}.delete`

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param voicemailId The voicemail's ID
		@param messageId The message's ID
		@return VoicemailsAPIDeleteVoicemailMessageRequest
	*/
	DeleteVoicemailMessage(ctx context.Context, voicemailId int32, messageId string) VoicemailsAPIDeleteVoicemailMessageRequest

	// DeleteVoicemailMessageExecute executes the request
	DeleteVoicemailMessageExecute(r VoicemailsAPIDeleteVoicemailMessageRequest) (*http.Response, error)

	/*
		GetUserVoicemailFolder Get details of a folder

		**Required ACL:** `calld.users.me.voicemails.folders.{folder_id}.read`

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param folderId The folder's ID
		@return VoicemailsAPIGetUserVoicemailFolderRequest
	*/
	GetUserVoicemailFolder(ctx context.Context, folderId int32) VoicemailsAPIGetUserVoicemailFolderRequest

	// GetUserVoicemailFolderExecute executes the request
	//  @return VoicemailFolder
	GetUserVoicemailFolderExecute(r VoicemailsAPIGetUserVoicemailFolderRequest) (*VoicemailFolder, *http.Response, error)

	/*
		GetUserVoicemailGreeting Get a custom greeting

		**Required ACL:** `calld.users.me.voicemails.greetings.{greeting}.read`

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param greeting The greeting
		@return VoicemailsAPIGetUserVoicemailGreetingRequest
	*/
	GetUserVoicemailGreeting(ctx context.Context, greeting string) VoicemailsAPIGetUserVoicemailGreetingRequest

	// GetUserVoicemailGreetingExecute executes the request
	GetUserVoicemailGreetingExecute(r VoicemailsAPIGetUserVoicemailGreetingRequest) (*http.Response, error)

	/*
		GetUserVoicemailMessage Get a message

		**Required ACL:** `calld.users.me.voicemails.messages.{message_id}.read`

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param messageId The message's ID
		@return VoicemailsAPIGetUserVoicemailMessageRequest
	*/
	GetUserVoicemailMessage(ctx context.Context, messageId string) VoicemailsAPIGetUserVoicemailMessageRequest

	// GetUserVoicemailMessageExecute executes the request
	//  @return VoicemailMessage
	GetUserVoicemailMessageExecute(r VoicemailsAPIGetUserVoicemailMessageRequest) (*VoicemailMessage, *http.Response, error)

	/*
		GetUserVoicemailMessageRecording Get a message's recording

		**Required ACL:** `calld.users.me.voicemails.messages.{message_id}.recording.read`

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param messageId The message's ID
		@return VoicemailsAPIGetUserVoicemailMessageRecordingRequest
	*/
	GetUserVoicemailMessageRecording(ctx context.Context, messageId string) VoicemailsAPIGetUserVoicemailMessageRecordingRequest

	// GetUserVoicemailMessageRecordingExecute executes the request
	GetUserVoicemailMessageRecordingExecute(r VoicemailsAPIGetUserVoicemailMessageRecordingRequest) (*http.Response, error)

	/*
		GetVoicemail Get details of a voicemail

		**Required ACL:** `calld.voicemails.{voicemail_id}.read`

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param voicemailId The voicemail's ID
		@return VoicemailsAPIGetVoicemailRequest
	*/
	GetVoicemail(ctx context.Context, voicemailId int32) VoicemailsAPIGetVoicemailRequest

	// GetVoicemailExecute executes the request
	//  @return Voicemail
	GetVoicemailExecute(r VoicemailsAPIGetVoicemailRequest) (*Voicemail, *http.Response, error)

	/*
		GetVoicemailFolder Get details of a folder

		**Required ACL:** `calld.voicemails.{voicemail_id}.folders.{folder_id}.read`

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param voicemailId The voicemail's ID
		@param folderId The folder's ID
		@return VoicemailsAPIGetVoicemailFolderRequest
	*/
	GetVoicemailFolder(ctx context.Context, voicemailId int32, folderId int32) VoicemailsAPIGetVoicemailFolderRequest

	// GetVoicemailFolderExecute executes the request
	//  @return VoicemailFolder
	GetVoicemailFolderExecute(r VoicemailsAPIGetVoicemailFolderRequest) (*VoicemailFolder, *http.Response, error)

	/*
		GetVoicemailGreeting Get a custom greeting

		**Required ACL:** `calld.voicemails.{voicemail_id}.greetings.{greeting}.read`

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param voicemailId The voicemail's ID
		@param greeting The greeting
		@return VoicemailsAPIGetVoicemailGreetingRequest
	*/
	GetVoicemailGreeting(ctx context.Context, voicemailId int32, greeting string) VoicemailsAPIGetVoicemailGreetingRequest

	// GetVoicemailGreetingExecute executes the request
	GetVoicemailGreetingExecute(r VoicemailsAPIGetVoicemailGreetingRequest) (*http.Response, error)

	/*
		GetVoicemailMessage Get a message

		**Required ACL:** `calld.voicemails.{voicemail_id}.messages.{message_id}.read`

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param voicemailId The voicemail's ID
		@param messageId The message's ID
		@return VoicemailsAPIGetVoicemailMessageRequest
	*/
	GetVoicemailMessage(ctx context.Context, voicemailId int32, messageId string) VoicemailsAPIGetVoicemailMessageRequest

	// GetVoicemailMessageExecute executes the request
	//  @return VoicemailMessage
	GetVoicemailMessageExecute(r VoicemailsAPIGetVoicemailMessageRequest) (*VoicemailMessage, *http.Response, error)

	/*
		GetVoicemailMessageRecording Get a message's recording

		**Required ACL:** `calld.voicemails.{voicemail_id}.messages.{message_id}.recording.read`

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param voicemailId The voicemail's ID
		@param messageId The message's ID
		@return VoicemailsAPIGetVoicemailMessageRecordingRequest
	*/
	GetVoicemailMessageRecording(ctx context.Context, voicemailId int32, messageId string) VoicemailsAPIGetVoicemailMessageRecordingRequest

	// GetVoicemailMessageRecordingExecute executes the request
	GetVoicemailMessageRecordingExecute(r VoicemailsAPIGetVoicemailMessageRecordingRequest) (*http.Response, error)

	/*
		ListUserVoicemails Get details of the voicemail of the authenticated user

		**Required ACL:** `calld.users.me.voicemails.read`

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@return VoicemailsAPIListUserVoicemailsRequest
	*/
	ListUserVoicemails(ctx context.Context) VoicemailsAPIListUserVoicemailsRequest

	// ListUserVoicemailsExecute executes the request
	//  @return Voicemail
	ListUserVoicemailsExecute(r VoicemailsAPIListUserVoicemailsRequest) (*Voicemail, *http.Response, error)

	/*
		UpdateUserVoicemailGreeting Update a custom greeting

		**Required ACL:** `calld.users.me.voicemails.greetings.{greeting}.update`

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param greeting The greeting
		@return VoicemailsAPIUpdateUserVoicemailGreetingRequest
	*/
	UpdateUserVoicemailGreeting(ctx context.Context, greeting string) VoicemailsAPIUpdateUserVoicemailGreetingRequest

	// UpdateUserVoicemailGreetingExecute executes the request
	UpdateUserVoicemailGreetingExecute(r VoicemailsAPIUpdateUserVoicemailGreetingRequest) (*http.Response, error)

	/*
		UpdateUserVoicemailMessage Update a message

		**Required ACL:** `calld.users.me.voicemails.messages.{message_id}.update`

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param messageId The message's ID
		@return VoicemailsAPIUpdateUserVoicemailMessageRequest
	*/
	UpdateUserVoicemailMessage(ctx context.Context, messageId string) VoicemailsAPIUpdateUserVoicemailMessageRequest

	// UpdateUserVoicemailMessageExecute executes the request
	UpdateUserVoicemailMessageExecute(r VoicemailsAPIUpdateUserVoicemailMessageRequest) (*http.Response, error)

	/*
		UpdateVoicemailGreeting Update a custom greeting

		**Required ACL:** `calld.voicemails.{voicemail_id}.greetings.{greeting}.update`

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param voicemailId The voicemail's ID
		@param greeting The greeting
		@return VoicemailsAPIUpdateVoicemailGreetingRequest
	*/
	UpdateVoicemailGreeting(ctx context.Context, voicemailId int32, greeting string) VoicemailsAPIUpdateVoicemailGreetingRequest

	// UpdateVoicemailGreetingExecute executes the request
	UpdateVoicemailGreetingExecute(r VoicemailsAPIUpdateVoicemailGreetingRequest) (*http.Response, error)

	/*
		UpdateVoicemailMessage Update a message

		**Required ACL:** `calld.voicemails.{voicemail_id}.messages.{message_id}.update`

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param voicemailId The voicemail's ID
		@param messageId The message's ID
		@return VoicemailsAPIUpdateVoicemailMessageRequest
	*/
	UpdateVoicemailMessage(ctx context.Context, voicemailId int32, messageId string) VoicemailsAPIUpdateVoicemailMessageRequest

	// UpdateVoicemailMessageExecute executes the request
	UpdateVoicemailMessageExecute(r VoicemailsAPIUpdateVoicemailMessageRequest) (*http.Response, error)
}

// VoicemailsAPIService VoicemailsAPI service
type VoicemailsAPIService service

type VoicemailsAPICheckUserVoicemailGreetingRequest struct {
	ctx        context.Context
	ApiService VoicemailsAPI
	greeting   string
}

func (r VoicemailsAPICheckUserVoicemailGreetingRequest) Execute() (*http.Response, error) {
	return r.ApiService.CheckUserVoicemailGreetingExecute(r)
}

/*
CheckUserVoicemailGreeting Check if greeting exists

**Required ACL:** `calld.users.me.voicemails.greetings.{greeting}.read`

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param greeting The greeting
	@return VoicemailsAPICheckUserVoicemailGreetingRequest
*/
func (a *VoicemailsAPIService) CheckUserVoicemailGreeting(ctx context.Context, greeting string) VoicemailsAPICheckUserVoicemailGreetingRequest {
	return VoicemailsAPICheckUserVoicemailGreetingRequest{
		ApiService: a,
		ctx:        ctx,
		greeting:   greeting,
	}
}

// Execute executes the request
func (a *VoicemailsAPIService) CheckUserVoicemailGreetingExecute(r VoicemailsAPICheckUserVoicemailGreetingRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodHead
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "VoicemailsAPIService.CheckUserVoicemailGreeting")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/me/voicemails/greetings/{greeting}"
	localVarPath = strings.Replace(localVarPath, "{"+"greeting"+"}", url.PathEscape(parameterValueToString(r.greeting, "greeting")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["accent_auth_token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Auth-Token"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 503 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type VoicemailsAPICheckVoicemailGreetingRequest struct {
	ctx         context.Context
	ApiService  VoicemailsAPI
	voicemailId int32
	greeting    string
}

func (r VoicemailsAPICheckVoicemailGreetingRequest) Execute() (*http.Response, error) {
	return r.ApiService.CheckVoicemailGreetingExecute(r)
}

/*
CheckVoicemailGreeting Check if greeting exists

**Required ACL:** `calld.voicemails.{voicemail_id}.greetings.{greeting}.read`

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param voicemailId The voicemail's ID
	@param greeting The greeting
	@return VoicemailsAPICheckVoicemailGreetingRequest
*/
func (a *VoicemailsAPIService) CheckVoicemailGreeting(ctx context.Context, voicemailId int32, greeting string) VoicemailsAPICheckVoicemailGreetingRequest {
	return VoicemailsAPICheckVoicemailGreetingRequest{
		ApiService:  a,
		ctx:         ctx,
		voicemailId: voicemailId,
		greeting:    greeting,
	}
}

// Execute executes the request
func (a *VoicemailsAPIService) CheckVoicemailGreetingExecute(r VoicemailsAPICheckVoicemailGreetingRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodHead
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "VoicemailsAPIService.CheckVoicemailGreeting")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/voicemails/{voicemail_id}/greetings/{greeting}"
	localVarPath = strings.Replace(localVarPath, "{"+"voicemail_id"+"}", url.PathEscape(parameterValueToString(r.voicemailId, "voicemailId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"greeting"+"}", url.PathEscape(parameterValueToString(r.greeting, "greeting")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["accent_auth_token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Auth-Token"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 503 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type VoicemailsAPICopyUserVoicemailGreetingRequest struct {
	ctx        context.Context
	ApiService VoicemailsAPI
	body       *GreetingCopy
	greeting   string
}

func (r VoicemailsAPICopyUserVoicemailGreetingRequest) Body(body GreetingCopy) VoicemailsAPICopyUserVoicemailGreetingRequest {
	r.body = &body
	return r
}

func (r VoicemailsAPICopyUserVoicemailGreetingRequest) Execute() (*http.Response, error) {
	return r.ApiService.CopyUserVoicemailGreetingExecute(r)
}

/*
CopyUserVoicemailGreeting Copy a custom greeting

**Required ACL:** `calld.users.me.voicemails.greetings.{greeting}.copy.create`

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param greeting The greeting
	@return VoicemailsAPICopyUserVoicemailGreetingRequest
*/
func (a *VoicemailsAPIService) CopyUserVoicemailGreeting(ctx context.Context, greeting string) VoicemailsAPICopyUserVoicemailGreetingRequest {
	return VoicemailsAPICopyUserVoicemailGreetingRequest{
		ApiService: a,
		ctx:        ctx,
		greeting:   greeting,
	}
}

// Execute executes the request
func (a *VoicemailsAPIService) CopyUserVoicemailGreetingExecute(r VoicemailsAPICopyUserVoicemailGreetingRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodPost
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "VoicemailsAPIService.CopyUserVoicemailGreeting")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/me/voicemails/greetings/{greeting}/copy"
	localVarPath = strings.Replace(localVarPath, "{"+"greeting"+"}", url.PathEscape(parameterValueToString(r.greeting, "greeting")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return nil, reportError("body is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["accent_auth_token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Auth-Token"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 503 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type VoicemailsAPICopyVoicemailGreetingRequest struct {
	ctx         context.Context
	ApiService  VoicemailsAPI
	body        *GreetingCopy
	voicemailId int32
	greeting    string
}

func (r VoicemailsAPICopyVoicemailGreetingRequest) Body(body GreetingCopy) VoicemailsAPICopyVoicemailGreetingRequest {
	r.body = &body
	return r
}

func (r VoicemailsAPICopyVoicemailGreetingRequest) Execute() (*http.Response, error) {
	return r.ApiService.CopyVoicemailGreetingExecute(r)
}

/*
CopyVoicemailGreeting Copy a custom greeting

**Required ACL:** `calld.voicemails.{voicemail_id}.greetings.{greeting}.copy.create`

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param voicemailId The voicemail's ID
	@param greeting The greeting
	@return VoicemailsAPICopyVoicemailGreetingRequest
*/
func (a *VoicemailsAPIService) CopyVoicemailGreeting(ctx context.Context, voicemailId int32, greeting string) VoicemailsAPICopyVoicemailGreetingRequest {
	return VoicemailsAPICopyVoicemailGreetingRequest{
		ApiService:  a,
		ctx:         ctx,
		voicemailId: voicemailId,
		greeting:    greeting,
	}
}

// Execute executes the request
func (a *VoicemailsAPIService) CopyVoicemailGreetingExecute(r VoicemailsAPICopyVoicemailGreetingRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodPost
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "VoicemailsAPIService.CopyVoicemailGreeting")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/voicemails/{voicemail_id}/greetings/{greeting}/copy"
	localVarPath = strings.Replace(localVarPath, "{"+"voicemail_id"+"}", url.PathEscape(parameterValueToString(r.voicemailId, "voicemailId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"greeting"+"}", url.PathEscape(parameterValueToString(r.greeting, "greeting")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return nil, reportError("body is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["accent_auth_token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Auth-Token"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 503 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type VoicemailsAPICreateUserVoicemailGreetingRequest struct {
	ctx        context.Context
	ApiService VoicemailsAPI
	body       *map[string]interface{}
	greeting   string
}

func (r VoicemailsAPICreateUserVoicemailGreetingRequest) Body(body map[string]interface{}) VoicemailsAPICreateUserVoicemailGreetingRequest {
	r.body = &body
	return r
}

func (r VoicemailsAPICreateUserVoicemailGreetingRequest) Execute() (*http.Response, error) {
	return r.ApiService.CreateUserVoicemailGreetingExecute(r)
}

/*
CreateUserVoicemailGreeting Create a custom greeting

**Required ACL:** `calld.users.me.voicemails.greetings.{greeting}.create`

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param greeting The greeting
	@return VoicemailsAPICreateUserVoicemailGreetingRequest
*/
func (a *VoicemailsAPIService) CreateUserVoicemailGreeting(ctx context.Context, greeting string) VoicemailsAPICreateUserVoicemailGreetingRequest {
	return VoicemailsAPICreateUserVoicemailGreetingRequest{
		ApiService: a,
		ctx:        ctx,
		greeting:   greeting,
	}
}

// Execute executes the request
func (a *VoicemailsAPIService) CreateUserVoicemailGreetingExecute(r VoicemailsAPICreateUserVoicemailGreetingRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodPost
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "VoicemailsAPIService.CreateUserVoicemailGreeting")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/me/voicemails/greetings/{greeting}"
	localVarPath = strings.Replace(localVarPath, "{"+"greeting"+"}", url.PathEscape(parameterValueToString(r.greeting, "greeting")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return nil, reportError("body is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"audio/wav"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["accent_auth_token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Auth-Token"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 503 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type VoicemailsAPICreateVoicemailGreetingRequest struct {
	ctx         context.Context
	ApiService  VoicemailsAPI
	body        *map[string]interface{}
	voicemailId int32
	greeting    string
}

func (r VoicemailsAPICreateVoicemailGreetingRequest) Body(body map[string]interface{}) VoicemailsAPICreateVoicemailGreetingRequest {
	r.body = &body
	return r
}

func (r VoicemailsAPICreateVoicemailGreetingRequest) Execute() (*http.Response, error) {
	return r.ApiService.CreateVoicemailGreetingExecute(r)
}

/*
CreateVoicemailGreeting Create a custom greeting

**Required ACL:** `calld.voicemails.{voicemail_id}.greetings.{greeting}.create`

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param voicemailId The voicemail's ID
	@param greeting The greeting
	@return VoicemailsAPICreateVoicemailGreetingRequest
*/
func (a *VoicemailsAPIService) CreateVoicemailGreeting(ctx context.Context, voicemailId int32, greeting string) VoicemailsAPICreateVoicemailGreetingRequest {
	return VoicemailsAPICreateVoicemailGreetingRequest{
		ApiService:  a,
		ctx:         ctx,
		voicemailId: voicemailId,
		greeting:    greeting,
	}
}

// Execute executes the request
func (a *VoicemailsAPIService) CreateVoicemailGreetingExecute(r VoicemailsAPICreateVoicemailGreetingRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodPost
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "VoicemailsAPIService.CreateVoicemailGreeting")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/voicemails/{voicemail_id}/greetings/{greeting}"
	localVarPath = strings.Replace(localVarPath, "{"+"voicemail_id"+"}", url.PathEscape(parameterValueToString(r.voicemailId, "voicemailId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"greeting"+"}", url.PathEscape(parameterValueToString(r.greeting, "greeting")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return nil, reportError("body is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"audio/wav"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["accent_auth_token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Auth-Token"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 503 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type VoicemailsAPIDeleteUserVoicemailGreetingRequest struct {
	ctx        context.Context
	ApiService VoicemailsAPI
	greeting   string
}

func (r VoicemailsAPIDeleteUserVoicemailGreetingRequest) Execute() (*http.Response, error) {
	return r.ApiService.DeleteUserVoicemailGreetingExecute(r)
}

/*
DeleteUserVoicemailGreeting Delete a custom greeting

**Required ACL:** `calld.users.me.voicemails.greetings.{greeting}.delete`

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param greeting The greeting
	@return VoicemailsAPIDeleteUserVoicemailGreetingRequest
*/
func (a *VoicemailsAPIService) DeleteUserVoicemailGreeting(ctx context.Context, greeting string) VoicemailsAPIDeleteUserVoicemailGreetingRequest {
	return VoicemailsAPIDeleteUserVoicemailGreetingRequest{
		ApiService: a,
		ctx:        ctx,
		greeting:   greeting,
	}
}

// Execute executes the request
func (a *VoicemailsAPIService) DeleteUserVoicemailGreetingExecute(r VoicemailsAPIDeleteUserVoicemailGreetingRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodDelete
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "VoicemailsAPIService.DeleteUserVoicemailGreeting")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/me/voicemails/greetings/{greeting}"
	localVarPath = strings.Replace(localVarPath, "{"+"greeting"+"}", url.PathEscape(parameterValueToString(r.greeting, "greeting")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["accent_auth_token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Auth-Token"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 503 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type VoicemailsAPIDeleteUserVoicemailMessageRequest struct {
	ctx        context.Context
	ApiService VoicemailsAPI
	messageId  string
}

func (r VoicemailsAPIDeleteUserVoicemailMessageRequest) Execute() (*http.Response, error) {
	return r.ApiService.DeleteUserVoicemailMessageExecute(r)
}

/*
DeleteUserVoicemailMessage Delete a mesage

**Required ACL:** `calld.users.me.voicemails.messages.{message_id}.delete`

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param messageId The message's ID
	@return VoicemailsAPIDeleteUserVoicemailMessageRequest
*/
func (a *VoicemailsAPIService) DeleteUserVoicemailMessage(ctx context.Context, messageId string) VoicemailsAPIDeleteUserVoicemailMessageRequest {
	return VoicemailsAPIDeleteUserVoicemailMessageRequest{
		ApiService: a,
		ctx:        ctx,
		messageId:  messageId,
	}
}

// Execute executes the request
func (a *VoicemailsAPIService) DeleteUserVoicemailMessageExecute(r VoicemailsAPIDeleteUserVoicemailMessageRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodDelete
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "VoicemailsAPIService.DeleteUserVoicemailMessage")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/me/voicemails/messages/{message_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"message_id"+"}", url.PathEscape(parameterValueToString(r.messageId, "messageId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["accent_auth_token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Auth-Token"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 503 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type VoicemailsAPIDeleteVoicemailGreetingRequest struct {
	ctx         context.Context
	ApiService  VoicemailsAPI
	voicemailId int32
	greeting    string
}

func (r VoicemailsAPIDeleteVoicemailGreetingRequest) Execute() (*http.Response, error) {
	return r.ApiService.DeleteVoicemailGreetingExecute(r)
}

/*
DeleteVoicemailGreeting Delete a custom greeting

**Required ACL:** `calld.voicemails.{voicemail_id}.greetings.{greeting}.delete`

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param voicemailId The voicemail's ID
	@param greeting The greeting
	@return VoicemailsAPIDeleteVoicemailGreetingRequest
*/
func (a *VoicemailsAPIService) DeleteVoicemailGreeting(ctx context.Context, voicemailId int32, greeting string) VoicemailsAPIDeleteVoicemailGreetingRequest {
	return VoicemailsAPIDeleteVoicemailGreetingRequest{
		ApiService:  a,
		ctx:         ctx,
		voicemailId: voicemailId,
		greeting:    greeting,
	}
}

// Execute executes the request
func (a *VoicemailsAPIService) DeleteVoicemailGreetingExecute(r VoicemailsAPIDeleteVoicemailGreetingRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodDelete
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "VoicemailsAPIService.DeleteVoicemailGreeting")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/voicemails/{voicemail_id}/greetings/{greeting}"
	localVarPath = strings.Replace(localVarPath, "{"+"voicemail_id"+"}", url.PathEscape(parameterValueToString(r.voicemailId, "voicemailId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"greeting"+"}", url.PathEscape(parameterValueToString(r.greeting, "greeting")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["accent_auth_token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Auth-Token"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 503 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type VoicemailsAPIDeleteVoicemailMessageRequest struct {
	ctx         context.Context
	ApiService  VoicemailsAPI
	voicemailId int32
	messageId   string
}

func (r VoicemailsAPIDeleteVoicemailMessageRequest) Execute() (*http.Response, error) {
	return r.ApiService.DeleteVoicemailMessageExecute(r)
}

/*
DeleteVoicemailMessage Delete a mesage

**Required ACL:** `calld.voicemails.{voicemail_id}.messages.{message_id}.delete`

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param voicemailId The voicemail's ID
	@param messageId The message's ID
	@return VoicemailsAPIDeleteVoicemailMessageRequest
*/
func (a *VoicemailsAPIService) DeleteVoicemailMessage(ctx context.Context, voicemailId int32, messageId string) VoicemailsAPIDeleteVoicemailMessageRequest {
	return VoicemailsAPIDeleteVoicemailMessageRequest{
		ApiService:  a,
		ctx:         ctx,
		voicemailId: voicemailId,
		messageId:   messageId,
	}
}

// Execute executes the request
func (a *VoicemailsAPIService) DeleteVoicemailMessageExecute(r VoicemailsAPIDeleteVoicemailMessageRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodDelete
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "VoicemailsAPIService.DeleteVoicemailMessage")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/voicemails/{voicemail_id}/messages/{message_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"voicemail_id"+"}", url.PathEscape(parameterValueToString(r.voicemailId, "voicemailId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"message_id"+"}", url.PathEscape(parameterValueToString(r.messageId, "messageId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["accent_auth_token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Auth-Token"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 503 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type VoicemailsAPIGetUserVoicemailFolderRequest struct {
	ctx        context.Context
	ApiService VoicemailsAPI
	folderId   int32
}

func (r VoicemailsAPIGetUserVoicemailFolderRequest) Execute() (*VoicemailFolder, *http.Response, error) {
	return r.ApiService.GetUserVoicemailFolderExecute(r)
}

/*
GetUserVoicemailFolder Get details of a folder

**Required ACL:** `calld.users.me.voicemails.folders.{folder_id}.read`

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param folderId The folder's ID
	@return VoicemailsAPIGetUserVoicemailFolderRequest
*/
func (a *VoicemailsAPIService) GetUserVoicemailFolder(ctx context.Context, folderId int32) VoicemailsAPIGetUserVoicemailFolderRequest {
	return VoicemailsAPIGetUserVoicemailFolderRequest{
		ApiService: a,
		ctx:        ctx,
		folderId:   folderId,
	}
}

// Execute executes the request
//
//	@return VoicemailFolder
func (a *VoicemailsAPIService) GetUserVoicemailFolderExecute(r VoicemailsAPIGetUserVoicemailFolderRequest) (*VoicemailFolder, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *VoicemailFolder
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "VoicemailsAPIService.GetUserVoicemailFolder")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/me/voicemails/folders/{folder_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"folder_id"+"}", url.PathEscape(parameterValueToString(r.folderId, "folderId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["accent_auth_token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Auth-Token"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 503 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type VoicemailsAPIGetUserVoicemailGreetingRequest struct {
	ctx        context.Context
	ApiService VoicemailsAPI
	greeting   string
}

func (r VoicemailsAPIGetUserVoicemailGreetingRequest) Execute() (*http.Response, error) {
	return r.ApiService.GetUserVoicemailGreetingExecute(r)
}

/*
GetUserVoicemailGreeting Get a custom greeting

**Required ACL:** `calld.users.me.voicemails.greetings.{greeting}.read`

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param greeting The greeting
	@return VoicemailsAPIGetUserVoicemailGreetingRequest
*/
func (a *VoicemailsAPIService) GetUserVoicemailGreeting(ctx context.Context, greeting string) VoicemailsAPIGetUserVoicemailGreetingRequest {
	return VoicemailsAPIGetUserVoicemailGreetingRequest{
		ApiService: a,
		ctx:        ctx,
		greeting:   greeting,
	}
}

// Execute executes the request
func (a *VoicemailsAPIService) GetUserVoicemailGreetingExecute(r VoicemailsAPIGetUserVoicemailGreetingRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodGet
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "VoicemailsAPIService.GetUserVoicemailGreeting")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/me/voicemails/greetings/{greeting}"
	localVarPath = strings.Replace(localVarPath, "{"+"greeting"+"}", url.PathEscape(parameterValueToString(r.greeting, "greeting")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"audio/wav"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["accent_auth_token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Auth-Token"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 503 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type VoicemailsAPIGetUserVoicemailMessageRequest struct {
	ctx        context.Context
	ApiService VoicemailsAPI
	messageId  string
}

func (r VoicemailsAPIGetUserVoicemailMessageRequest) Execute() (*VoicemailMessage, *http.Response, error) {
	return r.ApiService.GetUserVoicemailMessageExecute(r)
}

/*
GetUserVoicemailMessage Get a message

**Required ACL:** `calld.users.me.voicemails.messages.{message_id}.read`

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param messageId The message's ID
	@return VoicemailsAPIGetUserVoicemailMessageRequest
*/
func (a *VoicemailsAPIService) GetUserVoicemailMessage(ctx context.Context, messageId string) VoicemailsAPIGetUserVoicemailMessageRequest {
	return VoicemailsAPIGetUserVoicemailMessageRequest{
		ApiService: a,
		ctx:        ctx,
		messageId:  messageId,
	}
}

// Execute executes the request
//
//	@return VoicemailMessage
func (a *VoicemailsAPIService) GetUserVoicemailMessageExecute(r VoicemailsAPIGetUserVoicemailMessageRequest) (*VoicemailMessage, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *VoicemailMessage
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "VoicemailsAPIService.GetUserVoicemailMessage")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/me/voicemails/messages/{message_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"message_id"+"}", url.PathEscape(parameterValueToString(r.messageId, "messageId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["accent_auth_token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Auth-Token"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 503 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type VoicemailsAPIGetUserVoicemailMessageRecordingRequest struct {
	ctx        context.Context
	ApiService VoicemailsAPI
	messageId  string
	token      *string
	download   *string
}

// The token&#39;s ID
func (r VoicemailsAPIGetUserVoicemailMessageRecordingRequest) Token(token string) VoicemailsAPIGetUserVoicemailMessageRecordingRequest {
	r.token = &token
	return r
}

// Set to 1 to force download by browser
func (r VoicemailsAPIGetUserVoicemailMessageRecordingRequest) Download(download string) VoicemailsAPIGetUserVoicemailMessageRecordingRequest {
	r.download = &download
	return r
}

func (r VoicemailsAPIGetUserVoicemailMessageRecordingRequest) Execute() (*http.Response, error) {
	return r.ApiService.GetUserVoicemailMessageRecordingExecute(r)
}

/*
GetUserVoicemailMessageRecording Get a message's recording

**Required ACL:** `calld.users.me.voicemails.messages.{message_id}.recording.read`

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param messageId The message's ID
	@return VoicemailsAPIGetUserVoicemailMessageRecordingRequest
*/
func (a *VoicemailsAPIService) GetUserVoicemailMessageRecording(ctx context.Context, messageId string) VoicemailsAPIGetUserVoicemailMessageRecordingRequest {
	return VoicemailsAPIGetUserVoicemailMessageRecordingRequest{
		ApiService: a,
		ctx:        ctx,
		messageId:  messageId,
	}
}

// Execute executes the request
func (a *VoicemailsAPIService) GetUserVoicemailMessageRecordingExecute(r VoicemailsAPIGetUserVoicemailMessageRecordingRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodGet
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "VoicemailsAPIService.GetUserVoicemailMessageRecording")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/me/voicemails/messages/{message_id}/recording"
	localVarPath = strings.Replace(localVarPath, "{"+"message_id"+"}", url.PathEscape(parameterValueToString(r.messageId, "messageId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.token != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "token", r.token, "")
	}
	if r.download != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "download", r.download, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"audio/wav"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["accent_auth_token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Auth-Token"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 503 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type VoicemailsAPIGetVoicemailRequest struct {
	ctx         context.Context
	ApiService  VoicemailsAPI
	voicemailId int32
}

func (r VoicemailsAPIGetVoicemailRequest) Execute() (*Voicemail, *http.Response, error) {
	return r.ApiService.GetVoicemailExecute(r)
}

/*
GetVoicemail Get details of a voicemail

**Required ACL:** `calld.voicemails.{voicemail_id}.read`

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param voicemailId The voicemail's ID
	@return VoicemailsAPIGetVoicemailRequest
*/
func (a *VoicemailsAPIService) GetVoicemail(ctx context.Context, voicemailId int32) VoicemailsAPIGetVoicemailRequest {
	return VoicemailsAPIGetVoicemailRequest{
		ApiService:  a,
		ctx:         ctx,
		voicemailId: voicemailId,
	}
}

// Execute executes the request
//
//	@return Voicemail
func (a *VoicemailsAPIService) GetVoicemailExecute(r VoicemailsAPIGetVoicemailRequest) (*Voicemail, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *Voicemail
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "VoicemailsAPIService.GetVoicemail")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/voicemails/{voicemail_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"voicemail_id"+"}", url.PathEscape(parameterValueToString(r.voicemailId, "voicemailId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["accent_auth_token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Auth-Token"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 503 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type VoicemailsAPIGetVoicemailFolderRequest struct {
	ctx         context.Context
	ApiService  VoicemailsAPI
	voicemailId int32
	folderId    int32
}

func (r VoicemailsAPIGetVoicemailFolderRequest) Execute() (*VoicemailFolder, *http.Response, error) {
	return r.ApiService.GetVoicemailFolderExecute(r)
}

/*
GetVoicemailFolder Get details of a folder

**Required ACL:** `calld.voicemails.{voicemail_id}.folders.{folder_id}.read`

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param voicemailId The voicemail's ID
	@param folderId The folder's ID
	@return VoicemailsAPIGetVoicemailFolderRequest
*/
func (a *VoicemailsAPIService) GetVoicemailFolder(ctx context.Context, voicemailId int32, folderId int32) VoicemailsAPIGetVoicemailFolderRequest {
	return VoicemailsAPIGetVoicemailFolderRequest{
		ApiService:  a,
		ctx:         ctx,
		voicemailId: voicemailId,
		folderId:    folderId,
	}
}

// Execute executes the request
//
//	@return VoicemailFolder
func (a *VoicemailsAPIService) GetVoicemailFolderExecute(r VoicemailsAPIGetVoicemailFolderRequest) (*VoicemailFolder, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *VoicemailFolder
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "VoicemailsAPIService.GetVoicemailFolder")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/voicemails/{voicemail_id}/folders/{folder_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"voicemail_id"+"}", url.PathEscape(parameterValueToString(r.voicemailId, "voicemailId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"folder_id"+"}", url.PathEscape(parameterValueToString(r.folderId, "folderId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["accent_auth_token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Auth-Token"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 503 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type VoicemailsAPIGetVoicemailGreetingRequest struct {
	ctx         context.Context
	ApiService  VoicemailsAPI
	voicemailId int32
	greeting    string
}

func (r VoicemailsAPIGetVoicemailGreetingRequest) Execute() (*http.Response, error) {
	return r.ApiService.GetVoicemailGreetingExecute(r)
}

/*
GetVoicemailGreeting Get a custom greeting

**Required ACL:** `calld.voicemails.{voicemail_id}.greetings.{greeting}.read`

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param voicemailId The voicemail's ID
	@param greeting The greeting
	@return VoicemailsAPIGetVoicemailGreetingRequest
*/
func (a *VoicemailsAPIService) GetVoicemailGreeting(ctx context.Context, voicemailId int32, greeting string) VoicemailsAPIGetVoicemailGreetingRequest {
	return VoicemailsAPIGetVoicemailGreetingRequest{
		ApiService:  a,
		ctx:         ctx,
		voicemailId: voicemailId,
		greeting:    greeting,
	}
}

// Execute executes the request
func (a *VoicemailsAPIService) GetVoicemailGreetingExecute(r VoicemailsAPIGetVoicemailGreetingRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodGet
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "VoicemailsAPIService.GetVoicemailGreeting")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/voicemails/{voicemail_id}/greetings/{greeting}"
	localVarPath = strings.Replace(localVarPath, "{"+"voicemail_id"+"}", url.PathEscape(parameterValueToString(r.voicemailId, "voicemailId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"greeting"+"}", url.PathEscape(parameterValueToString(r.greeting, "greeting")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"audio/wav"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["accent_auth_token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Auth-Token"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 503 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type VoicemailsAPIGetVoicemailMessageRequest struct {
	ctx         context.Context
	ApiService  VoicemailsAPI
	voicemailId int32
	messageId   string
}

func (r VoicemailsAPIGetVoicemailMessageRequest) Execute() (*VoicemailMessage, *http.Response, error) {
	return r.ApiService.GetVoicemailMessageExecute(r)
}

/*
GetVoicemailMessage Get a message

**Required ACL:** `calld.voicemails.{voicemail_id}.messages.{message_id}.read`

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param voicemailId The voicemail's ID
	@param messageId The message's ID
	@return VoicemailsAPIGetVoicemailMessageRequest
*/
func (a *VoicemailsAPIService) GetVoicemailMessage(ctx context.Context, voicemailId int32, messageId string) VoicemailsAPIGetVoicemailMessageRequest {
	return VoicemailsAPIGetVoicemailMessageRequest{
		ApiService:  a,
		ctx:         ctx,
		voicemailId: voicemailId,
		messageId:   messageId,
	}
}

// Execute executes the request
//
//	@return VoicemailMessage
func (a *VoicemailsAPIService) GetVoicemailMessageExecute(r VoicemailsAPIGetVoicemailMessageRequest) (*VoicemailMessage, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *VoicemailMessage
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "VoicemailsAPIService.GetVoicemailMessage")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/voicemails/{voicemail_id}/messages/{message_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"voicemail_id"+"}", url.PathEscape(parameterValueToString(r.voicemailId, "voicemailId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"message_id"+"}", url.PathEscape(parameterValueToString(r.messageId, "messageId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["accent_auth_token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Auth-Token"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 503 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type VoicemailsAPIGetVoicemailMessageRecordingRequest struct {
	ctx         context.Context
	ApiService  VoicemailsAPI
	voicemailId int32
	messageId   string
	token       *string
	download    *string
}

// The token&#39;s ID
func (r VoicemailsAPIGetVoicemailMessageRecordingRequest) Token(token string) VoicemailsAPIGetVoicemailMessageRecordingRequest {
	r.token = &token
	return r
}

// Set to 1 to force download by browser
func (r VoicemailsAPIGetVoicemailMessageRecordingRequest) Download(download string) VoicemailsAPIGetVoicemailMessageRecordingRequest {
	r.download = &download
	return r
}

func (r VoicemailsAPIGetVoicemailMessageRecordingRequest) Execute() (*http.Response, error) {
	return r.ApiService.GetVoicemailMessageRecordingExecute(r)
}

/*
GetVoicemailMessageRecording Get a message's recording

**Required ACL:** `calld.voicemails.{voicemail_id}.messages.{message_id}.recording.read`

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param voicemailId The voicemail's ID
	@param messageId The message's ID
	@return VoicemailsAPIGetVoicemailMessageRecordingRequest
*/
func (a *VoicemailsAPIService) GetVoicemailMessageRecording(ctx context.Context, voicemailId int32, messageId string) VoicemailsAPIGetVoicemailMessageRecordingRequest {
	return VoicemailsAPIGetVoicemailMessageRecordingRequest{
		ApiService:  a,
		ctx:         ctx,
		voicemailId: voicemailId,
		messageId:   messageId,
	}
}

// Execute executes the request
func (a *VoicemailsAPIService) GetVoicemailMessageRecordingExecute(r VoicemailsAPIGetVoicemailMessageRecordingRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodGet
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "VoicemailsAPIService.GetVoicemailMessageRecording")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/voicemails/{voicemail_id}/messages/{message_id}/recording"
	localVarPath = strings.Replace(localVarPath, "{"+"voicemail_id"+"}", url.PathEscape(parameterValueToString(r.voicemailId, "voicemailId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"message_id"+"}", url.PathEscape(parameterValueToString(r.messageId, "messageId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.token != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "token", r.token, "")
	}
	if r.download != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "download", r.download, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"audio/wav"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["accent_auth_token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Auth-Token"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 503 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type VoicemailsAPIListUserVoicemailsRequest struct {
	ctx        context.Context
	ApiService VoicemailsAPI
}

func (r VoicemailsAPIListUserVoicemailsRequest) Execute() (*Voicemail, *http.Response, error) {
	return r.ApiService.ListUserVoicemailsExecute(r)
}

/*
ListUserVoicemails Get details of the voicemail of the authenticated user

**Required ACL:** `calld.users.me.voicemails.read`

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return VoicemailsAPIListUserVoicemailsRequest
*/
func (a *VoicemailsAPIService) ListUserVoicemails(ctx context.Context) VoicemailsAPIListUserVoicemailsRequest {
	return VoicemailsAPIListUserVoicemailsRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return Voicemail
func (a *VoicemailsAPIService) ListUserVoicemailsExecute(r VoicemailsAPIListUserVoicemailsRequest) (*Voicemail, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *Voicemail
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "VoicemailsAPIService.ListUserVoicemails")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/me/voicemails"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["accent_auth_token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Auth-Token"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 503 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type VoicemailsAPIUpdateUserVoicemailGreetingRequest struct {
	ctx        context.Context
	ApiService VoicemailsAPI
	body       *map[string]interface{}
	greeting   string
}

func (r VoicemailsAPIUpdateUserVoicemailGreetingRequest) Body(body map[string]interface{}) VoicemailsAPIUpdateUserVoicemailGreetingRequest {
	r.body = &body
	return r
}

func (r VoicemailsAPIUpdateUserVoicemailGreetingRequest) Execute() (*http.Response, error) {
	return r.ApiService.UpdateUserVoicemailGreetingExecute(r)
}

/*
UpdateUserVoicemailGreeting Update a custom greeting

**Required ACL:** `calld.users.me.voicemails.greetings.{greeting}.update`

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param greeting The greeting
	@return VoicemailsAPIUpdateUserVoicemailGreetingRequest
*/
func (a *VoicemailsAPIService) UpdateUserVoicemailGreeting(ctx context.Context, greeting string) VoicemailsAPIUpdateUserVoicemailGreetingRequest {
	return VoicemailsAPIUpdateUserVoicemailGreetingRequest{
		ApiService: a,
		ctx:        ctx,
		greeting:   greeting,
	}
}

// Execute executes the request
func (a *VoicemailsAPIService) UpdateUserVoicemailGreetingExecute(r VoicemailsAPIUpdateUserVoicemailGreetingRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodPut
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "VoicemailsAPIService.UpdateUserVoicemailGreeting")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/me/voicemails/greetings/{greeting}"
	localVarPath = strings.Replace(localVarPath, "{"+"greeting"+"}", url.PathEscape(parameterValueToString(r.greeting, "greeting")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return nil, reportError("body is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"audio/wav"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["accent_auth_token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Auth-Token"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 503 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type VoicemailsAPIUpdateUserVoicemailMessageRequest struct {
	ctx        context.Context
	ApiService VoicemailsAPI
	body       *VoicemailMessageUpdate
	messageId  string
}

// Message
func (r VoicemailsAPIUpdateUserVoicemailMessageRequest) Body(body VoicemailMessageUpdate) VoicemailsAPIUpdateUserVoicemailMessageRequest {
	r.body = &body
	return r
}

func (r VoicemailsAPIUpdateUserVoicemailMessageRequest) Execute() (*http.Response, error) {
	return r.ApiService.UpdateUserVoicemailMessageExecute(r)
}

/*
UpdateUserVoicemailMessage Update a message

**Required ACL:** `calld.users.me.voicemails.messages.{message_id}.update`

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param messageId The message's ID
	@return VoicemailsAPIUpdateUserVoicemailMessageRequest
*/
func (a *VoicemailsAPIService) UpdateUserVoicemailMessage(ctx context.Context, messageId string) VoicemailsAPIUpdateUserVoicemailMessageRequest {
	return VoicemailsAPIUpdateUserVoicemailMessageRequest{
		ApiService: a,
		ctx:        ctx,
		messageId:  messageId,
	}
}

// Execute executes the request
func (a *VoicemailsAPIService) UpdateUserVoicemailMessageExecute(r VoicemailsAPIUpdateUserVoicemailMessageRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodPut
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "VoicemailsAPIService.UpdateUserVoicemailMessage")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/me/voicemails/messages/{message_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"message_id"+"}", url.PathEscape(parameterValueToString(r.messageId, "messageId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return nil, reportError("body is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["accent_auth_token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Auth-Token"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 503 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type VoicemailsAPIUpdateVoicemailGreetingRequest struct {
	ctx         context.Context
	ApiService  VoicemailsAPI
	body        *map[string]interface{}
	voicemailId int32
	greeting    string
}

func (r VoicemailsAPIUpdateVoicemailGreetingRequest) Body(body map[string]interface{}) VoicemailsAPIUpdateVoicemailGreetingRequest {
	r.body = &body
	return r
}

func (r VoicemailsAPIUpdateVoicemailGreetingRequest) Execute() (*http.Response, error) {
	return r.ApiService.UpdateVoicemailGreetingExecute(r)
}

/*
UpdateVoicemailGreeting Update a custom greeting

**Required ACL:** `calld.voicemails.{voicemail_id}.greetings.{greeting}.update`

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param voicemailId The voicemail's ID
	@param greeting The greeting
	@return VoicemailsAPIUpdateVoicemailGreetingRequest
*/
func (a *VoicemailsAPIService) UpdateVoicemailGreeting(ctx context.Context, voicemailId int32, greeting string) VoicemailsAPIUpdateVoicemailGreetingRequest {
	return VoicemailsAPIUpdateVoicemailGreetingRequest{
		ApiService:  a,
		ctx:         ctx,
		voicemailId: voicemailId,
		greeting:    greeting,
	}
}

// Execute executes the request
func (a *VoicemailsAPIService) UpdateVoicemailGreetingExecute(r VoicemailsAPIUpdateVoicemailGreetingRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodPut
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "VoicemailsAPIService.UpdateVoicemailGreeting")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/voicemails/{voicemail_id}/greetings/{greeting}"
	localVarPath = strings.Replace(localVarPath, "{"+"voicemail_id"+"}", url.PathEscape(parameterValueToString(r.voicemailId, "voicemailId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"greeting"+"}", url.PathEscape(parameterValueToString(r.greeting, "greeting")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return nil, reportError("body is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"audio/wav"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["accent_auth_token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Auth-Token"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 503 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type VoicemailsAPIUpdateVoicemailMessageRequest struct {
	ctx         context.Context
	ApiService  VoicemailsAPI
	body        *VoicemailMessageUpdate
	voicemailId int32
	messageId   string
}

// Message
func (r VoicemailsAPIUpdateVoicemailMessageRequest) Body(body VoicemailMessageUpdate) VoicemailsAPIUpdateVoicemailMessageRequest {
	r.body = &body
	return r
}

func (r VoicemailsAPIUpdateVoicemailMessageRequest) Execute() (*http.Response, error) {
	return r.ApiService.UpdateVoicemailMessageExecute(r)
}

/*
UpdateVoicemailMessage Update a message

**Required ACL:** `calld.voicemails.{voicemail_id}.messages.{message_id}.update`

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param voicemailId The voicemail's ID
	@param messageId The message's ID
	@return VoicemailsAPIUpdateVoicemailMessageRequest
*/
func (a *VoicemailsAPIService) UpdateVoicemailMessage(ctx context.Context, voicemailId int32, messageId string) VoicemailsAPIUpdateVoicemailMessageRequest {
	return VoicemailsAPIUpdateVoicemailMessageRequest{
		ApiService:  a,
		ctx:         ctx,
		voicemailId: voicemailId,
		messageId:   messageId,
	}
}

// Execute executes the request
func (a *VoicemailsAPIService) UpdateVoicemailMessageExecute(r VoicemailsAPIUpdateVoicemailMessageRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodPut
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "VoicemailsAPIService.UpdateVoicemailMessage")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/voicemails/{voicemail_id}/messages/{message_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"voicemail_id"+"}", url.PathEscape(parameterValueToString(r.voicemailId, "voicemailId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"message_id"+"}", url.PathEscape(parameterValueToString(r.messageId, "messageId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return nil, reportError("body is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["accent_auth_token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Auth-Token"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 503 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

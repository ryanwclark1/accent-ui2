/*
accent-calld

Control your calls from a REST API

API version: 1.0.0
Contact: help@accentvoice.io
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package calld

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"strings"
)

type VoicemailsAPI interface {

	/*
		CheckUserVoicemailGreeting Check if greeting exists

		**Required ACL:** `calld.users.me.voicemails.greetings.{greeting}.read`

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param greeting The greeting
		@return ApiCheckUserVoicemailGreetingRequest
	*/
	CheckUserVoicemailGreeting(ctx context.Context, greeting string) ApiCheckUserVoicemailGreetingRequest

	// CheckUserVoicemailGreetingExecute executes the request
	CheckUserVoicemailGreetingExecute(r ApiCheckUserVoicemailGreetingRequest) (*http.Response, error)

	/*
		CheckVoicemailGreeting Check if greeting exists

		**Required ACL:** `calld.voicemails.{voicemail_id}.greetings.{greeting}.read`

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param voicemailId The voicemail's ID
		@param greeting The greeting
		@return ApiCheckVoicemailGreetingRequest
	*/
	CheckVoicemailGreeting(ctx context.Context, voicemailId int32, greeting string) ApiCheckVoicemailGreetingRequest

	// CheckVoicemailGreetingExecute executes the request
	CheckVoicemailGreetingExecute(r ApiCheckVoicemailGreetingRequest) (*http.Response, error)

	/*
		CopyUserVoicemailGreeting Copy a custom greeting

		**Required ACL:** `calld.users.me.voicemails.greetings.{greeting}.copy.create`

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param greeting The greeting
		@return ApiCopyUserVoicemailGreetingRequest
	*/
	CopyUserVoicemailGreeting(ctx context.Context, greeting string) ApiCopyUserVoicemailGreetingRequest

	// CopyUserVoicemailGreetingExecute executes the request
	CopyUserVoicemailGreetingExecute(r ApiCopyUserVoicemailGreetingRequest) (*http.Response, error)

	/*
		CopyVoicemailGreeting Copy a custom greeting

		**Required ACL:** `calld.voicemails.{voicemail_id}.greetings.{greeting}.copy.create`

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param voicemailId The voicemail's ID
		@param greeting The greeting
		@return ApiCopyVoicemailGreetingRequest
	*/
	CopyVoicemailGreeting(ctx context.Context, voicemailId int32, greeting string) ApiCopyVoicemailGreetingRequest

	// CopyVoicemailGreetingExecute executes the request
	CopyVoicemailGreetingExecute(r ApiCopyVoicemailGreetingRequest) (*http.Response, error)

	/*
		CreateUserVoicemailGreeting Create a custom greeting

		**Required ACL:** `calld.users.me.voicemails.greetings.{greeting}.create`

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param greeting The greeting
		@return ApiCreateUserVoicemailGreetingRequest
	*/
	CreateUserVoicemailGreeting(ctx context.Context, greeting string) ApiCreateUserVoicemailGreetingRequest

	// CreateUserVoicemailGreetingExecute executes the request
	CreateUserVoicemailGreetingExecute(r ApiCreateUserVoicemailGreetingRequest) (*http.Response, error)

	/*
		CreateVoicemailGreeting Create a custom greeting

		**Required ACL:** `calld.voicemails.{voicemail_id}.greetings.{greeting}.create`

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param voicemailId The voicemail's ID
		@param greeting The greeting
		@return ApiCreateVoicemailGreetingRequest
	*/
	CreateVoicemailGreeting(ctx context.Context, voicemailId int32, greeting string) ApiCreateVoicemailGreetingRequest

	// CreateVoicemailGreetingExecute executes the request
	CreateVoicemailGreetingExecute(r ApiCreateVoicemailGreetingRequest) (*http.Response, error)

	/*
		DeleteUserVoicemailGreeting Delete a custom greeting

		**Required ACL:** `calld.users.me.voicemails.greetings.{greeting}.delete`

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param greeting The greeting
		@return ApiDeleteUserVoicemailGreetingRequest
	*/
	DeleteUserVoicemailGreeting(ctx context.Context, greeting string) ApiDeleteUserVoicemailGreetingRequest

	// DeleteUserVoicemailGreetingExecute executes the request
	DeleteUserVoicemailGreetingExecute(r ApiDeleteUserVoicemailGreetingRequest) (*http.Response, error)

	/*
		DeleteUserVoicemailMessage Delete a mesage

		**Required ACL:** `calld.users.me.voicemails.messages.{message_id}.delete`

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param messageId The message's ID
		@return ApiDeleteUserVoicemailMessageRequest
	*/
	DeleteUserVoicemailMessage(ctx context.Context, messageId string) ApiDeleteUserVoicemailMessageRequest

	// DeleteUserVoicemailMessageExecute executes the request
	DeleteUserVoicemailMessageExecute(r ApiDeleteUserVoicemailMessageRequest) (*http.Response, error)

	/*
		DeleteVoicemailGreeting Delete a custom greeting

		**Required ACL:** `calld.voicemails.{voicemail_id}.greetings.{greeting}.delete`

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param voicemailId The voicemail's ID
		@param greeting The greeting
		@return ApiDeleteVoicemailGreetingRequest
	*/
	DeleteVoicemailGreeting(ctx context.Context, voicemailId int32, greeting string) ApiDeleteVoicemailGreetingRequest

	// DeleteVoicemailGreetingExecute executes the request
	DeleteVoicemailGreetingExecute(r ApiDeleteVoicemailGreetingRequest) (*http.Response, error)

	/*
		DeleteVoicemailMessage Delete a mesage

		**Required ACL:** `calld.voicemails.{voicemail_id}.messages.{message_id}.delete`

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param voicemailId The voicemail's ID
		@param messageId The message's ID
		@return ApiDeleteVoicemailMessageRequest
	*/
	DeleteVoicemailMessage(ctx context.Context, voicemailId int32, messageId string) ApiDeleteVoicemailMessageRequest

	// DeleteVoicemailMessageExecute executes the request
	DeleteVoicemailMessageExecute(r ApiDeleteVoicemailMessageRequest) (*http.Response, error)

	/*
		GetUserVoicemailFolder Get details of a folder

		**Required ACL:** `calld.users.me.voicemails.folders.{folder_id}.read`

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param folderId The folder's ID
		@return ApiGetUserVoicemailFolderRequest
	*/
	GetUserVoicemailFolder(ctx context.Context, folderId int32) ApiGetUserVoicemailFolderRequest

	// GetUserVoicemailFolderExecute executes the request
	//  @return VoicemailFolder
	GetUserVoicemailFolderExecute(r ApiGetUserVoicemailFolderRequest) (*VoicemailFolder, *http.Response, error)

	/*
		GetUserVoicemailGreeting Get a custom greeting

		**Required ACL:** `calld.users.me.voicemails.greetings.{greeting}.read`

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param greeting The greeting
		@return ApiGetUserVoicemailGreetingRequest
	*/
	GetUserVoicemailGreeting(ctx context.Context, greeting string) ApiGetUserVoicemailGreetingRequest

	// GetUserVoicemailGreetingExecute executes the request
	GetUserVoicemailGreetingExecute(r ApiGetUserVoicemailGreetingRequest) (*http.Response, error)

	/*
		GetUserVoicemailMessage Get a message

		**Required ACL:** `calld.users.me.voicemails.messages.{message_id}.read`

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param messageId The message's ID
		@return ApiGetUserVoicemailMessageRequest
	*/
	GetUserVoicemailMessage(ctx context.Context, messageId string) ApiGetUserVoicemailMessageRequest

	// GetUserVoicemailMessageExecute executes the request
	//  @return VoicemailMessage
	GetUserVoicemailMessageExecute(r ApiGetUserVoicemailMessageRequest) (*VoicemailMessage, *http.Response, error)

	/*
		GetUserVoicemailMessageRecording Get a message's recording

		**Required ACL:** `calld.users.me.voicemails.messages.{message_id}.recording.read`

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param messageId The message's ID
		@return ApiGetUserVoicemailMessageRecordingRequest
	*/
	GetUserVoicemailMessageRecording(ctx context.Context, messageId string) ApiGetUserVoicemailMessageRecordingRequest

	// GetUserVoicemailMessageRecordingExecute executes the request
	GetUserVoicemailMessageRecordingExecute(r ApiGetUserVoicemailMessageRecordingRequest) (*http.Response, error)

	/*
		GetVoicemail Get details of a voicemail

		**Required ACL:** `calld.voicemails.{voicemail_id}.read`

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param voicemailId The voicemail's ID
		@return ApiGetVoicemailRequest
	*/
	GetVoicemail(ctx context.Context, voicemailId int32) ApiGetVoicemailRequest

	// GetVoicemailExecute executes the request
	//  @return Voicemail
	GetVoicemailExecute(r ApiGetVoicemailRequest) (*Voicemail, *http.Response, error)

	/*
		GetVoicemailFolder Get details of a folder

		**Required ACL:** `calld.voicemails.{voicemail_id}.folders.{folder_id}.read`

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param voicemailId The voicemail's ID
		@param folderId The folder's ID
		@return ApiGetVoicemailFolderRequest
	*/
	GetVoicemailFolder(ctx context.Context, voicemailId int32, folderId int32) ApiGetVoicemailFolderRequest

	// GetVoicemailFolderExecute executes the request
	//  @return VoicemailFolder
	GetVoicemailFolderExecute(r ApiGetVoicemailFolderRequest) (*VoicemailFolder, *http.Response, error)

	/*
		GetVoicemailGreeting Get a custom greeting

		**Required ACL:** `calld.voicemails.{voicemail_id}.greetings.{greeting}.read`

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param voicemailId The voicemail's ID
		@param greeting The greeting
		@return ApiGetVoicemailGreetingRequest
	*/
	GetVoicemailGreeting(ctx context.Context, voicemailId int32, greeting string) ApiGetVoicemailGreetingRequest

	// GetVoicemailGreetingExecute executes the request
	GetVoicemailGreetingExecute(r ApiGetVoicemailGreetingRequest) (*http.Response, error)

	/*
		GetVoicemailMessage Get a message

		**Required ACL:** `calld.voicemails.{voicemail_id}.messages.{message_id}.read`

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param voicemailId The voicemail's ID
		@param messageId The message's ID
		@return ApiGetVoicemailMessageRequest
	*/
	GetVoicemailMessage(ctx context.Context, voicemailId int32, messageId string) ApiGetVoicemailMessageRequest

	// GetVoicemailMessageExecute executes the request
	//  @return VoicemailMessage
	GetVoicemailMessageExecute(r ApiGetVoicemailMessageRequest) (*VoicemailMessage, *http.Response, error)

	/*
		GetVoicemailMessageRecording Get a message's recording

		**Required ACL:** `calld.voicemails.{voicemail_id}.messages.{message_id}.recording.read`

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param voicemailId The voicemail's ID
		@param messageId The message's ID
		@return ApiGetVoicemailMessageRecordingRequest
	*/
	GetVoicemailMessageRecording(ctx context.Context, voicemailId int32, messageId string) ApiGetVoicemailMessageRecordingRequest

	// GetVoicemailMessageRecordingExecute executes the request
	GetVoicemailMessageRecordingExecute(r ApiGetVoicemailMessageRecordingRequest) (*http.Response, error)

	/*
		ListUserVoicemails Get details of the voicemail of the authenticated user

		**Required ACL:** `calld.users.me.voicemails.read`

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@return ApiListUserVoicemailsRequest
	*/
	ListUserVoicemails(ctx context.Context) ApiListUserVoicemailsRequest

	// ListUserVoicemailsExecute executes the request
	//  @return Voicemail
	ListUserVoicemailsExecute(r ApiListUserVoicemailsRequest) (*Voicemail, *http.Response, error)

	/*
		UpdateUserVoicemailGreeting Update a custom greeting

		**Required ACL:** `calld.users.me.voicemails.greetings.{greeting}.update`

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param greeting The greeting
		@return ApiUpdateUserVoicemailGreetingRequest
	*/
	UpdateUserVoicemailGreeting(ctx context.Context, greeting string) ApiUpdateUserVoicemailGreetingRequest

	// UpdateUserVoicemailGreetingExecute executes the request
	UpdateUserVoicemailGreetingExecute(r ApiUpdateUserVoicemailGreetingRequest) (*http.Response, error)

	/*
		UpdateUserVoicemailMessage Update a message

		**Required ACL:** `calld.users.me.voicemails.messages.{message_id}.update`

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param messageId The message's ID
		@return ApiUpdateUserVoicemailMessageRequest
	*/
	UpdateUserVoicemailMessage(ctx context.Context, messageId string) ApiUpdateUserVoicemailMessageRequest

	// UpdateUserVoicemailMessageExecute executes the request
	UpdateUserVoicemailMessageExecute(r ApiUpdateUserVoicemailMessageRequest) (*http.Response, error)

	/*
		UpdateVoicemailGreeting Update a custom greeting

		**Required ACL:** `calld.voicemails.{voicemail_id}.greetings.{greeting}.update`

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param voicemailId The voicemail's ID
		@param greeting The greeting
		@return ApiUpdateVoicemailGreetingRequest
	*/
	UpdateVoicemailGreeting(ctx context.Context, voicemailId int32, greeting string) ApiUpdateVoicemailGreetingRequest

	// UpdateVoicemailGreetingExecute executes the request
	UpdateVoicemailGreetingExecute(r ApiUpdateVoicemailGreetingRequest) (*http.Response, error)

	/*
		UpdateVoicemailMessage Update a message

		**Required ACL:** `calld.voicemails.{voicemail_id}.messages.{message_id}.update`

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param voicemailId The voicemail's ID
		@param messageId The message's ID
		@return ApiUpdateVoicemailMessageRequest
	*/
	UpdateVoicemailMessage(ctx context.Context, voicemailId int32, messageId string) ApiUpdateVoicemailMessageRequest

	// UpdateVoicemailMessageExecute executes the request
	UpdateVoicemailMessageExecute(r ApiUpdateVoicemailMessageRequest) (*http.Response, error)
}

// VoicemailsAPIService VoicemailsAPI service
type VoicemailsAPIService service

type ApiCheckUserVoicemailGreetingRequest struct {
	ctx        context.Context
	ApiService VoicemailsAPI
	greeting   string
}

func (r ApiCheckUserVoicemailGreetingRequest) Execute() (*http.Response, error) {
	return r.ApiService.CheckUserVoicemailGreetingExecute(r)
}

/*
CheckUserVoicemailGreeting Check if greeting exists

**Required ACL:** `calld.users.me.voicemails.greetings.{greeting}.read`

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param greeting The greeting
	@return ApiCheckUserVoicemailGreetingRequest
*/
func (a *VoicemailsAPIService) CheckUserVoicemailGreeting(ctx context.Context, greeting string) ApiCheckUserVoicemailGreetingRequest {
	return ApiCheckUserVoicemailGreetingRequest{
		ApiService: a,
		ctx:        ctx,
		greeting:   greeting,
	}
}

// Execute executes the request
func (a *VoicemailsAPIService) CheckUserVoicemailGreetingExecute(r ApiCheckUserVoicemailGreetingRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodHead
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "VoicemailsAPIService.CheckUserVoicemailGreeting")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/me/voicemails/greetings/{greeting}"
	localVarPath = strings.Replace(localVarPath, "{"+"greeting"+"}", url.PathEscape(parameterValueToString(r.greeting, "greeting")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["accent_auth_token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Auth-Token"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 503 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiCheckVoicemailGreetingRequest struct {
	ctx         context.Context
	ApiService  VoicemailsAPI
	voicemailId int32
	greeting    string
}

func (r ApiCheckVoicemailGreetingRequest) Execute() (*http.Response, error) {
	return r.ApiService.CheckVoicemailGreetingExecute(r)
}

/*
CheckVoicemailGreeting Check if greeting exists

**Required ACL:** `calld.voicemails.{voicemail_id}.greetings.{greeting}.read`

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param voicemailId The voicemail's ID
	@param greeting The greeting
	@return ApiCheckVoicemailGreetingRequest
*/
func (a *VoicemailsAPIService) CheckVoicemailGreeting(ctx context.Context, voicemailId int32, greeting string) ApiCheckVoicemailGreetingRequest {
	return ApiCheckVoicemailGreetingRequest{
		ApiService:  a,
		ctx:         ctx,
		voicemailId: voicemailId,
		greeting:    greeting,
	}
}

// Execute executes the request
func (a *VoicemailsAPIService) CheckVoicemailGreetingExecute(r ApiCheckVoicemailGreetingRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodHead
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "VoicemailsAPIService.CheckVoicemailGreeting")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/voicemails/{voicemail_id}/greetings/{greeting}"
	localVarPath = strings.Replace(localVarPath, "{"+"voicemail_id"+"}", url.PathEscape(parameterValueToString(r.voicemailId, "voicemailId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"greeting"+"}", url.PathEscape(parameterValueToString(r.greeting, "greeting")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["accent_auth_token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Auth-Token"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 503 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiCopyUserVoicemailGreetingRequest struct {
	ctx        context.Context
	ApiService VoicemailsAPI
	body       *GreetingCopy
	greeting   string
}

func (r ApiCopyUserVoicemailGreetingRequest) Body(body GreetingCopy) ApiCopyUserVoicemailGreetingRequest {
	r.body = &body
	return r
}

func (r ApiCopyUserVoicemailGreetingRequest) Execute() (*http.Response, error) {
	return r.ApiService.CopyUserVoicemailGreetingExecute(r)
}

/*
CopyUserVoicemailGreeting Copy a custom greeting

**Required ACL:** `calld.users.me.voicemails.greetings.{greeting}.copy.create`

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param greeting The greeting
	@return ApiCopyUserVoicemailGreetingRequest
*/
func (a *VoicemailsAPIService) CopyUserVoicemailGreeting(ctx context.Context, greeting string) ApiCopyUserVoicemailGreetingRequest {
	return ApiCopyUserVoicemailGreetingRequest{
		ApiService: a,
		ctx:        ctx,
		greeting:   greeting,
	}
}

// Execute executes the request
func (a *VoicemailsAPIService) CopyUserVoicemailGreetingExecute(r ApiCopyUserVoicemailGreetingRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodPost
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "VoicemailsAPIService.CopyUserVoicemailGreeting")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/me/voicemails/greetings/{greeting}/copy"
	localVarPath = strings.Replace(localVarPath, "{"+"greeting"+"}", url.PathEscape(parameterValueToString(r.greeting, "greeting")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return nil, reportError("body is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["accent_auth_token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Auth-Token"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 503 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiCopyVoicemailGreetingRequest struct {
	ctx         context.Context
	ApiService  VoicemailsAPI
	body        *GreetingCopy
	voicemailId int32
	greeting    string
}

func (r ApiCopyVoicemailGreetingRequest) Body(body GreetingCopy) ApiCopyVoicemailGreetingRequest {
	r.body = &body
	return r
}

func (r ApiCopyVoicemailGreetingRequest) Execute() (*http.Response, error) {
	return r.ApiService.CopyVoicemailGreetingExecute(r)
}

/*
CopyVoicemailGreeting Copy a custom greeting

**Required ACL:** `calld.voicemails.{voicemail_id}.greetings.{greeting}.copy.create`

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param voicemailId The voicemail's ID
	@param greeting The greeting
	@return ApiCopyVoicemailGreetingRequest
*/
func (a *VoicemailsAPIService) CopyVoicemailGreeting(ctx context.Context, voicemailId int32, greeting string) ApiCopyVoicemailGreetingRequest {
	return ApiCopyVoicemailGreetingRequest{
		ApiService:  a,
		ctx:         ctx,
		voicemailId: voicemailId,
		greeting:    greeting,
	}
}

// Execute executes the request
func (a *VoicemailsAPIService) CopyVoicemailGreetingExecute(r ApiCopyVoicemailGreetingRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodPost
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "VoicemailsAPIService.CopyVoicemailGreeting")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/voicemails/{voicemail_id}/greetings/{greeting}/copy"
	localVarPath = strings.Replace(localVarPath, "{"+"voicemail_id"+"}", url.PathEscape(parameterValueToString(r.voicemailId, "voicemailId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"greeting"+"}", url.PathEscape(parameterValueToString(r.greeting, "greeting")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return nil, reportError("body is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["accent_auth_token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Auth-Token"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 503 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiCreateUserVoicemailGreetingRequest struct {
	ctx        context.Context
	ApiService VoicemailsAPI
	body       *map[string]interface{}
	greeting   string
}

func (r ApiCreateUserVoicemailGreetingRequest) Body(body map[string]interface{}) ApiCreateUserVoicemailGreetingRequest {
	r.body = &body
	return r
}

func (r ApiCreateUserVoicemailGreetingRequest) Execute() (*http.Response, error) {
	return r.ApiService.CreateUserVoicemailGreetingExecute(r)
}

/*
CreateUserVoicemailGreeting Create a custom greeting

**Required ACL:** `calld.users.me.voicemails.greetings.{greeting}.create`

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param greeting The greeting
	@return ApiCreateUserVoicemailGreetingRequest
*/
func (a *VoicemailsAPIService) CreateUserVoicemailGreeting(ctx context.Context, greeting string) ApiCreateUserVoicemailGreetingRequest {
	return ApiCreateUserVoicemailGreetingRequest{
		ApiService: a,
		ctx:        ctx,
		greeting:   greeting,
	}
}

// Execute executes the request
func (a *VoicemailsAPIService) CreateUserVoicemailGreetingExecute(r ApiCreateUserVoicemailGreetingRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodPost
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "VoicemailsAPIService.CreateUserVoicemailGreeting")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/me/voicemails/greetings/{greeting}"
	localVarPath = strings.Replace(localVarPath, "{"+"greeting"+"}", url.PathEscape(parameterValueToString(r.greeting, "greeting")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return nil, reportError("body is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"audio/wav"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["accent_auth_token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Auth-Token"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 503 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiCreateVoicemailGreetingRequest struct {
	ctx         context.Context
	ApiService  VoicemailsAPI
	body        *map[string]interface{}
	voicemailId int32
	greeting    string
}

func (r ApiCreateVoicemailGreetingRequest) Body(body map[string]interface{}) ApiCreateVoicemailGreetingRequest {
	r.body = &body
	return r
}

func (r ApiCreateVoicemailGreetingRequest) Execute() (*http.Response, error) {
	return r.ApiService.CreateVoicemailGreetingExecute(r)
}

/*
CreateVoicemailGreeting Create a custom greeting

**Required ACL:** `calld.voicemails.{voicemail_id}.greetings.{greeting}.create`

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param voicemailId The voicemail's ID
	@param greeting The greeting
	@return ApiCreateVoicemailGreetingRequest
*/
func (a *VoicemailsAPIService) CreateVoicemailGreeting(ctx context.Context, voicemailId int32, greeting string) ApiCreateVoicemailGreetingRequest {
	return ApiCreateVoicemailGreetingRequest{
		ApiService:  a,
		ctx:         ctx,
		voicemailId: voicemailId,
		greeting:    greeting,
	}
}

// Execute executes the request
func (a *VoicemailsAPIService) CreateVoicemailGreetingExecute(r ApiCreateVoicemailGreetingRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodPost
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "VoicemailsAPIService.CreateVoicemailGreeting")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/voicemails/{voicemail_id}/greetings/{greeting}"
	localVarPath = strings.Replace(localVarPath, "{"+"voicemail_id"+"}", url.PathEscape(parameterValueToString(r.voicemailId, "voicemailId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"greeting"+"}", url.PathEscape(parameterValueToString(r.greeting, "greeting")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return nil, reportError("body is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"audio/wav"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["accent_auth_token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Auth-Token"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 503 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiDeleteUserVoicemailGreetingRequest struct {
	ctx        context.Context
	ApiService VoicemailsAPI
	greeting   string
}

func (r ApiDeleteUserVoicemailGreetingRequest) Execute() (*http.Response, error) {
	return r.ApiService.DeleteUserVoicemailGreetingExecute(r)
}

/*
DeleteUserVoicemailGreeting Delete a custom greeting

**Required ACL:** `calld.users.me.voicemails.greetings.{greeting}.delete`

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param greeting The greeting
	@return ApiDeleteUserVoicemailGreetingRequest
*/
func (a *VoicemailsAPIService) DeleteUserVoicemailGreeting(ctx context.Context, greeting string) ApiDeleteUserVoicemailGreetingRequest {
	return ApiDeleteUserVoicemailGreetingRequest{
		ApiService: a,
		ctx:        ctx,
		greeting:   greeting,
	}
}

// Execute executes the request
func (a *VoicemailsAPIService) DeleteUserVoicemailGreetingExecute(r ApiDeleteUserVoicemailGreetingRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodDelete
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "VoicemailsAPIService.DeleteUserVoicemailGreeting")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/me/voicemails/greetings/{greeting}"
	localVarPath = strings.Replace(localVarPath, "{"+"greeting"+"}", url.PathEscape(parameterValueToString(r.greeting, "greeting")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["accent_auth_token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Auth-Token"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 503 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiDeleteUserVoicemailMessageRequest struct {
	ctx        context.Context
	ApiService VoicemailsAPI
	messageId  string
}

func (r ApiDeleteUserVoicemailMessageRequest) Execute() (*http.Response, error) {
	return r.ApiService.DeleteUserVoicemailMessageExecute(r)
}

/*
DeleteUserVoicemailMessage Delete a mesage

**Required ACL:** `calld.users.me.voicemails.messages.{message_id}.delete`

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param messageId The message's ID
	@return ApiDeleteUserVoicemailMessageRequest
*/
func (a *VoicemailsAPIService) DeleteUserVoicemailMessage(ctx context.Context, messageId string) ApiDeleteUserVoicemailMessageRequest {
	return ApiDeleteUserVoicemailMessageRequest{
		ApiService: a,
		ctx:        ctx,
		messageId:  messageId,
	}
}

// Execute executes the request
func (a *VoicemailsAPIService) DeleteUserVoicemailMessageExecute(r ApiDeleteUserVoicemailMessageRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodDelete
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "VoicemailsAPIService.DeleteUserVoicemailMessage")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/me/voicemails/messages/{message_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"message_id"+"}", url.PathEscape(parameterValueToString(r.messageId, "messageId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["accent_auth_token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Auth-Token"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 503 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiDeleteVoicemailGreetingRequest struct {
	ctx         context.Context
	ApiService  VoicemailsAPI
	voicemailId int32
	greeting    string
}

func (r ApiDeleteVoicemailGreetingRequest) Execute() (*http.Response, error) {
	return r.ApiService.DeleteVoicemailGreetingExecute(r)
}

/*
DeleteVoicemailGreeting Delete a custom greeting

**Required ACL:** `calld.voicemails.{voicemail_id}.greetings.{greeting}.delete`

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param voicemailId The voicemail's ID
	@param greeting The greeting
	@return ApiDeleteVoicemailGreetingRequest
*/
func (a *VoicemailsAPIService) DeleteVoicemailGreeting(ctx context.Context, voicemailId int32, greeting string) ApiDeleteVoicemailGreetingRequest {
	return ApiDeleteVoicemailGreetingRequest{
		ApiService:  a,
		ctx:         ctx,
		voicemailId: voicemailId,
		greeting:    greeting,
	}
}

// Execute executes the request
func (a *VoicemailsAPIService) DeleteVoicemailGreetingExecute(r ApiDeleteVoicemailGreetingRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodDelete
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "VoicemailsAPIService.DeleteVoicemailGreeting")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/voicemails/{voicemail_id}/greetings/{greeting}"
	localVarPath = strings.Replace(localVarPath, "{"+"voicemail_id"+"}", url.PathEscape(parameterValueToString(r.voicemailId, "voicemailId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"greeting"+"}", url.PathEscape(parameterValueToString(r.greeting, "greeting")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["accent_auth_token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Auth-Token"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 503 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiDeleteVoicemailMessageRequest struct {
	ctx         context.Context
	ApiService  VoicemailsAPI
	voicemailId int32
	messageId   string
}

func (r ApiDeleteVoicemailMessageRequest) Execute() (*http.Response, error) {
	return r.ApiService.DeleteVoicemailMessageExecute(r)
}

/*
DeleteVoicemailMessage Delete a mesage

**Required ACL:** `calld.voicemails.{voicemail_id}.messages.{message_id}.delete`

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param voicemailId The voicemail's ID
	@param messageId The message's ID
	@return ApiDeleteVoicemailMessageRequest
*/
func (a *VoicemailsAPIService) DeleteVoicemailMessage(ctx context.Context, voicemailId int32, messageId string) ApiDeleteVoicemailMessageRequest {
	return ApiDeleteVoicemailMessageRequest{
		ApiService:  a,
		ctx:         ctx,
		voicemailId: voicemailId,
		messageId:   messageId,
	}
}

// Execute executes the request
func (a *VoicemailsAPIService) DeleteVoicemailMessageExecute(r ApiDeleteVoicemailMessageRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodDelete
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "VoicemailsAPIService.DeleteVoicemailMessage")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/voicemails/{voicemail_id}/messages/{message_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"voicemail_id"+"}", url.PathEscape(parameterValueToString(r.voicemailId, "voicemailId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"message_id"+"}", url.PathEscape(parameterValueToString(r.messageId, "messageId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["accent_auth_token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Auth-Token"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 503 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiGetUserVoicemailFolderRequest struct {
	ctx        context.Context
	ApiService VoicemailsAPI
	folderId   int32
}

func (r ApiGetUserVoicemailFolderRequest) Execute() (*VoicemailFolder, *http.Response, error) {
	return r.ApiService.GetUserVoicemailFolderExecute(r)
}

/*
GetUserVoicemailFolder Get details of a folder

**Required ACL:** `calld.users.me.voicemails.folders.{folder_id}.read`

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param folderId The folder's ID
	@return ApiGetUserVoicemailFolderRequest
*/
func (a *VoicemailsAPIService) GetUserVoicemailFolder(ctx context.Context, folderId int32) ApiGetUserVoicemailFolderRequest {
	return ApiGetUserVoicemailFolderRequest{
		ApiService: a,
		ctx:        ctx,
		folderId:   folderId,
	}
}

// Execute executes the request
//
//	@return VoicemailFolder
func (a *VoicemailsAPIService) GetUserVoicemailFolderExecute(r ApiGetUserVoicemailFolderRequest) (*VoicemailFolder, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *VoicemailFolder
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "VoicemailsAPIService.GetUserVoicemailFolder")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/me/voicemails/folders/{folder_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"folder_id"+"}", url.PathEscape(parameterValueToString(r.folderId, "folderId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["accent_auth_token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Auth-Token"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 503 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetUserVoicemailGreetingRequest struct {
	ctx        context.Context
	ApiService VoicemailsAPI
	greeting   string
}

func (r ApiGetUserVoicemailGreetingRequest) Execute() (*http.Response, error) {
	return r.ApiService.GetUserVoicemailGreetingExecute(r)
}

/*
GetUserVoicemailGreeting Get a custom greeting

**Required ACL:** `calld.users.me.voicemails.greetings.{greeting}.read`

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param greeting The greeting
	@return ApiGetUserVoicemailGreetingRequest
*/
func (a *VoicemailsAPIService) GetUserVoicemailGreeting(ctx context.Context, greeting string) ApiGetUserVoicemailGreetingRequest {
	return ApiGetUserVoicemailGreetingRequest{
		ApiService: a,
		ctx:        ctx,
		greeting:   greeting,
	}
}

// Execute executes the request
func (a *VoicemailsAPIService) GetUserVoicemailGreetingExecute(r ApiGetUserVoicemailGreetingRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodGet
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "VoicemailsAPIService.GetUserVoicemailGreeting")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/me/voicemails/greetings/{greeting}"
	localVarPath = strings.Replace(localVarPath, "{"+"greeting"+"}", url.PathEscape(parameterValueToString(r.greeting, "greeting")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"audio/wav"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["accent_auth_token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Auth-Token"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 503 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiGetUserVoicemailMessageRequest struct {
	ctx        context.Context
	ApiService VoicemailsAPI
	messageId  string
}

func (r ApiGetUserVoicemailMessageRequest) Execute() (*VoicemailMessage, *http.Response, error) {
	return r.ApiService.GetUserVoicemailMessageExecute(r)
}

/*
GetUserVoicemailMessage Get a message

**Required ACL:** `calld.users.me.voicemails.messages.{message_id}.read`

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param messageId The message's ID
	@return ApiGetUserVoicemailMessageRequest
*/
func (a *VoicemailsAPIService) GetUserVoicemailMessage(ctx context.Context, messageId string) ApiGetUserVoicemailMessageRequest {
	return ApiGetUserVoicemailMessageRequest{
		ApiService: a,
		ctx:        ctx,
		messageId:  messageId,
	}
}

// Execute executes the request
//
//	@return VoicemailMessage
func (a *VoicemailsAPIService) GetUserVoicemailMessageExecute(r ApiGetUserVoicemailMessageRequest) (*VoicemailMessage, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *VoicemailMessage
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "VoicemailsAPIService.GetUserVoicemailMessage")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/me/voicemails/messages/{message_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"message_id"+"}", url.PathEscape(parameterValueToString(r.messageId, "messageId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["accent_auth_token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Auth-Token"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 503 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetUserVoicemailMessageRecordingRequest struct {
	ctx        context.Context
	ApiService VoicemailsAPI
	messageId  string
	token      *string
	download   *string
}

// The token&#39;s ID
func (r ApiGetUserVoicemailMessageRecordingRequest) Token(token string) ApiGetUserVoicemailMessageRecordingRequest {
	r.token = &token
	return r
}

// Set to 1 to force download by browser
func (r ApiGetUserVoicemailMessageRecordingRequest) Download(download string) ApiGetUserVoicemailMessageRecordingRequest {
	r.download = &download
	return r
}

func (r ApiGetUserVoicemailMessageRecordingRequest) Execute() (*http.Response, error) {
	return r.ApiService.GetUserVoicemailMessageRecordingExecute(r)
}

/*
GetUserVoicemailMessageRecording Get a message's recording

**Required ACL:** `calld.users.me.voicemails.messages.{message_id}.recording.read`

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param messageId The message's ID
	@return ApiGetUserVoicemailMessageRecordingRequest
*/
func (a *VoicemailsAPIService) GetUserVoicemailMessageRecording(ctx context.Context, messageId string) ApiGetUserVoicemailMessageRecordingRequest {
	return ApiGetUserVoicemailMessageRecordingRequest{
		ApiService: a,
		ctx:        ctx,
		messageId:  messageId,
	}
}

// Execute executes the request
func (a *VoicemailsAPIService) GetUserVoicemailMessageRecordingExecute(r ApiGetUserVoicemailMessageRecordingRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodGet
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "VoicemailsAPIService.GetUserVoicemailMessageRecording")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/me/voicemails/messages/{message_id}/recording"
	localVarPath = strings.Replace(localVarPath, "{"+"message_id"+"}", url.PathEscape(parameterValueToString(r.messageId, "messageId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.token != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "token", r.token, "")
	}
	if r.download != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "download", r.download, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"audio/wav"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["accent_auth_token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Auth-Token"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 503 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiGetVoicemailRequest struct {
	ctx         context.Context
	ApiService  VoicemailsAPI
	voicemailId int32
}

func (r ApiGetVoicemailRequest) Execute() (*Voicemail, *http.Response, error) {
	return r.ApiService.GetVoicemailExecute(r)
}

/*
GetVoicemail Get details of a voicemail

**Required ACL:** `calld.voicemails.{voicemail_id}.read`

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param voicemailId The voicemail's ID
	@return ApiGetVoicemailRequest
*/
func (a *VoicemailsAPIService) GetVoicemail(ctx context.Context, voicemailId int32) ApiGetVoicemailRequest {
	return ApiGetVoicemailRequest{
		ApiService:  a,
		ctx:         ctx,
		voicemailId: voicemailId,
	}
}

// Execute executes the request
//
//	@return Voicemail
func (a *VoicemailsAPIService) GetVoicemailExecute(r ApiGetVoicemailRequest) (*Voicemail, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *Voicemail
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "VoicemailsAPIService.GetVoicemail")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/voicemails/{voicemail_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"voicemail_id"+"}", url.PathEscape(parameterValueToString(r.voicemailId, "voicemailId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["accent_auth_token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Auth-Token"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 503 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetVoicemailFolderRequest struct {
	ctx         context.Context
	ApiService  VoicemailsAPI
	voicemailId int32
	folderId    int32
}

func (r ApiGetVoicemailFolderRequest) Execute() (*VoicemailFolder, *http.Response, error) {
	return r.ApiService.GetVoicemailFolderExecute(r)
}

/*
GetVoicemailFolder Get details of a folder

**Required ACL:** `calld.voicemails.{voicemail_id}.folders.{folder_id}.read`

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param voicemailId The voicemail's ID
	@param folderId The folder's ID
	@return ApiGetVoicemailFolderRequest
*/
func (a *VoicemailsAPIService) GetVoicemailFolder(ctx context.Context, voicemailId int32, folderId int32) ApiGetVoicemailFolderRequest {
	return ApiGetVoicemailFolderRequest{
		ApiService:  a,
		ctx:         ctx,
		voicemailId: voicemailId,
		folderId:    folderId,
	}
}

// Execute executes the request
//
//	@return VoicemailFolder
func (a *VoicemailsAPIService) GetVoicemailFolderExecute(r ApiGetVoicemailFolderRequest) (*VoicemailFolder, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *VoicemailFolder
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "VoicemailsAPIService.GetVoicemailFolder")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/voicemails/{voicemail_id}/folders/{folder_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"voicemail_id"+"}", url.PathEscape(parameterValueToString(r.voicemailId, "voicemailId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"folder_id"+"}", url.PathEscape(parameterValueToString(r.folderId, "folderId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["accent_auth_token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Auth-Token"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 503 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetVoicemailGreetingRequest struct {
	ctx         context.Context
	ApiService  VoicemailsAPI
	voicemailId int32
	greeting    string
}

func (r ApiGetVoicemailGreetingRequest) Execute() (*http.Response, error) {
	return r.ApiService.GetVoicemailGreetingExecute(r)
}

/*
GetVoicemailGreeting Get a custom greeting

**Required ACL:** `calld.voicemails.{voicemail_id}.greetings.{greeting}.read`

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param voicemailId The voicemail's ID
	@param greeting The greeting
	@return ApiGetVoicemailGreetingRequest
*/
func (a *VoicemailsAPIService) GetVoicemailGreeting(ctx context.Context, voicemailId int32, greeting string) ApiGetVoicemailGreetingRequest {
	return ApiGetVoicemailGreetingRequest{
		ApiService:  a,
		ctx:         ctx,
		voicemailId: voicemailId,
		greeting:    greeting,
	}
}

// Execute executes the request
func (a *VoicemailsAPIService) GetVoicemailGreetingExecute(r ApiGetVoicemailGreetingRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodGet
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "VoicemailsAPIService.GetVoicemailGreeting")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/voicemails/{voicemail_id}/greetings/{greeting}"
	localVarPath = strings.Replace(localVarPath, "{"+"voicemail_id"+"}", url.PathEscape(parameterValueToString(r.voicemailId, "voicemailId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"greeting"+"}", url.PathEscape(parameterValueToString(r.greeting, "greeting")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"audio/wav"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["accent_auth_token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Auth-Token"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 503 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiGetVoicemailMessageRequest struct {
	ctx         context.Context
	ApiService  VoicemailsAPI
	voicemailId int32
	messageId   string
}

func (r ApiGetVoicemailMessageRequest) Execute() (*VoicemailMessage, *http.Response, error) {
	return r.ApiService.GetVoicemailMessageExecute(r)
}

/*
GetVoicemailMessage Get a message

**Required ACL:** `calld.voicemails.{voicemail_id}.messages.{message_id}.read`

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param voicemailId The voicemail's ID
	@param messageId The message's ID
	@return ApiGetVoicemailMessageRequest
*/
func (a *VoicemailsAPIService) GetVoicemailMessage(ctx context.Context, voicemailId int32, messageId string) ApiGetVoicemailMessageRequest {
	return ApiGetVoicemailMessageRequest{
		ApiService:  a,
		ctx:         ctx,
		voicemailId: voicemailId,
		messageId:   messageId,
	}
}

// Execute executes the request
//
//	@return VoicemailMessage
func (a *VoicemailsAPIService) GetVoicemailMessageExecute(r ApiGetVoicemailMessageRequest) (*VoicemailMessage, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *VoicemailMessage
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "VoicemailsAPIService.GetVoicemailMessage")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/voicemails/{voicemail_id}/messages/{message_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"voicemail_id"+"}", url.PathEscape(parameterValueToString(r.voicemailId, "voicemailId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"message_id"+"}", url.PathEscape(parameterValueToString(r.messageId, "messageId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["accent_auth_token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Auth-Token"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 503 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetVoicemailMessageRecordingRequest struct {
	ctx         context.Context
	ApiService  VoicemailsAPI
	voicemailId int32
	messageId   string
	token       *string
	download    *string
}

// The token&#39;s ID
func (r ApiGetVoicemailMessageRecordingRequest) Token(token string) ApiGetVoicemailMessageRecordingRequest {
	r.token = &token
	return r
}

// Set to 1 to force download by browser
func (r ApiGetVoicemailMessageRecordingRequest) Download(download string) ApiGetVoicemailMessageRecordingRequest {
	r.download = &download
	return r
}

func (r ApiGetVoicemailMessageRecordingRequest) Execute() (*http.Response, error) {
	return r.ApiService.GetVoicemailMessageRecordingExecute(r)
}

/*
GetVoicemailMessageRecording Get a message's recording

**Required ACL:** `calld.voicemails.{voicemail_id}.messages.{message_id}.recording.read`

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param voicemailId The voicemail's ID
	@param messageId The message's ID
	@return ApiGetVoicemailMessageRecordingRequest
*/
func (a *VoicemailsAPIService) GetVoicemailMessageRecording(ctx context.Context, voicemailId int32, messageId string) ApiGetVoicemailMessageRecordingRequest {
	return ApiGetVoicemailMessageRecordingRequest{
		ApiService:  a,
		ctx:         ctx,
		voicemailId: voicemailId,
		messageId:   messageId,
	}
}

// Execute executes the request
func (a *VoicemailsAPIService) GetVoicemailMessageRecordingExecute(r ApiGetVoicemailMessageRecordingRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodGet
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "VoicemailsAPIService.GetVoicemailMessageRecording")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/voicemails/{voicemail_id}/messages/{message_id}/recording"
	localVarPath = strings.Replace(localVarPath, "{"+"voicemail_id"+"}", url.PathEscape(parameterValueToString(r.voicemailId, "voicemailId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"message_id"+"}", url.PathEscape(parameterValueToString(r.messageId, "messageId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.token != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "token", r.token, "")
	}
	if r.download != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "download", r.download, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"audio/wav"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["accent_auth_token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Auth-Token"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 503 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiListUserVoicemailsRequest struct {
	ctx        context.Context
	ApiService VoicemailsAPI
}

func (r ApiListUserVoicemailsRequest) Execute() (*Voicemail, *http.Response, error) {
	return r.ApiService.ListUserVoicemailsExecute(r)
}

/*
ListUserVoicemails Get details of the voicemail of the authenticated user

**Required ACL:** `calld.users.me.voicemails.read`

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiListUserVoicemailsRequest
*/
func (a *VoicemailsAPIService) ListUserVoicemails(ctx context.Context) ApiListUserVoicemailsRequest {
	return ApiListUserVoicemailsRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return Voicemail
func (a *VoicemailsAPIService) ListUserVoicemailsExecute(r ApiListUserVoicemailsRequest) (*Voicemail, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *Voicemail
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "VoicemailsAPIService.ListUserVoicemails")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/me/voicemails"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["accent_auth_token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Auth-Token"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 503 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUpdateUserVoicemailGreetingRequest struct {
	ctx        context.Context
	ApiService VoicemailsAPI
	body       *map[string]interface{}
	greeting   string
}

func (r ApiUpdateUserVoicemailGreetingRequest) Body(body map[string]interface{}) ApiUpdateUserVoicemailGreetingRequest {
	r.body = &body
	return r
}

func (r ApiUpdateUserVoicemailGreetingRequest) Execute() (*http.Response, error) {
	return r.ApiService.UpdateUserVoicemailGreetingExecute(r)
}

/*
UpdateUserVoicemailGreeting Update a custom greeting

**Required ACL:** `calld.users.me.voicemails.greetings.{greeting}.update`

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param greeting The greeting
	@return ApiUpdateUserVoicemailGreetingRequest
*/
func (a *VoicemailsAPIService) UpdateUserVoicemailGreeting(ctx context.Context, greeting string) ApiUpdateUserVoicemailGreetingRequest {
	return ApiUpdateUserVoicemailGreetingRequest{
		ApiService: a,
		ctx:        ctx,
		greeting:   greeting,
	}
}

// Execute executes the request
func (a *VoicemailsAPIService) UpdateUserVoicemailGreetingExecute(r ApiUpdateUserVoicemailGreetingRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodPut
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "VoicemailsAPIService.UpdateUserVoicemailGreeting")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/me/voicemails/greetings/{greeting}"
	localVarPath = strings.Replace(localVarPath, "{"+"greeting"+"}", url.PathEscape(parameterValueToString(r.greeting, "greeting")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return nil, reportError("body is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"audio/wav"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["accent_auth_token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Auth-Token"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 503 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiUpdateUserVoicemailMessageRequest struct {
	ctx        context.Context
	ApiService VoicemailsAPI
	body       *VoicemailMessageUpdate
	messageId  string
}

// Message
func (r ApiUpdateUserVoicemailMessageRequest) Body(body VoicemailMessageUpdate) ApiUpdateUserVoicemailMessageRequest {
	r.body = &body
	return r
}

func (r ApiUpdateUserVoicemailMessageRequest) Execute() (*http.Response, error) {
	return r.ApiService.UpdateUserVoicemailMessageExecute(r)
}

/*
UpdateUserVoicemailMessage Update a message

**Required ACL:** `calld.users.me.voicemails.messages.{message_id}.update`

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param messageId The message's ID
	@return ApiUpdateUserVoicemailMessageRequest
*/
func (a *VoicemailsAPIService) UpdateUserVoicemailMessage(ctx context.Context, messageId string) ApiUpdateUserVoicemailMessageRequest {
	return ApiUpdateUserVoicemailMessageRequest{
		ApiService: a,
		ctx:        ctx,
		messageId:  messageId,
	}
}

// Execute executes the request
func (a *VoicemailsAPIService) UpdateUserVoicemailMessageExecute(r ApiUpdateUserVoicemailMessageRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodPut
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "VoicemailsAPIService.UpdateUserVoicemailMessage")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/me/voicemails/messages/{message_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"message_id"+"}", url.PathEscape(parameterValueToString(r.messageId, "messageId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return nil, reportError("body is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["accent_auth_token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Auth-Token"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 503 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiUpdateVoicemailGreetingRequest struct {
	ctx         context.Context
	ApiService  VoicemailsAPI
	body        *map[string]interface{}
	voicemailId int32
	greeting    string
}

func (r ApiUpdateVoicemailGreetingRequest) Body(body map[string]interface{}) ApiUpdateVoicemailGreetingRequest {
	r.body = &body
	return r
}

func (r ApiUpdateVoicemailGreetingRequest) Execute() (*http.Response, error) {
	return r.ApiService.UpdateVoicemailGreetingExecute(r)
}

/*
UpdateVoicemailGreeting Update a custom greeting

**Required ACL:** `calld.voicemails.{voicemail_id}.greetings.{greeting}.update`

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param voicemailId The voicemail's ID
	@param greeting The greeting
	@return ApiUpdateVoicemailGreetingRequest
*/
func (a *VoicemailsAPIService) UpdateVoicemailGreeting(ctx context.Context, voicemailId int32, greeting string) ApiUpdateVoicemailGreetingRequest {
	return ApiUpdateVoicemailGreetingRequest{
		ApiService:  a,
		ctx:         ctx,
		voicemailId: voicemailId,
		greeting:    greeting,
	}
}

// Execute executes the request
func (a *VoicemailsAPIService) UpdateVoicemailGreetingExecute(r ApiUpdateVoicemailGreetingRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodPut
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "VoicemailsAPIService.UpdateVoicemailGreeting")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/voicemails/{voicemail_id}/greetings/{greeting}"
	localVarPath = strings.Replace(localVarPath, "{"+"voicemail_id"+"}", url.PathEscape(parameterValueToString(r.voicemailId, "voicemailId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"greeting"+"}", url.PathEscape(parameterValueToString(r.greeting, "greeting")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return nil, reportError("body is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"audio/wav"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["accent_auth_token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Auth-Token"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 503 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiUpdateVoicemailMessageRequest struct {
	ctx         context.Context
	ApiService  VoicemailsAPI
	body        *VoicemailMessageUpdate
	voicemailId int32
	messageId   string
}

// Message
func (r ApiUpdateVoicemailMessageRequest) Body(body VoicemailMessageUpdate) ApiUpdateVoicemailMessageRequest {
	r.body = &body
	return r
}

func (r ApiUpdateVoicemailMessageRequest) Execute() (*http.Response, error) {
	return r.ApiService.UpdateVoicemailMessageExecute(r)
}

/*
UpdateVoicemailMessage Update a message

**Required ACL:** `calld.voicemails.{voicemail_id}.messages.{message_id}.update`

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param voicemailId The voicemail's ID
	@param messageId The message's ID
	@return ApiUpdateVoicemailMessageRequest
*/
func (a *VoicemailsAPIService) UpdateVoicemailMessage(ctx context.Context, voicemailId int32, messageId string) ApiUpdateVoicemailMessageRequest {
	return ApiUpdateVoicemailMessageRequest{
		ApiService:  a,
		ctx:         ctx,
		voicemailId: voicemailId,
		messageId:   messageId,
	}
}

// Execute executes the request
func (a *VoicemailsAPIService) UpdateVoicemailMessageExecute(r ApiUpdateVoicemailMessageRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodPut
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "VoicemailsAPIService.UpdateVoicemailMessage")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/voicemails/{voicemail_id}/messages/{message_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"voicemail_id"+"}", url.PathEscape(parameterValueToString(r.voicemailId, "voicemailId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"message_id"+"}", url.PathEscape(parameterValueToString(r.messageId, "messageId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return nil, reportError("body is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["accent_auth_token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Auth-Token"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 503 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

/*
accent-provd

Provisioning application REST API

API version: 0.2
Contact: help@accentvoice.io
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package provd

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"strings"
)

type PluginsAPI interface {

	/*
		DeletePgMgrInstall Delete the Operation In Progress

		**Required ACL:** `provd.operation.delete` This does not cancel the underlying operation; it only deletes the monitor Every monitor that is created should be deleted, else they won't be freed by the process and they will accumulate, taking memory

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param operationId Operation In Progress ID
		@return PluginsAPIDeletePgMgrInstallRequest
	*/
	DeletePgMgrInstall(ctx context.Context, operationId string) PluginsAPIDeletePgMgrInstallRequest

	// DeletePgMgrInstallExecute executes the request
	DeletePgMgrInstallExecute(r PluginsAPIDeletePgMgrInstallRequest) (*http.Response, error)

	/*
		DeletePgMgrInstallMonitor Delete the Operation In Progress

		**Required ACL:** `provd.operation.delete` This does not cancel the underlying operation; it only deletes the monitor Every monitor that is created should be deleted, else they won't be freed by the process and they will accumulate, taking memory

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param pluginId Plugin ID
		@param operationId Operation In Progress ID
		@return PluginsAPIDeletePgMgrInstallMonitorRequest
	*/
	DeletePgMgrInstallMonitor(ctx context.Context, pluginId string, operationId string) PluginsAPIDeletePgMgrInstallMonitorRequest

	// DeletePgMgrInstallMonitorExecute executes the request
	DeletePgMgrInstallMonitorExecute(r PluginsAPIDeletePgMgrInstallMonitorRequest) (*http.Response, error)

	/*
		DeletePgMgrMonitor Delete the Operation In Progress

		**Required ACL:** `provd.operation.delete` This does not cancel the underlying operation; it only deletes the monitor Every monitor that is created should be deleted, else they won't be freed by the process and they will accumulate, taking memory

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param operationId Operation In Progress ID
		@return PluginsAPIDeletePgMgrMonitorRequest
	*/
	DeletePgMgrMonitor(ctx context.Context, operationId string) PluginsAPIDeletePgMgrMonitorRequest

	// DeletePgMgrMonitorExecute executes the request
	DeletePgMgrMonitorExecute(r PluginsAPIDeletePgMgrMonitorRequest) (*http.Response, error)

	/*
		DeletePgMgrPluginUpgradeMonitor Delete the Operation In Progress

		**Required ACL:** `provd.operation.delete` This does not cancel the underlying operation; it only deletes the monitor Every monitor that is created should be deleted, else they won't be freed by the process and they will accumulate, taking memory

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param pluginId Plugin ID
		@param operationId Operation In Progress ID
		@return PluginsAPIDeletePgMgrPluginUpgradeMonitorRequest
	*/
	DeletePgMgrPluginUpgradeMonitor(ctx context.Context, pluginId string, operationId string) PluginsAPIDeletePgMgrPluginUpgradeMonitorRequest

	// DeletePgMgrPluginUpgradeMonitorExecute executes the request
	DeletePgMgrPluginUpgradeMonitorExecute(r PluginsAPIDeletePgMgrPluginUpgradeMonitorRequest) (*http.Response, error)

	/*
		DeletePgMgrUpgradeMonitor Delete the Operation In Progress

		**Required ACL:** `provd.operation.delete` This does not cancel the underlying operation; it only deletes the monitor Every monitor that is created should be deleted, else they won't be freed by the process and they will accumulate, taking memory

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param operationId Operation In Progress ID
		@return PluginsAPIDeletePgMgrUpgradeMonitorRequest
	*/
	DeletePgMgrUpgradeMonitor(ctx context.Context, operationId string) PluginsAPIDeletePgMgrUpgradeMonitorRequest

	// DeletePgMgrUpgradeMonitorExecute executes the request
	DeletePgMgrUpgradeMonitorExecute(r PluginsAPIDeletePgMgrUpgradeMonitorRequest) (*http.Response, error)

	/*
		GetPgMgr Get the Plugin Manager resource

		**Required ACL:** `provd.pg_mgr.read` The plugin manager resource represents the entry point to the accent-provd plugin REST API

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@return PluginsAPIGetPgMgrRequest
	*/
	GetPgMgr(ctx context.Context) PluginsAPIGetPgMgrRequest

	// GetPgMgrExecute executes the request
	//  @return LinksObject
	GetPgMgrExecute(r PluginsAPIGetPgMgrRequest) (*LinksObject, *http.Response, error)

	/*
		GetPgMgrInstall Get the installation service resources

		**Required ACL:** `provd.pg_mgr.install.read`

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@return PluginsAPIGetPgMgrInstallRequest
	*/
	GetPgMgrInstall(ctx context.Context) PluginsAPIGetPgMgrInstallRequest

	// GetPgMgrInstallExecute executes the request
	//  @return LinksObject
	GetPgMgrInstallExecute(r PluginsAPIGetPgMgrInstallRequest) (*LinksObject, *http.Response, error)

	/*
		GetPgMgrInstallStatus Get the status of a plugin installation Operation In Progress

		**Required ACL:** `provd.operation.read`

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param operationId Operation In Progress ID
		@return PluginsAPIGetPgMgrInstallStatusRequest
	*/
	GetPgMgrInstallStatus(ctx context.Context, operationId string) PluginsAPIGetPgMgrInstallStatusRequest

	// GetPgMgrInstallStatusExecute executes the request
	//  @return OperationInProgressObject
	GetPgMgrInstallStatusExecute(r PluginsAPIGetPgMgrInstallStatusRequest) (*OperationInProgressObject, *http.Response, error)

	/*
		GetPgMgrInstallable Get the installable plugins list

		**Required ACL:** `provd.pg_mgr.install.installable.read`

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@return PluginsAPIGetPgMgrInstallableRequest
	*/
	GetPgMgrInstallable(ctx context.Context) PluginsAPIGetPgMgrInstallableRequest

	// GetPgMgrInstallableExecute executes the request
	//  @return PackageList
	GetPgMgrInstallableExecute(r PluginsAPIGetPgMgrInstallableRequest) (*PackageList, *http.Response, error)

	/*
		GetPgMgrInstallableList Get the installable packages list

		**Required ACL:** `provd.pg_mgr.plugins.{plugin_id}.install.installable.read`

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param pluginId Plugin ID
		@return PluginsAPIGetPgMgrInstallableListRequest
	*/
	GetPgMgrInstallableList(ctx context.Context, pluginId string) PluginsAPIGetPgMgrInstallableListRequest

	// GetPgMgrInstallableListExecute executes the request
	//  @return PackageList
	GetPgMgrInstallableListExecute(r PluginsAPIGetPgMgrInstallableListRequest) (*PackageList, *http.Response, error)

	/*
		GetPgMgrInstalled Get the installed plugins list

		**Required ACL:** `provd.pg_mgr.install.installed.read`

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@return PluginsAPIGetPgMgrInstalledRequest
	*/
	GetPgMgrInstalled(ctx context.Context) PluginsAPIGetPgMgrInstalledRequest

	// GetPgMgrInstalledExecute executes the request
	//  @return PackageList
	GetPgMgrInstalledExecute(r PluginsAPIGetPgMgrInstalledRequest) (*PackageList, *http.Response, error)

	/*
		GetPgMgrInstalledList Get the installed packages list

		**Required ACL:** `provd.pg_mgr.plugins.{plugin_id}.install.installed.read`

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param pluginId Plugin ID
		@return PluginsAPIGetPgMgrInstalledListRequest
	*/
	GetPgMgrInstalledList(ctx context.Context, pluginId string) PluginsAPIGetPgMgrInstalledListRequest

	// GetPgMgrInstalledListExecute executes the request
	//  @return PackageList
	GetPgMgrInstalledListExecute(r PluginsAPIGetPgMgrInstalledListRequest) (*PackageList, *http.Response, error)

	/*
		GetPgMgrPlugin Get the resources of a specific plugin

		**Required ACL:** `provd.pg_mgr.plugins.{plugin_id}.read`

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param pluginId Plugin ID
		@return PluginsAPIGetPgMgrPluginRequest
	*/
	GetPgMgrPlugin(ctx context.Context, pluginId string) PluginsAPIGetPgMgrPluginRequest

	// GetPgMgrPluginExecute executes the request
	//  @return LinksObject
	GetPgMgrPluginExecute(r PluginsAPIGetPgMgrPluginRequest) (*LinksObject, *http.Response, error)

	/*
		GetPgMgrPluginInfo Get the information of a plugin

		**Required ACL:** `provd.pg_mgr.plugins.{plugin_id}.info.read`

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param pluginId Plugin ID
		@return PluginsAPIGetPgMgrPluginInfoRequest
	*/
	GetPgMgrPluginInfo(ctx context.Context, pluginId string) PluginsAPIGetPgMgrPluginInfoRequest

	// GetPgMgrPluginInfoExecute executes the request
	//  @return PluginInfo
	GetPgMgrPluginInfoExecute(r PluginsAPIGetPgMgrPluginInfoRequest) (*PluginInfo, *http.Response, error)

	/*
		GetPgMgrPluginInstall Get the package installation service resources

		**Required ACL:** `provd.pg_mgr.plugins.{plugin_id}.install.read`

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param pluginId Plugin ID
		@return PluginsAPIGetPgMgrPluginInstallRequest
	*/
	GetPgMgrPluginInstall(ctx context.Context, pluginId string) PluginsAPIGetPgMgrPluginInstallRequest

	// GetPgMgrPluginInstallExecute executes the request
	//  @return LinksObject
	GetPgMgrPluginInstallExecute(r PluginsAPIGetPgMgrPluginInstallRequest) (*LinksObject, *http.Response, error)

	/*
		GetPgMgrPluginInstallStatus Get the status of a package installation Operation In Progress

		**Required ACL:** `provd.operation.read`

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param pluginId Plugin ID
		@param operationId Operation In Progress ID
		@return PluginsAPIGetPgMgrPluginInstallStatusRequest
	*/
	GetPgMgrPluginInstallStatus(ctx context.Context, pluginId string, operationId string) PluginsAPIGetPgMgrPluginInstallStatusRequest

	// GetPgMgrPluginInstallStatusExecute executes the request
	//  @return OperationInProgressObject
	GetPgMgrPluginInstallStatusExecute(r PluginsAPIGetPgMgrPluginInstallStatusRequest) (*OperationInProgressObject, *http.Response, error)

	/*
		GetPgMgrPluginUpgradeStatus Get the status of a package upgrade Operation In Progress

		**Required ACL:** `provd.operation.read`

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param pluginId Plugin ID
		@param operationId Operation In Progress ID
		@return PluginsAPIGetPgMgrPluginUpgradeStatusRequest
	*/
	GetPgMgrPluginUpgradeStatus(ctx context.Context, pluginId string, operationId string) PluginsAPIGetPgMgrPluginUpgradeStatusRequest

	// GetPgMgrPluginUpgradeStatusExecute executes the request
	//  @return OperationInProgressObject
	GetPgMgrPluginUpgradeStatusExecute(r PluginsAPIGetPgMgrPluginUpgradeStatusRequest) (*OperationInProgressObject, *http.Response, error)

	/*
		GetPgMgrPlugins List the installed plugins

		**Required ACL:** `provd.pg_mgr.plugins.read`

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@return PluginsAPIGetPgMgrPluginsRequest
	*/
	GetPgMgrPlugins(ctx context.Context) PluginsAPIGetPgMgrPluginsRequest

	// GetPgMgrPluginsExecute executes the request
	//  @return PluginsObject
	GetPgMgrPluginsExecute(r PluginsAPIGetPgMgrPluginsRequest) (*PluginsObject, *http.Response, error)

	/*
		GetPgMgrUpdateStatus Get the status of a plugin database update Operation In Progress

		**Required ACL:** `provd.operation.read`

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param operationId Operation In Progress ID
		@return PluginsAPIGetPgMgrUpdateStatusRequest
	*/
	GetPgMgrUpdateStatus(ctx context.Context, operationId string) PluginsAPIGetPgMgrUpdateStatusRequest

	// GetPgMgrUpdateStatusExecute executes the request
	//  @return OperationInProgressObject
	GetPgMgrUpdateStatusExecute(r PluginsAPIGetPgMgrUpdateStatusRequest) (*OperationInProgressObject, *http.Response, error)

	/*
		GetPgMgrUpgradeStatus Get the status of a plugin upgrade Operation In Progress

		**Required ACL:** `provd.operation.read`

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param operationId Operation In Progress ID
		@return PluginsAPIGetPgMgrUpgradeStatusRequest
	*/
	GetPgMgrUpgradeStatus(ctx context.Context, operationId string) PluginsAPIGetPgMgrUpgradeStatusRequest

	// GetPgMgrUpgradeStatusExecute executes the request
	//  @return OperationInProgressObject
	GetPgMgrUpgradeStatusExecute(r PluginsAPIGetPgMgrUpgradeStatusRequest) (*OperationInProgressObject, *http.Response, error)

	/*
		PostPgMgrInstallPlugin Install a plugin

		**Required ACL:** `provd.pg_mgr.install.install.create`

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@return PluginsAPIPostPgMgrInstallPluginRequest
	*/
	PostPgMgrInstallPlugin(ctx context.Context) PluginsAPIPostPgMgrInstallPluginRequest

	// PostPgMgrInstallPluginExecute executes the request
	PostPgMgrInstallPluginExecute(r PluginsAPIPostPgMgrInstallPluginRequest) (*http.Response, error)

	/*
		PostPgMgrPluginInstallPlugin Install a package

		**Required ACL:** `provd.pg_mgr.plugins.{plugin_id}.install.install.create`

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param pluginId Plugin ID
		@return PluginsAPIPostPgMgrPluginInstallPluginRequest
	*/
	PostPgMgrPluginInstallPlugin(ctx context.Context, pluginId string) PluginsAPIPostPgMgrPluginInstallPluginRequest

	// PostPgMgrPluginInstallPluginExecute executes the request
	PostPgMgrPluginInstallPluginExecute(r PluginsAPIPostPgMgrPluginInstallPluginRequest) (*http.Response, error)

	/*
		PostPgMgrPluginUninstallPlugin Uninstall a package

		**Required ACL:** `provd.pg_mgr.plugins.{plugin_id}.install.uninstall.create`

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param pluginId Plugin ID
		@return PluginsAPIPostPgMgrPluginUninstallPluginRequest
	*/
	PostPgMgrPluginUninstallPlugin(ctx context.Context, pluginId string) PluginsAPIPostPgMgrPluginUninstallPluginRequest

	// PostPgMgrPluginUninstallPluginExecute executes the request
	PostPgMgrPluginUninstallPluginExecute(r PluginsAPIPostPgMgrPluginUninstallPluginRequest) (*http.Response, error)

	/*
		PostPgMgrReload Reload a plugin

		**Required ACL:** `provd.pg_mgr.reload.create` This is mostly useful during plugin development, after changing the code of the plugin, instead of restarting the accent-provd application

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@return PluginsAPIPostPgMgrReloadRequest
	*/
	PostPgMgrReload(ctx context.Context) PluginsAPIPostPgMgrReloadRequest

	// PostPgMgrReloadExecute executes the request
	PostPgMgrReloadExecute(r PluginsAPIPostPgMgrReloadRequest) (*http.Response, error)

	/*
		PostPgMgrUninstallPlugin Uninstall a plugin

		**Required ACL:** `provd.pg_mgr.install.uninstall.create`

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@return PluginsAPIPostPgMgrUninstallPluginRequest
	*/
	PostPgMgrUninstallPlugin(ctx context.Context) PluginsAPIPostPgMgrUninstallPluginRequest

	// PostPgMgrUninstallPluginExecute executes the request
	PostPgMgrUninstallPluginExecute(r PluginsAPIPostPgMgrUninstallPluginRequest) (*http.Response, error)

	/*
		PostPgMgrUpdateList Update the List of installable plugins

		**Required ACL:** `provd.pg_mgr.install.update.create`

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@return PluginsAPIPostPgMgrUpdateListRequest
	*/
	PostPgMgrUpdateList(ctx context.Context) PluginsAPIPostPgMgrUpdateListRequest

	// PostPgMgrUpdateListExecute executes the request
	PostPgMgrUpdateListExecute(r PluginsAPIPostPgMgrUpdateListRequest) (*http.Response, error)

	/*
		PostPgMgrUpgradePlugin Upgrade a plugin

		**Required ACL:** `provd.pg_mgr.install.upgrade.create`

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@return PluginsAPIPostPgMgrUpgradePluginRequest
	*/
	PostPgMgrUpgradePlugin(ctx context.Context) PluginsAPIPostPgMgrUpgradePluginRequest

	// PostPgMgrUpgradePluginExecute executes the request
	PostPgMgrUpgradePluginExecute(r PluginsAPIPostPgMgrUpgradePluginRequest) (*http.Response, error)
}

// PluginsAPIService PluginsAPI service
type PluginsAPIService service

type PluginsAPIDeletePgMgrInstallRequest struct {
	ctx         context.Context
	ApiService  PluginsAPI
	operationId string
}

func (r PluginsAPIDeletePgMgrInstallRequest) Execute() (*http.Response, error) {
	return r.ApiService.DeletePgMgrInstallExecute(r)
}

/*
DeletePgMgrInstall Delete the Operation In Progress

**Required ACL:** `provd.operation.delete` This does not cancel the underlying operation; it only deletes the monitor Every monitor that is created should be deleted, else they won't be freed by the process and they will accumulate, taking memory

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param operationId Operation In Progress ID
	@return PluginsAPIDeletePgMgrInstallRequest
*/
func (a *PluginsAPIService) DeletePgMgrInstall(ctx context.Context, operationId string) PluginsAPIDeletePgMgrInstallRequest {
	return PluginsAPIDeletePgMgrInstallRequest{
		ApiService:  a,
		ctx:         ctx,
		operationId: operationId,
	}
}

// Execute executes the request
func (a *PluginsAPIService) DeletePgMgrInstallExecute(r PluginsAPIDeletePgMgrInstallRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodDelete
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PluginsAPIService.DeletePgMgrInstall")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/pg_mgr/install/install/{operation_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"operation_id"+"}", url.PathEscape(parameterValueToString(r.operationId, "operationId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/vnd.accent.provd+json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["accent_auth_token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Auth-Token"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v string
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type PluginsAPIDeletePgMgrInstallMonitorRequest struct {
	ctx         context.Context
	ApiService  PluginsAPI
	pluginId    string
	operationId string
}

func (r PluginsAPIDeletePgMgrInstallMonitorRequest) Execute() (*http.Response, error) {
	return r.ApiService.DeletePgMgrInstallMonitorExecute(r)
}

/*
DeletePgMgrInstallMonitor Delete the Operation In Progress

**Required ACL:** `provd.operation.delete` This does not cancel the underlying operation; it only deletes the monitor Every monitor that is created should be deleted, else they won't be freed by the process and they will accumulate, taking memory

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param pluginId Plugin ID
	@param operationId Operation In Progress ID
	@return PluginsAPIDeletePgMgrInstallMonitorRequest
*/
func (a *PluginsAPIService) DeletePgMgrInstallMonitor(ctx context.Context, pluginId string, operationId string) PluginsAPIDeletePgMgrInstallMonitorRequest {
	return PluginsAPIDeletePgMgrInstallMonitorRequest{
		ApiService:  a,
		ctx:         ctx,
		pluginId:    pluginId,
		operationId: operationId,
	}
}

// Execute executes the request
func (a *PluginsAPIService) DeletePgMgrInstallMonitorExecute(r PluginsAPIDeletePgMgrInstallMonitorRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodDelete
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PluginsAPIService.DeletePgMgrInstallMonitor")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/pg_mgr/plugins/{plugin_id}/install/install/{operation_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"plugin_id"+"}", url.PathEscape(parameterValueToString(r.pluginId, "pluginId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"operation_id"+"}", url.PathEscape(parameterValueToString(r.operationId, "operationId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/vnd.accent.provd+json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["accent_auth_token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Auth-Token"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v string
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type PluginsAPIDeletePgMgrMonitorRequest struct {
	ctx         context.Context
	ApiService  PluginsAPI
	operationId string
}

func (r PluginsAPIDeletePgMgrMonitorRequest) Execute() (*http.Response, error) {
	return r.ApiService.DeletePgMgrMonitorExecute(r)
}

/*
DeletePgMgrMonitor Delete the Operation In Progress

**Required ACL:** `provd.operation.delete` This does not cancel the underlying operation; it only deletes the monitor Every monitor that is created should be deleted, else they won't be freed by the process and they will accumulate, taking memory

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param operationId Operation In Progress ID
	@return PluginsAPIDeletePgMgrMonitorRequest
*/
func (a *PluginsAPIService) DeletePgMgrMonitor(ctx context.Context, operationId string) PluginsAPIDeletePgMgrMonitorRequest {
	return PluginsAPIDeletePgMgrMonitorRequest{
		ApiService:  a,
		ctx:         ctx,
		operationId: operationId,
	}
}

// Execute executes the request
func (a *PluginsAPIService) DeletePgMgrMonitorExecute(r PluginsAPIDeletePgMgrMonitorRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodDelete
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PluginsAPIService.DeletePgMgrMonitor")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/pg_mgr/install/update/{operation_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"operation_id"+"}", url.PathEscape(parameterValueToString(r.operationId, "operationId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/vnd.accent.provd+json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["accent_auth_token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Auth-Token"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v string
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type PluginsAPIDeletePgMgrPluginUpgradeMonitorRequest struct {
	ctx         context.Context
	ApiService  PluginsAPI
	pluginId    string
	operationId string
}

func (r PluginsAPIDeletePgMgrPluginUpgradeMonitorRequest) Execute() (*http.Response, error) {
	return r.ApiService.DeletePgMgrPluginUpgradeMonitorExecute(r)
}

/*
DeletePgMgrPluginUpgradeMonitor Delete the Operation In Progress

**Required ACL:** `provd.operation.delete` This does not cancel the underlying operation; it only deletes the monitor Every monitor that is created should be deleted, else they won't be freed by the process and they will accumulate, taking memory

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param pluginId Plugin ID
	@param operationId Operation In Progress ID
	@return PluginsAPIDeletePgMgrPluginUpgradeMonitorRequest
*/
func (a *PluginsAPIService) DeletePgMgrPluginUpgradeMonitor(ctx context.Context, pluginId string, operationId string) PluginsAPIDeletePgMgrPluginUpgradeMonitorRequest {
	return PluginsAPIDeletePgMgrPluginUpgradeMonitorRequest{
		ApiService:  a,
		ctx:         ctx,
		pluginId:    pluginId,
		operationId: operationId,
	}
}

// Execute executes the request
func (a *PluginsAPIService) DeletePgMgrPluginUpgradeMonitorExecute(r PluginsAPIDeletePgMgrPluginUpgradeMonitorRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodDelete
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PluginsAPIService.DeletePgMgrPluginUpgradeMonitor")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/pg_mgr/plugins/{plugin_id}/install/upgrade/{operation_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"plugin_id"+"}", url.PathEscape(parameterValueToString(r.pluginId, "pluginId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"operation_id"+"}", url.PathEscape(parameterValueToString(r.operationId, "operationId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/vnd.accent.provd+json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["accent_auth_token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Auth-Token"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v string
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type PluginsAPIDeletePgMgrUpgradeMonitorRequest struct {
	ctx         context.Context
	ApiService  PluginsAPI
	operationId string
}

func (r PluginsAPIDeletePgMgrUpgradeMonitorRequest) Execute() (*http.Response, error) {
	return r.ApiService.DeletePgMgrUpgradeMonitorExecute(r)
}

/*
DeletePgMgrUpgradeMonitor Delete the Operation In Progress

**Required ACL:** `provd.operation.delete` This does not cancel the underlying operation; it only deletes the monitor Every monitor that is created should be deleted, else they won't be freed by the process and they will accumulate, taking memory

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param operationId Operation In Progress ID
	@return PluginsAPIDeletePgMgrUpgradeMonitorRequest
*/
func (a *PluginsAPIService) DeletePgMgrUpgradeMonitor(ctx context.Context, operationId string) PluginsAPIDeletePgMgrUpgradeMonitorRequest {
	return PluginsAPIDeletePgMgrUpgradeMonitorRequest{
		ApiService:  a,
		ctx:         ctx,
		operationId: operationId,
	}
}

// Execute executes the request
func (a *PluginsAPIService) DeletePgMgrUpgradeMonitorExecute(r PluginsAPIDeletePgMgrUpgradeMonitorRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodDelete
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PluginsAPIService.DeletePgMgrUpgradeMonitor")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/pg_mgr/install/upgrade/{operation_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"operation_id"+"}", url.PathEscape(parameterValueToString(r.operationId, "operationId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/vnd.accent.provd+json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["accent_auth_token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Auth-Token"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v string
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type PluginsAPIGetPgMgrRequest struct {
	ctx        context.Context
	ApiService PluginsAPI
}

func (r PluginsAPIGetPgMgrRequest) Execute() (*LinksObject, *http.Response, error) {
	return r.ApiService.GetPgMgrExecute(r)
}

/*
GetPgMgr Get the Plugin Manager resource

**Required ACL:** `provd.pg_mgr.read` The plugin manager resource represents the entry point to the accent-provd plugin REST API

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return PluginsAPIGetPgMgrRequest
*/
func (a *PluginsAPIService) GetPgMgr(ctx context.Context) PluginsAPIGetPgMgrRequest {
	return PluginsAPIGetPgMgrRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return LinksObject
func (a *PluginsAPIService) GetPgMgrExecute(r PluginsAPIGetPgMgrRequest) (*LinksObject, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *LinksObject
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PluginsAPIService.GetPgMgr")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/pg_mgr"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/vnd.accent.provd+json", "links"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["accent_auth_token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Auth-Token"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type PluginsAPIGetPgMgrInstallRequest struct {
	ctx        context.Context
	ApiService PluginsAPI
}

func (r PluginsAPIGetPgMgrInstallRequest) Execute() (*LinksObject, *http.Response, error) {
	return r.ApiService.GetPgMgrInstallExecute(r)
}

/*
GetPgMgrInstall Get the installation service resources

**Required ACL:** `provd.pg_mgr.install.read`

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return PluginsAPIGetPgMgrInstallRequest
*/
func (a *PluginsAPIService) GetPgMgrInstall(ctx context.Context) PluginsAPIGetPgMgrInstallRequest {
	return PluginsAPIGetPgMgrInstallRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return LinksObject
func (a *PluginsAPIService) GetPgMgrInstallExecute(r PluginsAPIGetPgMgrInstallRequest) (*LinksObject, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *LinksObject
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PluginsAPIService.GetPgMgrInstall")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/pg_mgr/install"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/vnd.accent.provd+json", "links"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["accent_auth_token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Auth-Token"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type PluginsAPIGetPgMgrInstallStatusRequest struct {
	ctx         context.Context
	ApiService  PluginsAPI
	operationId string
}

func (r PluginsAPIGetPgMgrInstallStatusRequest) Execute() (*OperationInProgressObject, *http.Response, error) {
	return r.ApiService.GetPgMgrInstallStatusExecute(r)
}

/*
GetPgMgrInstallStatus Get the status of a plugin installation Operation In Progress

**Required ACL:** `provd.operation.read`

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param operationId Operation In Progress ID
	@return PluginsAPIGetPgMgrInstallStatusRequest
*/
func (a *PluginsAPIService) GetPgMgrInstallStatus(ctx context.Context, operationId string) PluginsAPIGetPgMgrInstallStatusRequest {
	return PluginsAPIGetPgMgrInstallStatusRequest{
		ApiService:  a,
		ctx:         ctx,
		operationId: operationId,
	}
}

// Execute executes the request
//
//	@return OperationInProgressObject
func (a *PluginsAPIService) GetPgMgrInstallStatusExecute(r PluginsAPIGetPgMgrInstallStatusRequest) (*OperationInProgressObject, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *OperationInProgressObject
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PluginsAPIService.GetPgMgrInstallStatus")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/pg_mgr/install/install/{operation_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"operation_id"+"}", url.PathEscape(parameterValueToString(r.operationId, "operationId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/vnd.accent.provd+json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["accent_auth_token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Auth-Token"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v string
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type PluginsAPIGetPgMgrInstallableRequest struct {
	ctx        context.Context
	ApiService PluginsAPI
}

func (r PluginsAPIGetPgMgrInstallableRequest) Execute() (*PackageList, *http.Response, error) {
	return r.ApiService.GetPgMgrInstallableExecute(r)
}

/*
GetPgMgrInstallable Get the installable plugins list

**Required ACL:** `provd.pg_mgr.install.installable.read`

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return PluginsAPIGetPgMgrInstallableRequest
*/
func (a *PluginsAPIService) GetPgMgrInstallable(ctx context.Context) PluginsAPIGetPgMgrInstallableRequest {
	return PluginsAPIGetPgMgrInstallableRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return PackageList
func (a *PluginsAPIService) GetPgMgrInstallableExecute(r PluginsAPIGetPgMgrInstallableRequest) (*PackageList, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *PackageList
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PluginsAPIService.GetPgMgrInstallable")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/pg_mgr/install/installable"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/vnd.accent.provd+json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["accent_auth_token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Auth-Token"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type PluginsAPIGetPgMgrInstallableListRequest struct {
	ctx        context.Context
	ApiService PluginsAPI
	pluginId   string
}

func (r PluginsAPIGetPgMgrInstallableListRequest) Execute() (*PackageList, *http.Response, error) {
	return r.ApiService.GetPgMgrInstallableListExecute(r)
}

/*
GetPgMgrInstallableList Get the installable packages list

**Required ACL:** `provd.pg_mgr.plugins.{plugin_id}.install.installable.read`

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param pluginId Plugin ID
	@return PluginsAPIGetPgMgrInstallableListRequest
*/
func (a *PluginsAPIService) GetPgMgrInstallableList(ctx context.Context, pluginId string) PluginsAPIGetPgMgrInstallableListRequest {
	return PluginsAPIGetPgMgrInstallableListRequest{
		ApiService: a,
		ctx:        ctx,
		pluginId:   pluginId,
	}
}

// Execute executes the request
//
//	@return PackageList
func (a *PluginsAPIService) GetPgMgrInstallableListExecute(r PluginsAPIGetPgMgrInstallableListRequest) (*PackageList, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *PackageList
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PluginsAPIService.GetPgMgrInstallableList")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/pg_mgr/plugins/{plugin_id}/install/installable"
	localVarPath = strings.Replace(localVarPath, "{"+"plugin_id"+"}", url.PathEscape(parameterValueToString(r.pluginId, "pluginId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/vnd.accent.provd+json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["accent_auth_token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Auth-Token"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v string
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type PluginsAPIGetPgMgrInstalledRequest struct {
	ctx        context.Context
	ApiService PluginsAPI
}

func (r PluginsAPIGetPgMgrInstalledRequest) Execute() (*PackageList, *http.Response, error) {
	return r.ApiService.GetPgMgrInstalledExecute(r)
}

/*
GetPgMgrInstalled Get the installed plugins list

**Required ACL:** `provd.pg_mgr.install.installed.read`

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return PluginsAPIGetPgMgrInstalledRequest
*/
func (a *PluginsAPIService) GetPgMgrInstalled(ctx context.Context) PluginsAPIGetPgMgrInstalledRequest {
	return PluginsAPIGetPgMgrInstalledRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return PackageList
func (a *PluginsAPIService) GetPgMgrInstalledExecute(r PluginsAPIGetPgMgrInstalledRequest) (*PackageList, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *PackageList
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PluginsAPIService.GetPgMgrInstalled")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/pg_mgr/install/installed"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/vnd.accent.provd+json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["accent_auth_token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Auth-Token"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type PluginsAPIGetPgMgrInstalledListRequest struct {
	ctx        context.Context
	ApiService PluginsAPI
	pluginId   string
}

func (r PluginsAPIGetPgMgrInstalledListRequest) Execute() (*PackageList, *http.Response, error) {
	return r.ApiService.GetPgMgrInstalledListExecute(r)
}

/*
GetPgMgrInstalledList Get the installed packages list

**Required ACL:** `provd.pg_mgr.plugins.{plugin_id}.install.installed.read`

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param pluginId Plugin ID
	@return PluginsAPIGetPgMgrInstalledListRequest
*/
func (a *PluginsAPIService) GetPgMgrInstalledList(ctx context.Context, pluginId string) PluginsAPIGetPgMgrInstalledListRequest {
	return PluginsAPIGetPgMgrInstalledListRequest{
		ApiService: a,
		ctx:        ctx,
		pluginId:   pluginId,
	}
}

// Execute executes the request
//
//	@return PackageList
func (a *PluginsAPIService) GetPgMgrInstalledListExecute(r PluginsAPIGetPgMgrInstalledListRequest) (*PackageList, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *PackageList
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PluginsAPIService.GetPgMgrInstalledList")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/pg_mgr/plugins/{plugin_id}/install/installed"
	localVarPath = strings.Replace(localVarPath, "{"+"plugin_id"+"}", url.PathEscape(parameterValueToString(r.pluginId, "pluginId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/vnd.accent.provd+json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["accent_auth_token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Auth-Token"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v string
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type PluginsAPIGetPgMgrPluginRequest struct {
	ctx        context.Context
	ApiService PluginsAPI
	pluginId   string
}

func (r PluginsAPIGetPgMgrPluginRequest) Execute() (*LinksObject, *http.Response, error) {
	return r.ApiService.GetPgMgrPluginExecute(r)
}

/*
GetPgMgrPlugin Get the resources of a specific plugin

**Required ACL:** `provd.pg_mgr.plugins.{plugin_id}.read`

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param pluginId Plugin ID
	@return PluginsAPIGetPgMgrPluginRequest
*/
func (a *PluginsAPIService) GetPgMgrPlugin(ctx context.Context, pluginId string) PluginsAPIGetPgMgrPluginRequest {
	return PluginsAPIGetPgMgrPluginRequest{
		ApiService: a,
		ctx:        ctx,
		pluginId:   pluginId,
	}
}

// Execute executes the request
//
//	@return LinksObject
func (a *PluginsAPIService) GetPgMgrPluginExecute(r PluginsAPIGetPgMgrPluginRequest) (*LinksObject, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *LinksObject
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PluginsAPIService.GetPgMgrPlugin")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/pg_mgr/plugins/{plugin_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"plugin_id"+"}", url.PathEscape(parameterValueToString(r.pluginId, "pluginId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/vnd.accent.provd+json", "links"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["accent_auth_token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Auth-Token"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v string
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type PluginsAPIGetPgMgrPluginInfoRequest struct {
	ctx        context.Context
	ApiService PluginsAPI
	pluginId   string
}

func (r PluginsAPIGetPgMgrPluginInfoRequest) Execute() (*PluginInfo, *http.Response, error) {
	return r.ApiService.GetPgMgrPluginInfoExecute(r)
}

/*
GetPgMgrPluginInfo Get the information of a plugin

**Required ACL:** `provd.pg_mgr.plugins.{plugin_id}.info.read`

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param pluginId Plugin ID
	@return PluginsAPIGetPgMgrPluginInfoRequest
*/
func (a *PluginsAPIService) GetPgMgrPluginInfo(ctx context.Context, pluginId string) PluginsAPIGetPgMgrPluginInfoRequest {
	return PluginsAPIGetPgMgrPluginInfoRequest{
		ApiService: a,
		ctx:        ctx,
		pluginId:   pluginId,
	}
}

// Execute executes the request
//
//	@return PluginInfo
func (a *PluginsAPIService) GetPgMgrPluginInfoExecute(r PluginsAPIGetPgMgrPluginInfoRequest) (*PluginInfo, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *PluginInfo
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PluginsAPIService.GetPgMgrPluginInfo")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/pg_mgr/plugins/{plugin_id}/info"
	localVarPath = strings.Replace(localVarPath, "{"+"plugin_id"+"}", url.PathEscape(parameterValueToString(r.pluginId, "pluginId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/vnd.accent.provd+json", "plugin_info"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["accent_auth_token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Auth-Token"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v string
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type PluginsAPIGetPgMgrPluginInstallRequest struct {
	ctx        context.Context
	ApiService PluginsAPI
	pluginId   string
}

func (r PluginsAPIGetPgMgrPluginInstallRequest) Execute() (*LinksObject, *http.Response, error) {
	return r.ApiService.GetPgMgrPluginInstallExecute(r)
}

/*
GetPgMgrPluginInstall Get the package installation service resources

**Required ACL:** `provd.pg_mgr.plugins.{plugin_id}.install.read`

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param pluginId Plugin ID
	@return PluginsAPIGetPgMgrPluginInstallRequest
*/
func (a *PluginsAPIService) GetPgMgrPluginInstall(ctx context.Context, pluginId string) PluginsAPIGetPgMgrPluginInstallRequest {
	return PluginsAPIGetPgMgrPluginInstallRequest{
		ApiService: a,
		ctx:        ctx,
		pluginId:   pluginId,
	}
}

// Execute executes the request
//
//	@return LinksObject
func (a *PluginsAPIService) GetPgMgrPluginInstallExecute(r PluginsAPIGetPgMgrPluginInstallRequest) (*LinksObject, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *LinksObject
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PluginsAPIService.GetPgMgrPluginInstall")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/pg_mgr/plugins/{plugin_id}/install"
	localVarPath = strings.Replace(localVarPath, "{"+"plugin_id"+"}", url.PathEscape(parameterValueToString(r.pluginId, "pluginId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/vnd.accent.provd+json", "links"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["accent_auth_token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Auth-Token"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v string
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type PluginsAPIGetPgMgrPluginInstallStatusRequest struct {
	ctx         context.Context
	ApiService  PluginsAPI
	pluginId    string
	operationId string
}

func (r PluginsAPIGetPgMgrPluginInstallStatusRequest) Execute() (*OperationInProgressObject, *http.Response, error) {
	return r.ApiService.GetPgMgrPluginInstallStatusExecute(r)
}

/*
GetPgMgrPluginInstallStatus Get the status of a package installation Operation In Progress

**Required ACL:** `provd.operation.read`

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param pluginId Plugin ID
	@param operationId Operation In Progress ID
	@return PluginsAPIGetPgMgrPluginInstallStatusRequest
*/
func (a *PluginsAPIService) GetPgMgrPluginInstallStatus(ctx context.Context, pluginId string, operationId string) PluginsAPIGetPgMgrPluginInstallStatusRequest {
	return PluginsAPIGetPgMgrPluginInstallStatusRequest{
		ApiService:  a,
		ctx:         ctx,
		pluginId:    pluginId,
		operationId: operationId,
	}
}

// Execute executes the request
//
//	@return OperationInProgressObject
func (a *PluginsAPIService) GetPgMgrPluginInstallStatusExecute(r PluginsAPIGetPgMgrPluginInstallStatusRequest) (*OperationInProgressObject, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *OperationInProgressObject
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PluginsAPIService.GetPgMgrPluginInstallStatus")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/pg_mgr/plugins/{plugin_id}/install/install/{operation_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"plugin_id"+"}", url.PathEscape(parameterValueToString(r.pluginId, "pluginId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"operation_id"+"}", url.PathEscape(parameterValueToString(r.operationId, "operationId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/vnd.accent.provd+json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["accent_auth_token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Auth-Token"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v string
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type PluginsAPIGetPgMgrPluginUpgradeStatusRequest struct {
	ctx         context.Context
	ApiService  PluginsAPI
	pluginId    string
	operationId string
}

func (r PluginsAPIGetPgMgrPluginUpgradeStatusRequest) Execute() (*OperationInProgressObject, *http.Response, error) {
	return r.ApiService.GetPgMgrPluginUpgradeStatusExecute(r)
}

/*
GetPgMgrPluginUpgradeStatus Get the status of a package upgrade Operation In Progress

**Required ACL:** `provd.operation.read`

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param pluginId Plugin ID
	@param operationId Operation In Progress ID
	@return PluginsAPIGetPgMgrPluginUpgradeStatusRequest
*/
func (a *PluginsAPIService) GetPgMgrPluginUpgradeStatus(ctx context.Context, pluginId string, operationId string) PluginsAPIGetPgMgrPluginUpgradeStatusRequest {
	return PluginsAPIGetPgMgrPluginUpgradeStatusRequest{
		ApiService:  a,
		ctx:         ctx,
		pluginId:    pluginId,
		operationId: operationId,
	}
}

// Execute executes the request
//
//	@return OperationInProgressObject
func (a *PluginsAPIService) GetPgMgrPluginUpgradeStatusExecute(r PluginsAPIGetPgMgrPluginUpgradeStatusRequest) (*OperationInProgressObject, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *OperationInProgressObject
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PluginsAPIService.GetPgMgrPluginUpgradeStatus")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/pg_mgr/plugins/{plugin_id}/install/upgrade/{operation_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"plugin_id"+"}", url.PathEscape(parameterValueToString(r.pluginId, "pluginId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"operation_id"+"}", url.PathEscape(parameterValueToString(r.operationId, "operationId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/vnd.accent.provd+json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["accent_auth_token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Auth-Token"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v string
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type PluginsAPIGetPgMgrPluginsRequest struct {
	ctx        context.Context
	ApiService PluginsAPI
}

func (r PluginsAPIGetPgMgrPluginsRequest) Execute() (*PluginsObject, *http.Response, error) {
	return r.ApiService.GetPgMgrPluginsExecute(r)
}

/*
GetPgMgrPlugins List the installed plugins

**Required ACL:** `provd.pg_mgr.plugins.read`

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return PluginsAPIGetPgMgrPluginsRequest
*/
func (a *PluginsAPIService) GetPgMgrPlugins(ctx context.Context) PluginsAPIGetPgMgrPluginsRequest {
	return PluginsAPIGetPgMgrPluginsRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return PluginsObject
func (a *PluginsAPIService) GetPgMgrPluginsExecute(r PluginsAPIGetPgMgrPluginsRequest) (*PluginsObject, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *PluginsObject
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PluginsAPIService.GetPgMgrPlugins")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/pg_mgr/plugins"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/vnd.accent.provd+json", "plugins"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["accent_auth_token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Auth-Token"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type PluginsAPIGetPgMgrUpdateStatusRequest struct {
	ctx         context.Context
	ApiService  PluginsAPI
	operationId string
}

func (r PluginsAPIGetPgMgrUpdateStatusRequest) Execute() (*OperationInProgressObject, *http.Response, error) {
	return r.ApiService.GetPgMgrUpdateStatusExecute(r)
}

/*
GetPgMgrUpdateStatus Get the status of a plugin database update Operation In Progress

**Required ACL:** `provd.operation.read`

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param operationId Operation In Progress ID
	@return PluginsAPIGetPgMgrUpdateStatusRequest
*/
func (a *PluginsAPIService) GetPgMgrUpdateStatus(ctx context.Context, operationId string) PluginsAPIGetPgMgrUpdateStatusRequest {
	return PluginsAPIGetPgMgrUpdateStatusRequest{
		ApiService:  a,
		ctx:         ctx,
		operationId: operationId,
	}
}

// Execute executes the request
//
//	@return OperationInProgressObject
func (a *PluginsAPIService) GetPgMgrUpdateStatusExecute(r PluginsAPIGetPgMgrUpdateStatusRequest) (*OperationInProgressObject, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *OperationInProgressObject
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PluginsAPIService.GetPgMgrUpdateStatus")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/pg_mgr/install/update/{operation_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"operation_id"+"}", url.PathEscape(parameterValueToString(r.operationId, "operationId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/vnd.accent.provd+json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["accent_auth_token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Auth-Token"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v string
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type PluginsAPIGetPgMgrUpgradeStatusRequest struct {
	ctx         context.Context
	ApiService  PluginsAPI
	operationId string
}

func (r PluginsAPIGetPgMgrUpgradeStatusRequest) Execute() (*OperationInProgressObject, *http.Response, error) {
	return r.ApiService.GetPgMgrUpgradeStatusExecute(r)
}

/*
GetPgMgrUpgradeStatus Get the status of a plugin upgrade Operation In Progress

**Required ACL:** `provd.operation.read`

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param operationId Operation In Progress ID
	@return PluginsAPIGetPgMgrUpgradeStatusRequest
*/
func (a *PluginsAPIService) GetPgMgrUpgradeStatus(ctx context.Context, operationId string) PluginsAPIGetPgMgrUpgradeStatusRequest {
	return PluginsAPIGetPgMgrUpgradeStatusRequest{
		ApiService:  a,
		ctx:         ctx,
		operationId: operationId,
	}
}

// Execute executes the request
//
//	@return OperationInProgressObject
func (a *PluginsAPIService) GetPgMgrUpgradeStatusExecute(r PluginsAPIGetPgMgrUpgradeStatusRequest) (*OperationInProgressObject, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *OperationInProgressObject
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PluginsAPIService.GetPgMgrUpgradeStatus")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/pg_mgr/install/upgrade/{operation_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"operation_id"+"}", url.PathEscape(parameterValueToString(r.operationId, "operationId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/vnd.accent.provd+json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["accent_auth_token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Auth-Token"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v string
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type PluginsAPIPostPgMgrInstallPluginRequest struct {
	ctx        context.Context
	ApiService PluginsAPI
	body       *IdObject
}

// Package ID body definition
func (r PluginsAPIPostPgMgrInstallPluginRequest) Body(body IdObject) PluginsAPIPostPgMgrInstallPluginRequest {
	r.body = &body
	return r
}

func (r PluginsAPIPostPgMgrInstallPluginRequest) Execute() (*http.Response, error) {
	return r.ApiService.PostPgMgrInstallPluginExecute(r)
}

/*
PostPgMgrInstallPlugin Install a plugin

**Required ACL:** `provd.pg_mgr.install.install.create`

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return PluginsAPIPostPgMgrInstallPluginRequest
*/
func (a *PluginsAPIService) PostPgMgrInstallPlugin(ctx context.Context) PluginsAPIPostPgMgrInstallPluginRequest {
	return PluginsAPIPostPgMgrInstallPluginRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
func (a *PluginsAPIService) PostPgMgrInstallPluginExecute(r PluginsAPIPostPgMgrInstallPluginRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodPost
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PluginsAPIService.PostPgMgrInstallPlugin")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/pg_mgr/install/install"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/vnd.accent.provd+json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/vnd.accent.provd+json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["accent_auth_token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Auth-Token"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v string
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 415 {
			var v string
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type PluginsAPIPostPgMgrPluginInstallPluginRequest struct {
	ctx        context.Context
	ApiService PluginsAPI
	pluginId   string
	body       *IdObject
}

// Package ID body definition
func (r PluginsAPIPostPgMgrPluginInstallPluginRequest) Body(body IdObject) PluginsAPIPostPgMgrPluginInstallPluginRequest {
	r.body = &body
	return r
}

func (r PluginsAPIPostPgMgrPluginInstallPluginRequest) Execute() (*http.Response, error) {
	return r.ApiService.PostPgMgrPluginInstallPluginExecute(r)
}

/*
PostPgMgrPluginInstallPlugin Install a package

**Required ACL:** `provd.pg_mgr.plugins.{plugin_id}.install.install.create`

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param pluginId Plugin ID
	@return PluginsAPIPostPgMgrPluginInstallPluginRequest
*/
func (a *PluginsAPIService) PostPgMgrPluginInstallPlugin(ctx context.Context, pluginId string) PluginsAPIPostPgMgrPluginInstallPluginRequest {
	return PluginsAPIPostPgMgrPluginInstallPluginRequest{
		ApiService: a,
		ctx:        ctx,
		pluginId:   pluginId,
	}
}

// Execute executes the request
func (a *PluginsAPIService) PostPgMgrPluginInstallPluginExecute(r PluginsAPIPostPgMgrPluginInstallPluginRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodPost
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PluginsAPIService.PostPgMgrPluginInstallPlugin")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/pg_mgr/plugins/{plugin_id}/install/install"
	localVarPath = strings.Replace(localVarPath, "{"+"plugin_id"+"}", url.PathEscape(parameterValueToString(r.pluginId, "pluginId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/vnd.accent.provd+json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/vnd.accent.provd+json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["accent_auth_token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Auth-Token"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v string
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v string
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 415 {
			var v string
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type PluginsAPIPostPgMgrPluginUninstallPluginRequest struct {
	ctx        context.Context
	ApiService PluginsAPI
	pluginId   string
	body       *IdObject
}

// Package ID body definition
func (r PluginsAPIPostPgMgrPluginUninstallPluginRequest) Body(body IdObject) PluginsAPIPostPgMgrPluginUninstallPluginRequest {
	r.body = &body
	return r
}

func (r PluginsAPIPostPgMgrPluginUninstallPluginRequest) Execute() (*http.Response, error) {
	return r.ApiService.PostPgMgrPluginUninstallPluginExecute(r)
}

/*
PostPgMgrPluginUninstallPlugin Uninstall a package

**Required ACL:** `provd.pg_mgr.plugins.{plugin_id}.install.uninstall.create`

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param pluginId Plugin ID
	@return PluginsAPIPostPgMgrPluginUninstallPluginRequest
*/
func (a *PluginsAPIService) PostPgMgrPluginUninstallPlugin(ctx context.Context, pluginId string) PluginsAPIPostPgMgrPluginUninstallPluginRequest {
	return PluginsAPIPostPgMgrPluginUninstallPluginRequest{
		ApiService: a,
		ctx:        ctx,
		pluginId:   pluginId,
	}
}

// Execute executes the request
func (a *PluginsAPIService) PostPgMgrPluginUninstallPluginExecute(r PluginsAPIPostPgMgrPluginUninstallPluginRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodPost
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PluginsAPIService.PostPgMgrPluginUninstallPlugin")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/pg_mgr/plugins/{plugin_id}/install/uninstall"
	localVarPath = strings.Replace(localVarPath, "{"+"plugin_id"+"}", url.PathEscape(parameterValueToString(r.pluginId, "pluginId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/vnd.accent.provd+json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/vnd.accent.provd+json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["accent_auth_token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Auth-Token"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v string
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v string
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 415 {
			var v string
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type PluginsAPIPostPgMgrReloadRequest struct {
	ctx        context.Context
	ApiService PluginsAPI
	body       *IdObject
}

// Plugin ID body definition
func (r PluginsAPIPostPgMgrReloadRequest) Body(body IdObject) PluginsAPIPostPgMgrReloadRequest {
	r.body = &body
	return r
}

func (r PluginsAPIPostPgMgrReloadRequest) Execute() (*http.Response, error) {
	return r.ApiService.PostPgMgrReloadExecute(r)
}

/*
PostPgMgrReload Reload a plugin

**Required ACL:** `provd.pg_mgr.reload.create` This is mostly useful during plugin development, after changing the code of the plugin, instead of restarting the accent-provd application

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return PluginsAPIPostPgMgrReloadRequest
*/
func (a *PluginsAPIService) PostPgMgrReload(ctx context.Context) PluginsAPIPostPgMgrReloadRequest {
	return PluginsAPIPostPgMgrReloadRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
func (a *PluginsAPIService) PostPgMgrReloadExecute(r PluginsAPIPostPgMgrReloadRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodPost
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PluginsAPIService.PostPgMgrReload")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/pg_mgr/reload"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/vnd.accent.provd+json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["accent_auth_token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Auth-Token"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type PluginsAPIPostPgMgrUninstallPluginRequest struct {
	ctx        context.Context
	ApiService PluginsAPI
	body       *IdObject
}

// Package ID body definition
func (r PluginsAPIPostPgMgrUninstallPluginRequest) Body(body IdObject) PluginsAPIPostPgMgrUninstallPluginRequest {
	r.body = &body
	return r
}

func (r PluginsAPIPostPgMgrUninstallPluginRequest) Execute() (*http.Response, error) {
	return r.ApiService.PostPgMgrUninstallPluginExecute(r)
}

/*
PostPgMgrUninstallPlugin Uninstall a plugin

**Required ACL:** `provd.pg_mgr.install.uninstall.create`

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return PluginsAPIPostPgMgrUninstallPluginRequest
*/
func (a *PluginsAPIService) PostPgMgrUninstallPlugin(ctx context.Context) PluginsAPIPostPgMgrUninstallPluginRequest {
	return PluginsAPIPostPgMgrUninstallPluginRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
func (a *PluginsAPIService) PostPgMgrUninstallPluginExecute(r PluginsAPIPostPgMgrUninstallPluginRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodPost
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PluginsAPIService.PostPgMgrUninstallPlugin")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/pg_mgr/install/uninstall"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/vnd.accent.provd+json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/vnd.accent.provd+json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["accent_auth_token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Auth-Token"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v string
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 415 {
			var v string
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type PluginsAPIPostPgMgrUpdateListRequest struct {
	ctx        context.Context
	ApiService PluginsAPI
	body       *map[string]interface{}
}

// Empty object body
func (r PluginsAPIPostPgMgrUpdateListRequest) Body(body map[string]interface{}) PluginsAPIPostPgMgrUpdateListRequest {
	r.body = &body
	return r
}

func (r PluginsAPIPostPgMgrUpdateListRequest) Execute() (*http.Response, error) {
	return r.ApiService.PostPgMgrUpdateListExecute(r)
}

/*
PostPgMgrUpdateList Update the List of installable plugins

**Required ACL:** `provd.pg_mgr.install.update.create`

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return PluginsAPIPostPgMgrUpdateListRequest
*/
func (a *PluginsAPIService) PostPgMgrUpdateList(ctx context.Context) PluginsAPIPostPgMgrUpdateListRequest {
	return PluginsAPIPostPgMgrUpdateListRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
func (a *PluginsAPIService) PostPgMgrUpdateListExecute(r PluginsAPIPostPgMgrUpdateListRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodPost
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PluginsAPIService.PostPgMgrUpdateList")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/pg_mgr/install/update"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/vnd.accent.provd+json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/vnd.accent.provd+json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["accent_auth_token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Auth-Token"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v string
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type PluginsAPIPostPgMgrUpgradePluginRequest struct {
	ctx        context.Context
	ApiService PluginsAPI
	body       *IdObject
}

// Package ID body definition
func (r PluginsAPIPostPgMgrUpgradePluginRequest) Body(body IdObject) PluginsAPIPostPgMgrUpgradePluginRequest {
	r.body = &body
	return r
}

func (r PluginsAPIPostPgMgrUpgradePluginRequest) Execute() (*http.Response, error) {
	return r.ApiService.PostPgMgrUpgradePluginExecute(r)
}

/*
PostPgMgrUpgradePlugin Upgrade a plugin

**Required ACL:** `provd.pg_mgr.install.upgrade.create`

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return PluginsAPIPostPgMgrUpgradePluginRequest
*/
func (a *PluginsAPIService) PostPgMgrUpgradePlugin(ctx context.Context) PluginsAPIPostPgMgrUpgradePluginRequest {
	return PluginsAPIPostPgMgrUpgradePluginRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
func (a *PluginsAPIService) PostPgMgrUpgradePluginExecute(r PluginsAPIPostPgMgrUpgradePluginRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodPost
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PluginsAPIService.PostPgMgrUpgradePlugin")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/pg_mgr/install/upgrade"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/vnd.accent.provd+json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/vnd.accent.provd+json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["accent_auth_token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Auth-Token"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v string
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 415 {
			var v string
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

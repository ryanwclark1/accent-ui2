/*
accent-agentd

Agent service

API version: 1.0
Contact: help@accentvoice.io
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package agentd

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"strings"
)

type AgentAPI interface {

	/*
		AddAgentById Add agent to a queue.

		**Required ACL:** `agentd.agents.by-id.{agent_id}.add.create`

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param agentId Agent's ID
		@return AgentAPIAddAgentByIdRequest
	*/
	AddAgentById(ctx context.Context, agentId int32) AgentAPIAddAgentByIdRequest

	// AddAgentByIdExecute executes the request
	AddAgentByIdExecute(r AgentAPIAddAgentByIdRequest) (*http.Response, error)

	/*
		GetAgentById Get agent status.

		**Required ACL:** `agentd.agents.by-id.{agent_id}.read`

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param agentId Agent's ID
		@return AgentAPIGetAgentByIdRequest
	*/
	GetAgentById(ctx context.Context, agentId int32) AgentAPIGetAgentByIdRequest

	// GetAgentByIdExecute executes the request
	//  @return AgentStatus
	GetAgentByIdExecute(r AgentAPIGetAgentByIdRequest) (*AgentStatus, *http.Response, error)

	/*
		GetAgentByNumber Get agent status.

		**Required ACL:** `agentd.agents.by-number.{agent_number}.read`

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param agentNumber Agent's number
		@return AgentAPIGetAgentByNumberRequest
	*/
	GetAgentByNumber(ctx context.Context, agentNumber string) AgentAPIGetAgentByNumberRequest

	// GetAgentByNumberExecute executes the request
	//  @return AgentStatus
	GetAgentByNumberExecute(r AgentAPIGetAgentByNumberRequest) (*AgentStatus, *http.Response, error)

	/*
		GetUserAgent Get agent status of the user holding the authentication token.

		**Required ACL:** `agentd.users.me.agents.read`

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@return AgentAPIGetUserAgentRequest
	*/
	GetUserAgent(ctx context.Context) AgentAPIGetUserAgentRequest

	// GetUserAgentExecute executes the request
	//  @return AgentStatus
	GetUserAgentExecute(r AgentAPIGetUserAgentRequest) (*AgentStatus, *http.Response, error)

	/*
		LoginAgentById Log an agent.

		**Required ACL:** `agentd.agents.by-id.{agent_id}.login.create`

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param agentId Agent's ID
		@return AgentAPILoginAgentByIdRequest
	*/
	LoginAgentById(ctx context.Context, agentId int32) AgentAPILoginAgentByIdRequest

	// LoginAgentByIdExecute executes the request
	LoginAgentByIdExecute(r AgentAPILoginAgentByIdRequest) (*http.Response, error)

	/*
		LoginAgentByNumber Log an agent.

		**Required ACL:** `agentd.agents.by-number.{agent_number}.login.create`

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param agentNumber Agent's number
		@return AgentAPILoginAgentByNumberRequest
	*/
	LoginAgentByNumber(ctx context.Context, agentNumber string) AgentAPILoginAgentByNumberRequest

	// LoginAgentByNumberExecute executes the request
	LoginAgentByNumberExecute(r AgentAPILoginAgentByNumberRequest) (*http.Response, error)

	/*
		LoginUserAgent Log the agent of the user holding the authentication token

		**Required ACL:** `agentd.users.me.agents.login.create`

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@return AgentAPILoginUserAgentRequest
	*/
	LoginUserAgent(ctx context.Context) AgentAPILoginUserAgentRequest

	// LoginUserAgentExecute executes the request
	LoginUserAgentExecute(r AgentAPILoginUserAgentRequest) (*http.Response, error)

	/*
		LogoffAgentById Logoff an agent.

		**Required ACL:** `agentd.agents.by-id.{agent_id}.logoff.create`

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param agentId Agent's ID
		@return AgentAPILogoffAgentByIdRequest
	*/
	LogoffAgentById(ctx context.Context, agentId int32) AgentAPILogoffAgentByIdRequest

	// LogoffAgentByIdExecute executes the request
	LogoffAgentByIdExecute(r AgentAPILogoffAgentByIdRequest) (*http.Response, error)

	/*
		LogoffAgentByNumber Logoff an agent.

		**Required ACL:** `agentd.agents.by-number.{agent_number}.logoff.create`

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param agentNumber Agent's number
		@return AgentAPILogoffAgentByNumberRequest
	*/
	LogoffAgentByNumber(ctx context.Context, agentNumber string) AgentAPILogoffAgentByNumberRequest

	// LogoffAgentByNumberExecute executes the request
	LogoffAgentByNumberExecute(r AgentAPILogoffAgentByNumberRequest) (*http.Response, error)

	/*
		LogoffUserAgent Logoff the agent of the user holding the authentication token

		**Required ACL:** `agentd.users.me.agents.logoff.create`

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@return AgentAPILogoffUserAgentRequest
	*/
	LogoffUserAgent(ctx context.Context) AgentAPILogoffUserAgentRequest

	// LogoffUserAgentExecute executes the request
	LogoffUserAgentExecute(r AgentAPILogoffUserAgentRequest) (*http.Response, error)

	/*
		PauseAgentByNumber Pause an agent.

		**Required ACL:** `agentd.agents.by-number.{agent_number}.pause.create`

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param agentNumber Agent's number
		@return AgentAPIPauseAgentByNumberRequest
	*/
	PauseAgentByNumber(ctx context.Context, agentNumber string) AgentAPIPauseAgentByNumberRequest

	// PauseAgentByNumberExecute executes the request
	PauseAgentByNumberExecute(r AgentAPIPauseAgentByNumberRequest) (*http.Response, error)

	/*
		PauseUserAgent Pause the agent of the user holding the authentication token

		**Required ACL:** `agentd.users.me.agents.pause.create`

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@return AgentAPIPauseUserAgentRequest
	*/
	PauseUserAgent(ctx context.Context) AgentAPIPauseUserAgentRequest

	// PauseUserAgentExecute executes the request
	PauseUserAgentExecute(r AgentAPIPauseUserAgentRequest) (*http.Response, error)

	/*
		RemoveAgentById Remove agent from a queue.

		**Required ACL:** `agentd.agents.by-id.{agent_id}.remove.create`

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param agentId Agent's ID
		@return AgentAPIRemoveAgentByIdRequest
	*/
	RemoveAgentById(ctx context.Context, agentId int32) AgentAPIRemoveAgentByIdRequest

	// RemoveAgentByIdExecute executes the request
	RemoveAgentByIdExecute(r AgentAPIRemoveAgentByIdRequest) (*http.Response, error)

	/*
		UnpauseAgentByNumber Unpause an agent.

		**Required ACL:** `agentd.agents.by-number.{agent_number}.unpause.create`

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param agentNumber Agent's number
		@return AgentAPIUnpauseAgentByNumberRequest
	*/
	UnpauseAgentByNumber(ctx context.Context, agentNumber string) AgentAPIUnpauseAgentByNumberRequest

	// UnpauseAgentByNumberExecute executes the request
	UnpauseAgentByNumberExecute(r AgentAPIUnpauseAgentByNumberRequest) (*http.Response, error)

	/*
		UnpauseUserAgent Unpause the agent of the user holding the authentication token

		**Required ACL:** `agentd.users.me.agents.unpause.create`

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@return AgentAPIUnpauseUserAgentRequest
	*/
	UnpauseUserAgent(ctx context.Context) AgentAPIUnpauseUserAgentRequest

	// UnpauseUserAgentExecute executes the request
	UnpauseUserAgentExecute(r AgentAPIUnpauseUserAgentRequest) (*http.Response, error)
}

// AgentAPIService AgentAPI service
type AgentAPIService service

type AgentAPIAddAgentByIdRequest struct {
	ctx          context.Context
	ApiService   AgentAPI
	body         *Queue
	agentId      int32
	accentTenant *string
}

// The queue to add the agent to
func (r AgentAPIAddAgentByIdRequest) Body(body Queue) AgentAPIAddAgentByIdRequest {
	r.body = &body
	return r
}

// The tenant&#39;s UUID, defining the ownership of a given resource.
func (r AgentAPIAddAgentByIdRequest) AccentTenant(accentTenant string) AgentAPIAddAgentByIdRequest {
	r.accentTenant = &accentTenant
	return r
}

func (r AgentAPIAddAgentByIdRequest) Execute() (*http.Response, error) {
	return r.ApiService.AddAgentByIdExecute(r)
}

/*
AddAgentById Add agent to a queue.

**Required ACL:** `agentd.agents.by-id.{agent_id}.add.create`

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param agentId Agent's ID
	@return AgentAPIAddAgentByIdRequest
*/
func (a *AgentAPIService) AddAgentById(ctx context.Context, agentId int32) AgentAPIAddAgentByIdRequest {
	return AgentAPIAddAgentByIdRequest{
		ApiService: a,
		ctx:        ctx,
		agentId:    agentId,
	}
}

// Execute executes the request
func (a *AgentAPIService) AddAgentByIdExecute(r AgentAPIAddAgentByIdRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodPost
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AgentAPIService.AddAgentById")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/agents/by-id/{agent_id}/add"
	localVarPath = strings.Replace(localVarPath, "{"+"agent_id"+"}", url.PathEscape(parameterValueToString(r.agentId, "agentId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return nil, reportError("body is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.accentTenant != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accent-Tenant", r.accentTenant, "")
	}
	// body params
	localVarPostBody = r.body
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["accent_auth_token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Auth-Token"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 409 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type AgentAPIGetAgentByIdRequest struct {
	ctx          context.Context
	ApiService   AgentAPI
	agentId      int32
	accentTenant *string
}

// The tenant&#39;s UUID, defining the ownership of a given resource.
func (r AgentAPIGetAgentByIdRequest) AccentTenant(accentTenant string) AgentAPIGetAgentByIdRequest {
	r.accentTenant = &accentTenant
	return r
}

func (r AgentAPIGetAgentByIdRequest) Execute() (*AgentStatus, *http.Response, error) {
	return r.ApiService.GetAgentByIdExecute(r)
}

/*
GetAgentById Get agent status.

**Required ACL:** `agentd.agents.by-id.{agent_id}.read`

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param agentId Agent's ID
	@return AgentAPIGetAgentByIdRequest
*/
func (a *AgentAPIService) GetAgentById(ctx context.Context, agentId int32) AgentAPIGetAgentByIdRequest {
	return AgentAPIGetAgentByIdRequest{
		ApiService: a,
		ctx:        ctx,
		agentId:    agentId,
	}
}

// Execute executes the request
//
//	@return AgentStatus
func (a *AgentAPIService) GetAgentByIdExecute(r AgentAPIGetAgentByIdRequest) (*AgentStatus, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *AgentStatus
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AgentAPIService.GetAgentById")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/agents/by-id/{agent_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"agent_id"+"}", url.PathEscape(parameterValueToString(r.agentId, "agentId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.accentTenant != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accent-Tenant", r.accentTenant, "")
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["accent_auth_token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Auth-Token"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type AgentAPIGetAgentByNumberRequest struct {
	ctx          context.Context
	ApiService   AgentAPI
	agentNumber  string
	accentTenant *string
}

// The tenant&#39;s UUID, defining the ownership of a given resource.
func (r AgentAPIGetAgentByNumberRequest) AccentTenant(accentTenant string) AgentAPIGetAgentByNumberRequest {
	r.accentTenant = &accentTenant
	return r
}

func (r AgentAPIGetAgentByNumberRequest) Execute() (*AgentStatus, *http.Response, error) {
	return r.ApiService.GetAgentByNumberExecute(r)
}

/*
GetAgentByNumber Get agent status.

**Required ACL:** `agentd.agents.by-number.{agent_number}.read`

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param agentNumber Agent's number
	@return AgentAPIGetAgentByNumberRequest
*/
func (a *AgentAPIService) GetAgentByNumber(ctx context.Context, agentNumber string) AgentAPIGetAgentByNumberRequest {
	return AgentAPIGetAgentByNumberRequest{
		ApiService:  a,
		ctx:         ctx,
		agentNumber: agentNumber,
	}
}

// Execute executes the request
//
//	@return AgentStatus
func (a *AgentAPIService) GetAgentByNumberExecute(r AgentAPIGetAgentByNumberRequest) (*AgentStatus, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *AgentStatus
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AgentAPIService.GetAgentByNumber")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/agents/by-number/{agent_number}"
	localVarPath = strings.Replace(localVarPath, "{"+"agent_number"+"}", url.PathEscape(parameterValueToString(r.agentNumber, "agentNumber")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.accentTenant != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accent-Tenant", r.accentTenant, "")
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["accent_auth_token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Auth-Token"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type AgentAPIGetUserAgentRequest struct {
	ctx          context.Context
	ApiService   AgentAPI
	accentTenant *string
}

// The tenant&#39;s UUID, defining the ownership of a given resource.
func (r AgentAPIGetUserAgentRequest) AccentTenant(accentTenant string) AgentAPIGetUserAgentRequest {
	r.accentTenant = &accentTenant
	return r
}

func (r AgentAPIGetUserAgentRequest) Execute() (*AgentStatus, *http.Response, error) {
	return r.ApiService.GetUserAgentExecute(r)
}

/*
GetUserAgent Get agent status of the user holding the authentication token.

**Required ACL:** `agentd.users.me.agents.read`

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return AgentAPIGetUserAgentRequest
*/
func (a *AgentAPIService) GetUserAgent(ctx context.Context) AgentAPIGetUserAgentRequest {
	return AgentAPIGetUserAgentRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return AgentStatus
func (a *AgentAPIService) GetUserAgentExecute(r AgentAPIGetUserAgentRequest) (*AgentStatus, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *AgentStatus
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AgentAPIService.GetUserAgent")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/me/agents"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.accentTenant != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accent-Tenant", r.accentTenant, "")
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["accent_auth_token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Auth-Token"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type AgentAPILoginAgentByIdRequest struct {
	ctx          context.Context
	ApiService   AgentAPI
	body         *LoginInfo
	agentId      int32
	accentTenant *string
}

// The extension and context on which to log the agent
func (r AgentAPILoginAgentByIdRequest) Body(body LoginInfo) AgentAPILoginAgentByIdRequest {
	r.body = &body
	return r
}

// The tenant&#39;s UUID, defining the ownership of a given resource.
func (r AgentAPILoginAgentByIdRequest) AccentTenant(accentTenant string) AgentAPILoginAgentByIdRequest {
	r.accentTenant = &accentTenant
	return r
}

func (r AgentAPILoginAgentByIdRequest) Execute() (*http.Response, error) {
	return r.ApiService.LoginAgentByIdExecute(r)
}

/*
LoginAgentById Log an agent.

**Required ACL:** `agentd.agents.by-id.{agent_id}.login.create`

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param agentId Agent's ID
	@return AgentAPILoginAgentByIdRequest
*/
func (a *AgentAPIService) LoginAgentById(ctx context.Context, agentId int32) AgentAPILoginAgentByIdRequest {
	return AgentAPILoginAgentByIdRequest{
		ApiService: a,
		ctx:        ctx,
		agentId:    agentId,
	}
}

// Execute executes the request
func (a *AgentAPIService) LoginAgentByIdExecute(r AgentAPILoginAgentByIdRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodPost
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AgentAPIService.LoginAgentById")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/agents/by-id/{agent_id}/login"
	localVarPath = strings.Replace(localVarPath, "{"+"agent_id"+"}", url.PathEscape(parameterValueToString(r.agentId, "agentId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return nil, reportError("body is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.accentTenant != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accent-Tenant", r.accentTenant, "")
	}
	// body params
	localVarPostBody = r.body
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["accent_auth_token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Auth-Token"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 409 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type AgentAPILoginAgentByNumberRequest struct {
	ctx          context.Context
	ApiService   AgentAPI
	body         *LoginInfo
	agentNumber  string
	accentTenant *string
}

// The extension and context on which to log the agent
func (r AgentAPILoginAgentByNumberRequest) Body(body LoginInfo) AgentAPILoginAgentByNumberRequest {
	r.body = &body
	return r
}

// The tenant&#39;s UUID, defining the ownership of a given resource.
func (r AgentAPILoginAgentByNumberRequest) AccentTenant(accentTenant string) AgentAPILoginAgentByNumberRequest {
	r.accentTenant = &accentTenant
	return r
}

func (r AgentAPILoginAgentByNumberRequest) Execute() (*http.Response, error) {
	return r.ApiService.LoginAgentByNumberExecute(r)
}

/*
LoginAgentByNumber Log an agent.

**Required ACL:** `agentd.agents.by-number.{agent_number}.login.create`

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param agentNumber Agent's number
	@return AgentAPILoginAgentByNumberRequest
*/
func (a *AgentAPIService) LoginAgentByNumber(ctx context.Context, agentNumber string) AgentAPILoginAgentByNumberRequest {
	return AgentAPILoginAgentByNumberRequest{
		ApiService:  a,
		ctx:         ctx,
		agentNumber: agentNumber,
	}
}

// Execute executes the request
func (a *AgentAPIService) LoginAgentByNumberExecute(r AgentAPILoginAgentByNumberRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodPost
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AgentAPIService.LoginAgentByNumber")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/agents/by-number/{agent_number}/login"
	localVarPath = strings.Replace(localVarPath, "{"+"agent_number"+"}", url.PathEscape(parameterValueToString(r.agentNumber, "agentNumber")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return nil, reportError("body is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.accentTenant != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accent-Tenant", r.accentTenant, "")
	}
	// body params
	localVarPostBody = r.body
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["accent_auth_token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Auth-Token"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 409 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type AgentAPILoginUserAgentRequest struct {
	ctx          context.Context
	ApiService   AgentAPI
	body         *UserAgentLoginInfo
	accentTenant *string
}

// The line on which to log the agent
func (r AgentAPILoginUserAgentRequest) Body(body UserAgentLoginInfo) AgentAPILoginUserAgentRequest {
	r.body = &body
	return r
}

// The tenant&#39;s UUID, defining the ownership of a given resource.
func (r AgentAPILoginUserAgentRequest) AccentTenant(accentTenant string) AgentAPILoginUserAgentRequest {
	r.accentTenant = &accentTenant
	return r
}

func (r AgentAPILoginUserAgentRequest) Execute() (*http.Response, error) {
	return r.ApiService.LoginUserAgentExecute(r)
}

/*
LoginUserAgent Log the agent of the user holding the authentication token

**Required ACL:** `agentd.users.me.agents.login.create`

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return AgentAPILoginUserAgentRequest
*/
func (a *AgentAPIService) LoginUserAgent(ctx context.Context) AgentAPILoginUserAgentRequest {
	return AgentAPILoginUserAgentRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
func (a *AgentAPIService) LoginUserAgentExecute(r AgentAPILoginUserAgentRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodPost
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AgentAPIService.LoginUserAgent")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/me/agents/login"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return nil, reportError("body is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.accentTenant != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accent-Tenant", r.accentTenant, "")
	}
	// body params
	localVarPostBody = r.body
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["accent_auth_token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Auth-Token"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 409 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type AgentAPILogoffAgentByIdRequest struct {
	ctx          context.Context
	ApiService   AgentAPI
	agentId      int32
	accentTenant *string
}

// The tenant&#39;s UUID, defining the ownership of a given resource.
func (r AgentAPILogoffAgentByIdRequest) AccentTenant(accentTenant string) AgentAPILogoffAgentByIdRequest {
	r.accentTenant = &accentTenant
	return r
}

func (r AgentAPILogoffAgentByIdRequest) Execute() (*http.Response, error) {
	return r.ApiService.LogoffAgentByIdExecute(r)
}

/*
LogoffAgentById Logoff an agent.

**Required ACL:** `agentd.agents.by-id.{agent_id}.logoff.create`

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param agentId Agent's ID
	@return AgentAPILogoffAgentByIdRequest
*/
func (a *AgentAPIService) LogoffAgentById(ctx context.Context, agentId int32) AgentAPILogoffAgentByIdRequest {
	return AgentAPILogoffAgentByIdRequest{
		ApiService: a,
		ctx:        ctx,
		agentId:    agentId,
	}
}

// Execute executes the request
func (a *AgentAPIService) LogoffAgentByIdExecute(r AgentAPILogoffAgentByIdRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodPost
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AgentAPIService.LogoffAgentById")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/agents/by-id/{agent_id}/logoff"
	localVarPath = strings.Replace(localVarPath, "{"+"agent_id"+"}", url.PathEscape(parameterValueToString(r.agentId, "agentId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.accentTenant != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accent-Tenant", r.accentTenant, "")
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["accent_auth_token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Auth-Token"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 409 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type AgentAPILogoffAgentByNumberRequest struct {
	ctx          context.Context
	ApiService   AgentAPI
	agentNumber  string
	accentTenant *string
}

// The tenant&#39;s UUID, defining the ownership of a given resource.
func (r AgentAPILogoffAgentByNumberRequest) AccentTenant(accentTenant string) AgentAPILogoffAgentByNumberRequest {
	r.accentTenant = &accentTenant
	return r
}

func (r AgentAPILogoffAgentByNumberRequest) Execute() (*http.Response, error) {
	return r.ApiService.LogoffAgentByNumberExecute(r)
}

/*
LogoffAgentByNumber Logoff an agent.

**Required ACL:** `agentd.agents.by-number.{agent_number}.logoff.create`

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param agentNumber Agent's number
	@return AgentAPILogoffAgentByNumberRequest
*/
func (a *AgentAPIService) LogoffAgentByNumber(ctx context.Context, agentNumber string) AgentAPILogoffAgentByNumberRequest {
	return AgentAPILogoffAgentByNumberRequest{
		ApiService:  a,
		ctx:         ctx,
		agentNumber: agentNumber,
	}
}

// Execute executes the request
func (a *AgentAPIService) LogoffAgentByNumberExecute(r AgentAPILogoffAgentByNumberRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodPost
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AgentAPIService.LogoffAgentByNumber")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/agents/by-number/{agent_number}/logoff"
	localVarPath = strings.Replace(localVarPath, "{"+"agent_number"+"}", url.PathEscape(parameterValueToString(r.agentNumber, "agentNumber")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.accentTenant != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accent-Tenant", r.accentTenant, "")
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["accent_auth_token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Auth-Token"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 409 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type AgentAPILogoffUserAgentRequest struct {
	ctx          context.Context
	ApiService   AgentAPI
	accentTenant *string
}

// The tenant&#39;s UUID, defining the ownership of a given resource.
func (r AgentAPILogoffUserAgentRequest) AccentTenant(accentTenant string) AgentAPILogoffUserAgentRequest {
	r.accentTenant = &accentTenant
	return r
}

func (r AgentAPILogoffUserAgentRequest) Execute() (*http.Response, error) {
	return r.ApiService.LogoffUserAgentExecute(r)
}

/*
LogoffUserAgent Logoff the agent of the user holding the authentication token

**Required ACL:** `agentd.users.me.agents.logoff.create`

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return AgentAPILogoffUserAgentRequest
*/
func (a *AgentAPIService) LogoffUserAgent(ctx context.Context) AgentAPILogoffUserAgentRequest {
	return AgentAPILogoffUserAgentRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
func (a *AgentAPIService) LogoffUserAgentExecute(r AgentAPILogoffUserAgentRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodPost
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AgentAPIService.LogoffUserAgent")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/me/agents/logoff"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.accentTenant != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accent-Tenant", r.accentTenant, "")
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["accent_auth_token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Auth-Token"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 409 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type AgentAPIPauseAgentByNumberRequest struct {
	ctx          context.Context
	ApiService   AgentAPI
	agentNumber  string
	body         *AgentPauseReason
	accentTenant *string
}

// The reason for pausing the agent
func (r AgentAPIPauseAgentByNumberRequest) Body(body AgentPauseReason) AgentAPIPauseAgentByNumberRequest {
	r.body = &body
	return r
}

// The tenant&#39;s UUID, defining the ownership of a given resource.
func (r AgentAPIPauseAgentByNumberRequest) AccentTenant(accentTenant string) AgentAPIPauseAgentByNumberRequest {
	r.accentTenant = &accentTenant
	return r
}

func (r AgentAPIPauseAgentByNumberRequest) Execute() (*http.Response, error) {
	return r.ApiService.PauseAgentByNumberExecute(r)
}

/*
PauseAgentByNumber Pause an agent.

**Required ACL:** `agentd.agents.by-number.{agent_number}.pause.create`

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param agentNumber Agent's number
	@return AgentAPIPauseAgentByNumberRequest
*/
func (a *AgentAPIService) PauseAgentByNumber(ctx context.Context, agentNumber string) AgentAPIPauseAgentByNumberRequest {
	return AgentAPIPauseAgentByNumberRequest{
		ApiService:  a,
		ctx:         ctx,
		agentNumber: agentNumber,
	}
}

// Execute executes the request
func (a *AgentAPIService) PauseAgentByNumberExecute(r AgentAPIPauseAgentByNumberRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodPost
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AgentAPIService.PauseAgentByNumber")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/agents/by-number/{agent_number}/pause"
	localVarPath = strings.Replace(localVarPath, "{"+"agent_number"+"}", url.PathEscape(parameterValueToString(r.agentNumber, "agentNumber")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.accentTenant != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accent-Tenant", r.accentTenant, "")
	}
	// body params
	localVarPostBody = r.body
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["accent_auth_token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Auth-Token"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 409 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type AgentAPIPauseUserAgentRequest struct {
	ctx          context.Context
	ApiService   AgentAPI
	body         *AgentPauseReason
	accentTenant *string
}

// The reason for pausing the agent
func (r AgentAPIPauseUserAgentRequest) Body(body AgentPauseReason) AgentAPIPauseUserAgentRequest {
	r.body = &body
	return r
}

// The tenant&#39;s UUID, defining the ownership of a given resource.
func (r AgentAPIPauseUserAgentRequest) AccentTenant(accentTenant string) AgentAPIPauseUserAgentRequest {
	r.accentTenant = &accentTenant
	return r
}

func (r AgentAPIPauseUserAgentRequest) Execute() (*http.Response, error) {
	return r.ApiService.PauseUserAgentExecute(r)
}

/*
PauseUserAgent Pause the agent of the user holding the authentication token

**Required ACL:** `agentd.users.me.agents.pause.create`

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return AgentAPIPauseUserAgentRequest
*/
func (a *AgentAPIService) PauseUserAgent(ctx context.Context) AgentAPIPauseUserAgentRequest {
	return AgentAPIPauseUserAgentRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
func (a *AgentAPIService) PauseUserAgentExecute(r AgentAPIPauseUserAgentRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodPost
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AgentAPIService.PauseUserAgent")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/me/agents/pause"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.accentTenant != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accent-Tenant", r.accentTenant, "")
	}
	// body params
	localVarPostBody = r.body
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["accent_auth_token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Auth-Token"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 409 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type AgentAPIRemoveAgentByIdRequest struct {
	ctx          context.Context
	ApiService   AgentAPI
	body         *Queue
	agentId      int32
	accentTenant *string
}

// The queue to remove the agent from
func (r AgentAPIRemoveAgentByIdRequest) Body(body Queue) AgentAPIRemoveAgentByIdRequest {
	r.body = &body
	return r
}

// The tenant&#39;s UUID, defining the ownership of a given resource.
func (r AgentAPIRemoveAgentByIdRequest) AccentTenant(accentTenant string) AgentAPIRemoveAgentByIdRequest {
	r.accentTenant = &accentTenant
	return r
}

func (r AgentAPIRemoveAgentByIdRequest) Execute() (*http.Response, error) {
	return r.ApiService.RemoveAgentByIdExecute(r)
}

/*
RemoveAgentById Remove agent from a queue.

**Required ACL:** `agentd.agents.by-id.{agent_id}.remove.create`

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param agentId Agent's ID
	@return AgentAPIRemoveAgentByIdRequest
*/
func (a *AgentAPIService) RemoveAgentById(ctx context.Context, agentId int32) AgentAPIRemoveAgentByIdRequest {
	return AgentAPIRemoveAgentByIdRequest{
		ApiService: a,
		ctx:        ctx,
		agentId:    agentId,
	}
}

// Execute executes the request
func (a *AgentAPIService) RemoveAgentByIdExecute(r AgentAPIRemoveAgentByIdRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodPost
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AgentAPIService.RemoveAgentById")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/agents/by-id/{agent_id}/remove"
	localVarPath = strings.Replace(localVarPath, "{"+"agent_id"+"}", url.PathEscape(parameterValueToString(r.agentId, "agentId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return nil, reportError("body is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.accentTenant != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accent-Tenant", r.accentTenant, "")
	}
	// body params
	localVarPostBody = r.body
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["accent_auth_token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Auth-Token"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 409 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type AgentAPIUnpauseAgentByNumberRequest struct {
	ctx          context.Context
	ApiService   AgentAPI
	agentNumber  string
	accentTenant *string
}

// The tenant&#39;s UUID, defining the ownership of a given resource.
func (r AgentAPIUnpauseAgentByNumberRequest) AccentTenant(accentTenant string) AgentAPIUnpauseAgentByNumberRequest {
	r.accentTenant = &accentTenant
	return r
}

func (r AgentAPIUnpauseAgentByNumberRequest) Execute() (*http.Response, error) {
	return r.ApiService.UnpauseAgentByNumberExecute(r)
}

/*
UnpauseAgentByNumber Unpause an agent.

**Required ACL:** `agentd.agents.by-number.{agent_number}.unpause.create`

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param agentNumber Agent's number
	@return AgentAPIUnpauseAgentByNumberRequest
*/
func (a *AgentAPIService) UnpauseAgentByNumber(ctx context.Context, agentNumber string) AgentAPIUnpauseAgentByNumberRequest {
	return AgentAPIUnpauseAgentByNumberRequest{
		ApiService:  a,
		ctx:         ctx,
		agentNumber: agentNumber,
	}
}

// Execute executes the request
func (a *AgentAPIService) UnpauseAgentByNumberExecute(r AgentAPIUnpauseAgentByNumberRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodPost
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AgentAPIService.UnpauseAgentByNumber")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/agents/by-number/{agent_number}/unpause"
	localVarPath = strings.Replace(localVarPath, "{"+"agent_number"+"}", url.PathEscape(parameterValueToString(r.agentNumber, "agentNumber")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.accentTenant != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accent-Tenant", r.accentTenant, "")
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["accent_auth_token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Auth-Token"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 409 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type AgentAPIUnpauseUserAgentRequest struct {
	ctx          context.Context
	ApiService   AgentAPI
	accentTenant *string
}

// The tenant&#39;s UUID, defining the ownership of a given resource.
func (r AgentAPIUnpauseUserAgentRequest) AccentTenant(accentTenant string) AgentAPIUnpauseUserAgentRequest {
	r.accentTenant = &accentTenant
	return r
}

func (r AgentAPIUnpauseUserAgentRequest) Execute() (*http.Response, error) {
	return r.ApiService.UnpauseUserAgentExecute(r)
}

/*
UnpauseUserAgent Unpause the agent of the user holding the authentication token

**Required ACL:** `agentd.users.me.agents.unpause.create`

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return AgentAPIUnpauseUserAgentRequest
*/
func (a *AgentAPIService) UnpauseUserAgent(ctx context.Context) AgentAPIUnpauseUserAgentRequest {
	return AgentAPIUnpauseUserAgentRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
func (a *AgentAPIService) UnpauseUserAgentExecute(r AgentAPIUnpauseUserAgentRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodPost
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AgentAPIService.UnpauseUserAgent")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/me/agents/unpause"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.accentTenant != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accent-Tenant", r.accentTenant, "")
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["accent_auth_token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Auth-Token"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 409 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

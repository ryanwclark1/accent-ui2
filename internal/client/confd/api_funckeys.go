/*
accent-confd

Confd exposes an API for managing core resources on a Accent server such as users, extensions, devices, voicemails, queues, etc. Resources can be associated together to provide additional functionality. For example: By associating a voicemail with a user, calls will automatically fallback on to the voicemail when the user cannot answer.  Implementation notes ====================  Errors ------  Responses containing errors will have a status code in the 400 or 500 class. A list of error messages will be returned in the body of the response as a JSON-encoded array:  ~~~ [     \"Input error - User not found\",     \"Resource error - User not associated to a line\" ] ~~~   Updating resources via PUT --------------------------  When updating a resource, all fields become optional. In other words, only values that have been changed need to be sent to the server. Please note that this behavior may change in future versions of the API.

API version: 1.1
Contact: help@accentvoice.io
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package confd

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"strings"
)

type FunckeysAPI interface {

	/*
		AssociateUserFuncKeyTemplate Associate a func key template to a user

		**Required ACL:** `confd.users.{user_id}.funckeys.templates.{template_id}.update`

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param userId the user's ID or UUID
		@param templateId
		@return ApiAssociateUserFuncKeyTemplateRequest
	*/
	AssociateUserFuncKeyTemplate(ctx context.Context, userId string, templateId int32) ApiAssociateUserFuncKeyTemplateRequest

	// AssociateUserFuncKeyTemplateExecute executes the request
	AssociateUserFuncKeyTemplateExecute(r ApiAssociateUserFuncKeyTemplateRequest) (*http.Response, error)

	/*
		CreateFuncKeyTemplate Create a template of func keys

		**Required ACL:** `confd.funckeys.templates.create`

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@return ApiCreateFuncKeyTemplateRequest
	*/
	CreateFuncKeyTemplate(ctx context.Context) ApiCreateFuncKeyTemplateRequest

	// CreateFuncKeyTemplateExecute executes the request
	//  @return FuncKeyTemplate
	CreateFuncKeyTemplateExecute(r ApiCreateFuncKeyTemplateRequest) (*FuncKeyTemplate, *http.Response, error)

	/*
		DeleteFuncKey Remove func key from template

		**Required ACL:** `confd.funckeys.templates.{template_id}.{position}.delete`

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param templateId
		@param position position of the funckey
		@return ApiDeleteFuncKeyRequest
	*/
	DeleteFuncKey(ctx context.Context, templateId int32, position int32) ApiDeleteFuncKeyRequest

	// DeleteFuncKeyExecute executes the request
	DeleteFuncKeyExecute(r ApiDeleteFuncKeyRequest) (*http.Response, error)

	/*
		DeleteFuncKeyTemplate Delete func key template

		**Required ACL:** `confd.funckeys.templates.{template_id}.delete`

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param templateId
		@return ApiDeleteFuncKeyTemplateRequest
	*/
	DeleteFuncKeyTemplate(ctx context.Context, templateId int32) ApiDeleteFuncKeyTemplateRequest

	// DeleteFuncKeyTemplateExecute executes the request
	DeleteFuncKeyTemplateExecute(r ApiDeleteFuncKeyTemplateRequest) (*http.Response, error)

	/*
		DeleteUserFuncKey Remove func key for user

		**Required ACL:** `confd.users.{user_id}.funckeys.{position}.delete`

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param userId the user's ID or UUID
		@param position position of the funckey
		@return ApiDeleteUserFuncKeyRequest
	*/
	DeleteUserFuncKey(ctx context.Context, userId string, position int32) ApiDeleteUserFuncKeyRequest

	// DeleteUserFuncKeyExecute executes the request
	DeleteUserFuncKeyExecute(r ApiDeleteUserFuncKeyRequest) (*http.Response, error)

	/*
		DissociateUserFuncKeyTemplate Dissociate a func key template to a user

		**Required ACL:** `confd.users.{user_id}.funckeys.templates.{template_id}.delete`

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param userId the user's ID or UUID
		@param templateId
		@return ApiDissociateUserFuncKeyTemplateRequest
	*/
	DissociateUserFuncKeyTemplate(ctx context.Context, userId string, templateId int32) ApiDissociateUserFuncKeyTemplateRequest

	// DissociateUserFuncKeyTemplateExecute executes the request
	DissociateUserFuncKeyTemplateExecute(r ApiDissociateUserFuncKeyTemplateRequest) (*http.Response, error)

	/*
		GetFuncKey Get a func key inside template

		**Required ACL:** `confd.funckeys.templates.{template_id}.{position}.read`

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param templateId
		@param position position of the funckey
		@return ApiGetFuncKeyRequest
	*/
	GetFuncKey(ctx context.Context, templateId int32, position int32) ApiGetFuncKeyRequest

	// GetFuncKeyExecute executes the request
	//  @return FuncKey
	GetFuncKeyExecute(r ApiGetFuncKeyRequest) (*FuncKey, *http.Response, error)

	/*
		GetFuncKeyTemplate Get a func key template

		**Required ACL:** `confd.funckeys.templates.{template_id}.read`

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param templateId
		@return ApiGetFuncKeyTemplateRequest
	*/
	GetFuncKeyTemplate(ctx context.Context, templateId int32) ApiGetFuncKeyTemplateRequest

	// GetFuncKeyTemplateExecute executes the request
	//  @return FuncKeyTemplate
	GetFuncKeyTemplateExecute(r ApiGetFuncKeyTemplateRequest) (*FuncKeyTemplate, *http.Response, error)

	/*
		GetUserFuncKey Get a func key for a user

		**Required ACL:** `confd.users.{user_id}.funckeys.{position}.read`

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param userId the user's ID or UUID
		@param position position of the funckey
		@return ApiGetUserFuncKeyRequest
	*/
	GetUserFuncKey(ctx context.Context, userId string, position int32) ApiGetUserFuncKeyRequest

	// GetUserFuncKeyExecute executes the request
	//  @return FuncKey
	GetUserFuncKeyExecute(r ApiGetUserFuncKeyRequest) (*FuncKey, *http.Response, error)

	/*
		ListFuncKeyDestinations List of possible func key destinations and their parameters

		**Required ACL:** `confd.funckeys.destinations.read`

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@return ApiListFuncKeyDestinationsRequest
	*/
	ListFuncKeyDestinations(ctx context.Context) ApiListFuncKeyDestinationsRequest

	// ListFuncKeyDestinationsExecute executes the request
	//  @return []FuncKeyDestination
	ListFuncKeyDestinationsExecute(r ApiListFuncKeyDestinationsRequest) ([]FuncKeyDestination, *http.Response, error)

	/*
		ListFuncKeyTemplate List a func key template

		**Required ACL:** `confd.funckeys.templates.read`

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@return ApiListFuncKeyTemplateRequest
	*/
	ListFuncKeyTemplate(ctx context.Context) ApiListFuncKeyTemplateRequest

	// ListFuncKeyTemplateExecute executes the request
	//  @return FuncKeyTemplate
	ListFuncKeyTemplateExecute(r ApiListFuncKeyTemplateRequest) (*FuncKeyTemplate, *http.Response, error)

	/*
		ListFuncKeyTemplateUserAssociations List users associated to template

		**Required ACL:** `confd.funckeys.templates.{template_id}.users.read`

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param templateId
		@return ApiListFuncKeyTemplateUserAssociationsRequest
	*/
	ListFuncKeyTemplateUserAssociations(ctx context.Context, templateId int32) ApiListFuncKeyTemplateUserAssociationsRequest

	// ListFuncKeyTemplateUserAssociationsExecute executes the request
	//  @return UserFuncKeyTemplate
	ListFuncKeyTemplateUserAssociationsExecute(r ApiListFuncKeyTemplateUserAssociationsRequest) (*UserFuncKeyTemplate, *http.Response, error)

	/*
		ListUserFuncKeyTemplateAssociations List funckey templates associated to user

		**Required ACL:** `confd.users.{user_id}.funckeys.templates.read`

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param userId the user's ID or UUID
		@return ApiListUserFuncKeyTemplateAssociationsRequest
	*/
	ListUserFuncKeyTemplateAssociations(ctx context.Context, userId string) ApiListUserFuncKeyTemplateAssociationsRequest

	// ListUserFuncKeyTemplateAssociationsExecute executes the request
	//  @return UserFuncKeyTemplate
	ListUserFuncKeyTemplateAssociationsExecute(r ApiListUserFuncKeyTemplateAssociationsRequest) (*UserFuncKeyTemplate, *http.Response, error)

	/*
		ListUserFuncKeys List func keys for a user

		**Required ACL:** `confd.users.{user_id}.funckeys.read`

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param userId the user's ID or UUID
		@return ApiListUserFuncKeysRequest
	*/
	ListUserFuncKeys(ctx context.Context, userId string) ApiListUserFuncKeysRequest

	// ListUserFuncKeysExecute executes the request
	//  @return FuncKeyTemplate
	ListUserFuncKeysExecute(r ApiListUserFuncKeysRequest) (*FuncKeyTemplate, *http.Response, error)

	/*
		UpdateFuncKey Add/Replace a func key in a template

		**Required ACL:** `confd.funckeys.templates.{template_id}.{position}.update`

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param templateId
		@param position position of the funckey
		@return ApiUpdateFuncKeyRequest
	*/
	UpdateFuncKey(ctx context.Context, templateId int32, position int32) ApiUpdateFuncKeyRequest

	// UpdateFuncKeyExecute executes the request
	UpdateFuncKeyExecute(r ApiUpdateFuncKeyRequest) (*http.Response, error)

	/*
		UpdateFuncKeyTemplate Update a func key template

		**Required ACL:** `confd.funckeys.templates.{template_id}.update`

	**WARNING** This endpoint restore to default value or delete all fields that are not defined.

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param templateId
		@return ApiUpdateFuncKeyTemplateRequest
	*/
	UpdateFuncKeyTemplate(ctx context.Context, templateId int32) ApiUpdateFuncKeyTemplateRequest

	// UpdateFuncKeyTemplateExecute executes the request
	UpdateFuncKeyTemplateExecute(r ApiUpdateFuncKeyTemplateRequest) (*http.Response, error)

	/*
		UpdateUserFuncKey Add/Replace a func key for a user

		**Required ACL:** `confd.users.{user_id}.funckeys.{position}.update`

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param userId the user's ID or UUID
		@param position position of the funckey
		@return ApiUpdateUserFuncKeyRequest
	*/
	UpdateUserFuncKey(ctx context.Context, userId string, position int32) ApiUpdateUserFuncKeyRequest

	// UpdateUserFuncKeyExecute executes the request
	UpdateUserFuncKeyExecute(r ApiUpdateUserFuncKeyRequest) (*http.Response, error)

	/*
		UpdateUserFuncKeys Update func keys for a user

		**Required ACL:** `confd.users.{user_id}.funckeys.update`

	**WARNING** This endpoint restore to default value or delete all fields that are not defined.

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param userId the user's ID or UUID
		@return ApiUpdateUserFuncKeysRequest
	*/
	UpdateUserFuncKeys(ctx context.Context, userId string) ApiUpdateUserFuncKeysRequest

	// UpdateUserFuncKeysExecute executes the request
	UpdateUserFuncKeysExecute(r ApiUpdateUserFuncKeysRequest) (*http.Response, error)
}

// FunckeysAPIService FunckeysAPI service
type FunckeysAPIService service

type ApiAssociateUserFuncKeyTemplateRequest struct {
	ctx          context.Context
	ApiService   FunckeysAPI
	userId       string
	templateId   int32
	accentTenant *string
}

// The tenant&#39;s UUID, defining the ownership of a given resource.
func (r ApiAssociateUserFuncKeyTemplateRequest) AccentTenant(accentTenant string) ApiAssociateUserFuncKeyTemplateRequest {
	r.accentTenant = &accentTenant
	return r
}

func (r ApiAssociateUserFuncKeyTemplateRequest) Execute() (*http.Response, error) {
	return r.ApiService.AssociateUserFuncKeyTemplateExecute(r)
}

/*
AssociateUserFuncKeyTemplate Associate a func key template to a user

**Required ACL:** `confd.users.{user_id}.funckeys.templates.{template_id}.update`

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param userId the user's ID or UUID
	@param templateId
	@return ApiAssociateUserFuncKeyTemplateRequest
*/
func (a *FunckeysAPIService) AssociateUserFuncKeyTemplate(ctx context.Context, userId string, templateId int32) ApiAssociateUserFuncKeyTemplateRequest {
	return ApiAssociateUserFuncKeyTemplateRequest{
		ApiService: a,
		ctx:        ctx,
		userId:     userId,
		templateId: templateId,
	}
}

// Execute executes the request
func (a *FunckeysAPIService) AssociateUserFuncKeyTemplateExecute(r ApiAssociateUserFuncKeyTemplateRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodPut
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "FunckeysAPIService.AssociateUserFuncKeyTemplate")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/{user_id}/funckeys/templates/{template_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"user_id"+"}", url.PathEscape(parameterValueToString(r.userId, "userId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"template_id"+"}", url.PathEscape(parameterValueToString(r.templateId, "templateId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.accentTenant != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accent-Tenant", r.accentTenant, "")
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["accent_auth_token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Auth-Token"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v []string
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v []string
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiCreateFuncKeyTemplateRequest struct {
	ctx          context.Context
	ApiService   FunckeysAPI
	body         *FuncKeyTemplate
	accentTenant *string
}

// Template to create
func (r ApiCreateFuncKeyTemplateRequest) Body(body FuncKeyTemplate) ApiCreateFuncKeyTemplateRequest {
	r.body = &body
	return r
}

// The tenant&#39;s UUID, defining the ownership of a given resource.
func (r ApiCreateFuncKeyTemplateRequest) AccentTenant(accentTenant string) ApiCreateFuncKeyTemplateRequest {
	r.accentTenant = &accentTenant
	return r
}

func (r ApiCreateFuncKeyTemplateRequest) Execute() (*FuncKeyTemplate, *http.Response, error) {
	return r.ApiService.CreateFuncKeyTemplateExecute(r)
}

/*
CreateFuncKeyTemplate Create a template of func keys

**Required ACL:** `confd.funckeys.templates.create`

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiCreateFuncKeyTemplateRequest
*/
func (a *FunckeysAPIService) CreateFuncKeyTemplate(ctx context.Context) ApiCreateFuncKeyTemplateRequest {
	return ApiCreateFuncKeyTemplateRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return FuncKeyTemplate
func (a *FunckeysAPIService) CreateFuncKeyTemplateExecute(r ApiCreateFuncKeyTemplateRequest) (*FuncKeyTemplate, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *FuncKeyTemplate
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "FunckeysAPIService.CreateFuncKeyTemplate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/funckeys/templates"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.accentTenant != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accent-Tenant", r.accentTenant, "")
	}
	// body params
	localVarPostBody = r.body
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["accent_auth_token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Auth-Token"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v []string
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDeleteFuncKeyRequest struct {
	ctx          context.Context
	ApiService   FunckeysAPI
	templateId   int32
	position     int32
	accentTenant *string
}

// The tenant&#39;s UUID, defining the ownership of a given resource.
func (r ApiDeleteFuncKeyRequest) AccentTenant(accentTenant string) ApiDeleteFuncKeyRequest {
	r.accentTenant = &accentTenant
	return r
}

func (r ApiDeleteFuncKeyRequest) Execute() (*http.Response, error) {
	return r.ApiService.DeleteFuncKeyExecute(r)
}

/*
DeleteFuncKey Remove func key from template

**Required ACL:** `confd.funckeys.templates.{template_id}.{position}.delete`

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param templateId
	@param position position of the funckey
	@return ApiDeleteFuncKeyRequest
*/
func (a *FunckeysAPIService) DeleteFuncKey(ctx context.Context, templateId int32, position int32) ApiDeleteFuncKeyRequest {
	return ApiDeleteFuncKeyRequest{
		ApiService: a,
		ctx:        ctx,
		templateId: templateId,
		position:   position,
	}
}

// Execute executes the request
func (a *FunckeysAPIService) DeleteFuncKeyExecute(r ApiDeleteFuncKeyRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodDelete
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "FunckeysAPIService.DeleteFuncKey")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/funckeys/templates/{template_id}/{position}"
	localVarPath = strings.Replace(localVarPath, "{"+"template_id"+"}", url.PathEscape(parameterValueToString(r.templateId, "templateId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"position"+"}", url.PathEscape(parameterValueToString(r.position, "position")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.accentTenant != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accent-Tenant", r.accentTenant, "")
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["accent_auth_token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Auth-Token"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v []string
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v []string
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiDeleteFuncKeyTemplateRequest struct {
	ctx          context.Context
	ApiService   FunckeysAPI
	templateId   int32
	accentTenant *string
}

// The tenant&#39;s UUID, defining the ownership of a given resource.
func (r ApiDeleteFuncKeyTemplateRequest) AccentTenant(accentTenant string) ApiDeleteFuncKeyTemplateRequest {
	r.accentTenant = &accentTenant
	return r
}

func (r ApiDeleteFuncKeyTemplateRequest) Execute() (*http.Response, error) {
	return r.ApiService.DeleteFuncKeyTemplateExecute(r)
}

/*
DeleteFuncKeyTemplate Delete func key template

**Required ACL:** `confd.funckeys.templates.{template_id}.delete`

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param templateId
	@return ApiDeleteFuncKeyTemplateRequest
*/
func (a *FunckeysAPIService) DeleteFuncKeyTemplate(ctx context.Context, templateId int32) ApiDeleteFuncKeyTemplateRequest {
	return ApiDeleteFuncKeyTemplateRequest{
		ApiService: a,
		ctx:        ctx,
		templateId: templateId,
	}
}

// Execute executes the request
func (a *FunckeysAPIService) DeleteFuncKeyTemplateExecute(r ApiDeleteFuncKeyTemplateRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodDelete
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "FunckeysAPIService.DeleteFuncKeyTemplate")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/funckeys/templates/{template_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"template_id"+"}", url.PathEscape(parameterValueToString(r.templateId, "templateId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.accentTenant != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accent-Tenant", r.accentTenant, "")
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["accent_auth_token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Auth-Token"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v []string
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v []string
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiDeleteUserFuncKeyRequest struct {
	ctx          context.Context
	ApiService   FunckeysAPI
	userId       string
	position     int32
	accentTenant *string
}

// The tenant&#39;s UUID, defining the ownership of a given resource.
func (r ApiDeleteUserFuncKeyRequest) AccentTenant(accentTenant string) ApiDeleteUserFuncKeyRequest {
	r.accentTenant = &accentTenant
	return r
}

func (r ApiDeleteUserFuncKeyRequest) Execute() (*http.Response, error) {
	return r.ApiService.DeleteUserFuncKeyExecute(r)
}

/*
DeleteUserFuncKey Remove func key for user

**Required ACL:** `confd.users.{user_id}.funckeys.{position}.delete`

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param userId the user's ID or UUID
	@param position position of the funckey
	@return ApiDeleteUserFuncKeyRequest
*/
func (a *FunckeysAPIService) DeleteUserFuncKey(ctx context.Context, userId string, position int32) ApiDeleteUserFuncKeyRequest {
	return ApiDeleteUserFuncKeyRequest{
		ApiService: a,
		ctx:        ctx,
		userId:     userId,
		position:   position,
	}
}

// Execute executes the request
func (a *FunckeysAPIService) DeleteUserFuncKeyExecute(r ApiDeleteUserFuncKeyRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodDelete
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "FunckeysAPIService.DeleteUserFuncKey")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/{user_id}/funckeys/{position}"
	localVarPath = strings.Replace(localVarPath, "{"+"user_id"+"}", url.PathEscape(parameterValueToString(r.userId, "userId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"position"+"}", url.PathEscape(parameterValueToString(r.position, "position")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.accentTenant != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accent-Tenant", r.accentTenant, "")
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["accent_auth_token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Auth-Token"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v []string
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v []string
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiDissociateUserFuncKeyTemplateRequest struct {
	ctx          context.Context
	ApiService   FunckeysAPI
	userId       string
	templateId   int32
	accentTenant *string
}

// The tenant&#39;s UUID, defining the ownership of a given resource.
func (r ApiDissociateUserFuncKeyTemplateRequest) AccentTenant(accentTenant string) ApiDissociateUserFuncKeyTemplateRequest {
	r.accentTenant = &accentTenant
	return r
}

func (r ApiDissociateUserFuncKeyTemplateRequest) Execute() (*http.Response, error) {
	return r.ApiService.DissociateUserFuncKeyTemplateExecute(r)
}

/*
DissociateUserFuncKeyTemplate Dissociate a func key template to a user

**Required ACL:** `confd.users.{user_id}.funckeys.templates.{template_id}.delete`

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param userId the user's ID or UUID
	@param templateId
	@return ApiDissociateUserFuncKeyTemplateRequest
*/
func (a *FunckeysAPIService) DissociateUserFuncKeyTemplate(ctx context.Context, userId string, templateId int32) ApiDissociateUserFuncKeyTemplateRequest {
	return ApiDissociateUserFuncKeyTemplateRequest{
		ApiService: a,
		ctx:        ctx,
		userId:     userId,
		templateId: templateId,
	}
}

// Execute executes the request
func (a *FunckeysAPIService) DissociateUserFuncKeyTemplateExecute(r ApiDissociateUserFuncKeyTemplateRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodDelete
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "FunckeysAPIService.DissociateUserFuncKeyTemplate")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/{user_id}/funckeys/templates/{template_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"user_id"+"}", url.PathEscape(parameterValueToString(r.userId, "userId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"template_id"+"}", url.PathEscape(parameterValueToString(r.templateId, "templateId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.accentTenant != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accent-Tenant", r.accentTenant, "")
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["accent_auth_token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Auth-Token"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v []string
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v []string
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiGetFuncKeyRequest struct {
	ctx          context.Context
	ApiService   FunckeysAPI
	templateId   int32
	position     int32
	accentTenant *string
}

// The tenant&#39;s UUID, defining the ownership of a given resource.
func (r ApiGetFuncKeyRequest) AccentTenant(accentTenant string) ApiGetFuncKeyRequest {
	r.accentTenant = &accentTenant
	return r
}

func (r ApiGetFuncKeyRequest) Execute() (*FuncKey, *http.Response, error) {
	return r.ApiService.GetFuncKeyExecute(r)
}

/*
GetFuncKey Get a func key inside template

**Required ACL:** `confd.funckeys.templates.{template_id}.{position}.read`

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param templateId
	@param position position of the funckey
	@return ApiGetFuncKeyRequest
*/
func (a *FunckeysAPIService) GetFuncKey(ctx context.Context, templateId int32, position int32) ApiGetFuncKeyRequest {
	return ApiGetFuncKeyRequest{
		ApiService: a,
		ctx:        ctx,
		templateId: templateId,
		position:   position,
	}
}

// Execute executes the request
//
//	@return FuncKey
func (a *FunckeysAPIService) GetFuncKeyExecute(r ApiGetFuncKeyRequest) (*FuncKey, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *FuncKey
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "FunckeysAPIService.GetFuncKey")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/funckeys/templates/{template_id}/{position}"
	localVarPath = strings.Replace(localVarPath, "{"+"template_id"+"}", url.PathEscape(parameterValueToString(r.templateId, "templateId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"position"+"}", url.PathEscape(parameterValueToString(r.position, "position")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.accentTenant != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accent-Tenant", r.accentTenant, "")
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["accent_auth_token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Auth-Token"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v []string
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetFuncKeyTemplateRequest struct {
	ctx          context.Context
	ApiService   FunckeysAPI
	templateId   int32
	accentTenant *string
}

// The tenant&#39;s UUID, defining the ownership of a given resource.
func (r ApiGetFuncKeyTemplateRequest) AccentTenant(accentTenant string) ApiGetFuncKeyTemplateRequest {
	r.accentTenant = &accentTenant
	return r
}

func (r ApiGetFuncKeyTemplateRequest) Execute() (*FuncKeyTemplate, *http.Response, error) {
	return r.ApiService.GetFuncKeyTemplateExecute(r)
}

/*
GetFuncKeyTemplate Get a func key template

**Required ACL:** `confd.funckeys.templates.{template_id}.read`

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param templateId
	@return ApiGetFuncKeyTemplateRequest
*/
func (a *FunckeysAPIService) GetFuncKeyTemplate(ctx context.Context, templateId int32) ApiGetFuncKeyTemplateRequest {
	return ApiGetFuncKeyTemplateRequest{
		ApiService: a,
		ctx:        ctx,
		templateId: templateId,
	}
}

// Execute executes the request
//
//	@return FuncKeyTemplate
func (a *FunckeysAPIService) GetFuncKeyTemplateExecute(r ApiGetFuncKeyTemplateRequest) (*FuncKeyTemplate, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *FuncKeyTemplate
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "FunckeysAPIService.GetFuncKeyTemplate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/funckeys/templates/{template_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"template_id"+"}", url.PathEscape(parameterValueToString(r.templateId, "templateId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.accentTenant != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accent-Tenant", r.accentTenant, "")
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["accent_auth_token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Auth-Token"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v []string
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetUserFuncKeyRequest struct {
	ctx          context.Context
	ApiService   FunckeysAPI
	userId       string
	position     int32
	accentTenant *string
}

// The tenant&#39;s UUID, defining the ownership of a given resource.
func (r ApiGetUserFuncKeyRequest) AccentTenant(accentTenant string) ApiGetUserFuncKeyRequest {
	r.accentTenant = &accentTenant
	return r
}

func (r ApiGetUserFuncKeyRequest) Execute() (*FuncKey, *http.Response, error) {
	return r.ApiService.GetUserFuncKeyExecute(r)
}

/*
GetUserFuncKey Get a func key for a user

**Required ACL:** `confd.users.{user_id}.funckeys.{position}.read`

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param userId the user's ID or UUID
	@param position position of the funckey
	@return ApiGetUserFuncKeyRequest
*/
func (a *FunckeysAPIService) GetUserFuncKey(ctx context.Context, userId string, position int32) ApiGetUserFuncKeyRequest {
	return ApiGetUserFuncKeyRequest{
		ApiService: a,
		ctx:        ctx,
		userId:     userId,
		position:   position,
	}
}

// Execute executes the request
//
//	@return FuncKey
func (a *FunckeysAPIService) GetUserFuncKeyExecute(r ApiGetUserFuncKeyRequest) (*FuncKey, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *FuncKey
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "FunckeysAPIService.GetUserFuncKey")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/{user_id}/funckeys/{position}"
	localVarPath = strings.Replace(localVarPath, "{"+"user_id"+"}", url.PathEscape(parameterValueToString(r.userId, "userId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"position"+"}", url.PathEscape(parameterValueToString(r.position, "position")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.accentTenant != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accent-Tenant", r.accentTenant, "")
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["accent_auth_token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Auth-Token"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v []string
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiListFuncKeyDestinationsRequest struct {
	ctx        context.Context
	ApiService FunckeysAPI
}

func (r ApiListFuncKeyDestinationsRequest) Execute() ([]FuncKeyDestination, *http.Response, error) {
	return r.ApiService.ListFuncKeyDestinationsExecute(r)
}

/*
ListFuncKeyDestinations List of possible func key destinations and their parameters

**Required ACL:** `confd.funckeys.destinations.read`

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiListFuncKeyDestinationsRequest
*/
func (a *FunckeysAPIService) ListFuncKeyDestinations(ctx context.Context) ApiListFuncKeyDestinationsRequest {
	return ApiListFuncKeyDestinationsRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return []FuncKeyDestination
func (a *FunckeysAPIService) ListFuncKeyDestinationsExecute(r ApiListFuncKeyDestinationsRequest) ([]FuncKeyDestination, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue []FuncKeyDestination
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "FunckeysAPIService.ListFuncKeyDestinations")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/funckeys/destinations"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["accent_auth_token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Auth-Token"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiListFuncKeyTemplateRequest struct {
	ctx          context.Context
	ApiService   FunckeysAPI
	accentTenant *string
	recurse      *bool
}

// The tenant&#39;s UUID, defining the ownership of a given resource.
func (r ApiListFuncKeyTemplateRequest) AccentTenant(accentTenant string) ApiListFuncKeyTemplateRequest {
	r.accentTenant = &accentTenant
	return r
}

// Should the query include sub-tenants
func (r ApiListFuncKeyTemplateRequest) Recurse(recurse bool) ApiListFuncKeyTemplateRequest {
	r.recurse = &recurse
	return r
}

func (r ApiListFuncKeyTemplateRequest) Execute() (*FuncKeyTemplate, *http.Response, error) {
	return r.ApiService.ListFuncKeyTemplateExecute(r)
}

/*
ListFuncKeyTemplate List a func key template

**Required ACL:** `confd.funckeys.templates.read`

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiListFuncKeyTemplateRequest
*/
func (a *FunckeysAPIService) ListFuncKeyTemplate(ctx context.Context) ApiListFuncKeyTemplateRequest {
	return ApiListFuncKeyTemplateRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return FuncKeyTemplate
func (a *FunckeysAPIService) ListFuncKeyTemplateExecute(r ApiListFuncKeyTemplateRequest) (*FuncKeyTemplate, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *FuncKeyTemplate
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "FunckeysAPIService.ListFuncKeyTemplate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/funckeys/templates"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.recurse != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "recurse", r.recurse, "")
	} else {
		var defaultValue bool = false
		r.recurse = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.accentTenant != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accent-Tenant", r.accentTenant, "")
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["accent_auth_token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Auth-Token"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v []string
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiListFuncKeyTemplateUserAssociationsRequest struct {
	ctx          context.Context
	ApiService   FunckeysAPI
	templateId   int32
	accentTenant *string
}

// The tenant&#39;s UUID, defining the ownership of a given resource.
func (r ApiListFuncKeyTemplateUserAssociationsRequest) AccentTenant(accentTenant string) ApiListFuncKeyTemplateUserAssociationsRequest {
	r.accentTenant = &accentTenant
	return r
}

func (r ApiListFuncKeyTemplateUserAssociationsRequest) Execute() (*UserFuncKeyTemplate, *http.Response, error) {
	return r.ApiService.ListFuncKeyTemplateUserAssociationsExecute(r)
}

/*
ListFuncKeyTemplateUserAssociations List users associated to template

**Required ACL:** `confd.funckeys.templates.{template_id}.users.read`

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param templateId
	@return ApiListFuncKeyTemplateUserAssociationsRequest
*/
func (a *FunckeysAPIService) ListFuncKeyTemplateUserAssociations(ctx context.Context, templateId int32) ApiListFuncKeyTemplateUserAssociationsRequest {
	return ApiListFuncKeyTemplateUserAssociationsRequest{
		ApiService: a,
		ctx:        ctx,
		templateId: templateId,
	}
}

// Execute executes the request
//
//	@return UserFuncKeyTemplate
func (a *FunckeysAPIService) ListFuncKeyTemplateUserAssociationsExecute(r ApiListFuncKeyTemplateUserAssociationsRequest) (*UserFuncKeyTemplate, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *UserFuncKeyTemplate
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "FunckeysAPIService.ListFuncKeyTemplateUserAssociations")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/funckeys/templates/{template_id}/users"
	localVarPath = strings.Replace(localVarPath, "{"+"template_id"+"}", url.PathEscape(parameterValueToString(r.templateId, "templateId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.accentTenant != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accent-Tenant", r.accentTenant, "")
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["accent_auth_token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Auth-Token"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v []string
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiListUserFuncKeyTemplateAssociationsRequest struct {
	ctx          context.Context
	ApiService   FunckeysAPI
	userId       string
	accentTenant *string
}

// The tenant&#39;s UUID, defining the ownership of a given resource.
func (r ApiListUserFuncKeyTemplateAssociationsRequest) AccentTenant(accentTenant string) ApiListUserFuncKeyTemplateAssociationsRequest {
	r.accentTenant = &accentTenant
	return r
}

func (r ApiListUserFuncKeyTemplateAssociationsRequest) Execute() (*UserFuncKeyTemplate, *http.Response, error) {
	return r.ApiService.ListUserFuncKeyTemplateAssociationsExecute(r)
}

/*
ListUserFuncKeyTemplateAssociations List funckey templates associated to user

**Required ACL:** `confd.users.{user_id}.funckeys.templates.read`

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param userId the user's ID or UUID
	@return ApiListUserFuncKeyTemplateAssociationsRequest
*/
func (a *FunckeysAPIService) ListUserFuncKeyTemplateAssociations(ctx context.Context, userId string) ApiListUserFuncKeyTemplateAssociationsRequest {
	return ApiListUserFuncKeyTemplateAssociationsRequest{
		ApiService: a,
		ctx:        ctx,
		userId:     userId,
	}
}

// Execute executes the request
//
//	@return UserFuncKeyTemplate
func (a *FunckeysAPIService) ListUserFuncKeyTemplateAssociationsExecute(r ApiListUserFuncKeyTemplateAssociationsRequest) (*UserFuncKeyTemplate, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *UserFuncKeyTemplate
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "FunckeysAPIService.ListUserFuncKeyTemplateAssociations")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/{user_id}/funckeys/templates"
	localVarPath = strings.Replace(localVarPath, "{"+"user_id"+"}", url.PathEscape(parameterValueToString(r.userId, "userId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.accentTenant != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accent-Tenant", r.accentTenant, "")
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["accent_auth_token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Auth-Token"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v []string
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiListUserFuncKeysRequest struct {
	ctx          context.Context
	ApiService   FunckeysAPI
	userId       string
	accentTenant *string
}

// The tenant&#39;s UUID, defining the ownership of a given resource.
func (r ApiListUserFuncKeysRequest) AccentTenant(accentTenant string) ApiListUserFuncKeysRequest {
	r.accentTenant = &accentTenant
	return r
}

func (r ApiListUserFuncKeysRequest) Execute() (*FuncKeyTemplate, *http.Response, error) {
	return r.ApiService.ListUserFuncKeysExecute(r)
}

/*
ListUserFuncKeys List func keys for a user

**Required ACL:** `confd.users.{user_id}.funckeys.read`

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param userId the user's ID or UUID
	@return ApiListUserFuncKeysRequest
*/
func (a *FunckeysAPIService) ListUserFuncKeys(ctx context.Context, userId string) ApiListUserFuncKeysRequest {
	return ApiListUserFuncKeysRequest{
		ApiService: a,
		ctx:        ctx,
		userId:     userId,
	}
}

// Execute executes the request
//
//	@return FuncKeyTemplate
func (a *FunckeysAPIService) ListUserFuncKeysExecute(r ApiListUserFuncKeysRequest) (*FuncKeyTemplate, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *FuncKeyTemplate
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "FunckeysAPIService.ListUserFuncKeys")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/{user_id}/funckeys"
	localVarPath = strings.Replace(localVarPath, "{"+"user_id"+"}", url.PathEscape(parameterValueToString(r.userId, "userId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.accentTenant != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accent-Tenant", r.accentTenant, "")
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["accent_auth_token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Auth-Token"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUpdateFuncKeyRequest struct {
	ctx          context.Context
	ApiService   FunckeysAPI
	body         *FuncKey
	templateId   int32
	position     int32
	accentTenant *string
}

func (r ApiUpdateFuncKeyRequest) Body(body FuncKey) ApiUpdateFuncKeyRequest {
	r.body = &body
	return r
}

// The tenant&#39;s UUID, defining the ownership of a given resource.
func (r ApiUpdateFuncKeyRequest) AccentTenant(accentTenant string) ApiUpdateFuncKeyRequest {
	r.accentTenant = &accentTenant
	return r
}

func (r ApiUpdateFuncKeyRequest) Execute() (*http.Response, error) {
	return r.ApiService.UpdateFuncKeyExecute(r)
}

/*
UpdateFuncKey Add/Replace a func key in a template

**Required ACL:** `confd.funckeys.templates.{template_id}.{position}.update`

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param templateId
	@param position position of the funckey
	@return ApiUpdateFuncKeyRequest
*/
func (a *FunckeysAPIService) UpdateFuncKey(ctx context.Context, templateId int32, position int32) ApiUpdateFuncKeyRequest {
	return ApiUpdateFuncKeyRequest{
		ApiService: a,
		ctx:        ctx,
		templateId: templateId,
		position:   position,
	}
}

// Execute executes the request
func (a *FunckeysAPIService) UpdateFuncKeyExecute(r ApiUpdateFuncKeyRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodPut
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "FunckeysAPIService.UpdateFuncKey")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/funckeys/templates/{template_id}/{position}"
	localVarPath = strings.Replace(localVarPath, "{"+"template_id"+"}", url.PathEscape(parameterValueToString(r.templateId, "templateId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"position"+"}", url.PathEscape(parameterValueToString(r.position, "position")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return nil, reportError("body is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.accentTenant != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accent-Tenant", r.accentTenant, "")
	}
	// body params
	localVarPostBody = r.body
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["accent_auth_token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Auth-Token"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v []string
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiUpdateFuncKeyTemplateRequest struct {
	ctx          context.Context
	ApiService   FunckeysAPI
	body         *FuncKeyTemplate
	templateId   int32
	accentTenant *string
}

func (r ApiUpdateFuncKeyTemplateRequest) Body(body FuncKeyTemplate) ApiUpdateFuncKeyTemplateRequest {
	r.body = &body
	return r
}

// The tenant&#39;s UUID, defining the ownership of a given resource.
func (r ApiUpdateFuncKeyTemplateRequest) AccentTenant(accentTenant string) ApiUpdateFuncKeyTemplateRequest {
	r.accentTenant = &accentTenant
	return r
}

func (r ApiUpdateFuncKeyTemplateRequest) Execute() (*http.Response, error) {
	return r.ApiService.UpdateFuncKeyTemplateExecute(r)
}

/*
UpdateFuncKeyTemplate Update a func key template

**Required ACL:** `confd.funckeys.templates.{template_id}.update`

**WARNING** This endpoint restore to default value or delete all fields that are not defined.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param templateId
	@return ApiUpdateFuncKeyTemplateRequest
*/
func (a *FunckeysAPIService) UpdateFuncKeyTemplate(ctx context.Context, templateId int32) ApiUpdateFuncKeyTemplateRequest {
	return ApiUpdateFuncKeyTemplateRequest{
		ApiService: a,
		ctx:        ctx,
		templateId: templateId,
	}
}

// Execute executes the request
func (a *FunckeysAPIService) UpdateFuncKeyTemplateExecute(r ApiUpdateFuncKeyTemplateRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodPut
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "FunckeysAPIService.UpdateFuncKeyTemplate")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/funckeys/templates/{template_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"template_id"+"}", url.PathEscape(parameterValueToString(r.templateId, "templateId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return nil, reportError("body is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.accentTenant != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accent-Tenant", r.accentTenant, "")
	}
	// body params
	localVarPostBody = r.body
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["accent_auth_token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Auth-Token"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v []string
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiUpdateUserFuncKeyRequest struct {
	ctx          context.Context
	ApiService   FunckeysAPI
	body         *FuncKey
	userId       string
	position     int32
	accentTenant *string
}

func (r ApiUpdateUserFuncKeyRequest) Body(body FuncKey) ApiUpdateUserFuncKeyRequest {
	r.body = &body
	return r
}

// The tenant&#39;s UUID, defining the ownership of a given resource.
func (r ApiUpdateUserFuncKeyRequest) AccentTenant(accentTenant string) ApiUpdateUserFuncKeyRequest {
	r.accentTenant = &accentTenant
	return r
}

func (r ApiUpdateUserFuncKeyRequest) Execute() (*http.Response, error) {
	return r.ApiService.UpdateUserFuncKeyExecute(r)
}

/*
UpdateUserFuncKey Add/Replace a func key for a user

**Required ACL:** `confd.users.{user_id}.funckeys.{position}.update`

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param userId the user's ID or UUID
	@param position position of the funckey
	@return ApiUpdateUserFuncKeyRequest
*/
func (a *FunckeysAPIService) UpdateUserFuncKey(ctx context.Context, userId string, position int32) ApiUpdateUserFuncKeyRequest {
	return ApiUpdateUserFuncKeyRequest{
		ApiService: a,
		ctx:        ctx,
		userId:     userId,
		position:   position,
	}
}

// Execute executes the request
func (a *FunckeysAPIService) UpdateUserFuncKeyExecute(r ApiUpdateUserFuncKeyRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodPut
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "FunckeysAPIService.UpdateUserFuncKey")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/{user_id}/funckeys/{position}"
	localVarPath = strings.Replace(localVarPath, "{"+"user_id"+"}", url.PathEscape(parameterValueToString(r.userId, "userId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"position"+"}", url.PathEscape(parameterValueToString(r.position, "position")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return nil, reportError("body is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.accentTenant != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accent-Tenant", r.accentTenant, "")
	}
	// body params
	localVarPostBody = r.body
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["accent_auth_token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Auth-Token"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v []string
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiUpdateUserFuncKeysRequest struct {
	ctx          context.Context
	ApiService   FunckeysAPI
	body         *FuncKeyTemplate
	userId       string
	accentTenant *string
}

func (r ApiUpdateUserFuncKeysRequest) Body(body FuncKeyTemplate) ApiUpdateUserFuncKeysRequest {
	r.body = &body
	return r
}

// The tenant&#39;s UUID, defining the ownership of a given resource.
func (r ApiUpdateUserFuncKeysRequest) AccentTenant(accentTenant string) ApiUpdateUserFuncKeysRequest {
	r.accentTenant = &accentTenant
	return r
}

func (r ApiUpdateUserFuncKeysRequest) Execute() (*http.Response, error) {
	return r.ApiService.UpdateUserFuncKeysExecute(r)
}

/*
UpdateUserFuncKeys Update func keys for a user

**Required ACL:** `confd.users.{user_id}.funckeys.update`

**WARNING** This endpoint restore to default value or delete all fields that are not defined.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param userId the user's ID or UUID
	@return ApiUpdateUserFuncKeysRequest
*/
func (a *FunckeysAPIService) UpdateUserFuncKeys(ctx context.Context, userId string) ApiUpdateUserFuncKeysRequest {
	return ApiUpdateUserFuncKeysRequest{
		ApiService: a,
		ctx:        ctx,
		userId:     userId,
	}
}

// Execute executes the request
func (a *FunckeysAPIService) UpdateUserFuncKeysExecute(r ApiUpdateUserFuncKeysRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodPut
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "FunckeysAPIService.UpdateUserFuncKeys")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/{user_id}/funckeys"
	localVarPath = strings.Replace(localVarPath, "{"+"user_id"+"}", url.PathEscape(parameterValueToString(r.userId, "userId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return nil, reportError("body is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.accentTenant != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accent-Tenant", r.accentTenant, "")
	}
	// body params
	localVarPostBody = r.body
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["accent_auth_token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Auth-Token"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v []string
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

/*
accent-confd

Confd exposes an API for managing core resources on a Accent server such as users, extensions, devices, voicemails, queues, etc. Resources can be associated together to provide additional functionality. For example: By associating a voicemail with a user, calls will automatically fallback on to the voicemail when the user cannot answer.  Implementation notes ====================  Errors ------  Responses containing errors will have a status code in the 400 or 500 class. A list of error messages will be returned in the body of the response as a JSON-encoded array:  ~~~ [     \"Input error - User not found\",     \"Resource error - User not associated to a line\" ] ~~~   Updating resources via PUT --------------------------  When updating a resource, all fields become optional. In other words, only values that have been changed need to be sent to the server. Please note that this behavior may change in future versions of the API.

API version: 1.1
Contact: help@accentvoice.io
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package confd

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"strings"
)

type QueuesAPI interface {

	/*
		AssociateQueueExtension Associate queue and extension

		**Required ACL:** `confd.queues.{queue_id}.extensions.{extension_id}.update`

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param queueId queue's ID
		@param extensionId
		@return QueuesAPIAssociateQueueExtensionRequest
	*/
	AssociateQueueExtension(ctx context.Context, queueId int32, extensionId int32) QueuesAPIAssociateQueueExtensionRequest

	// AssociateQueueExtensionExecute executes the request
	AssociateQueueExtensionExecute(r QueuesAPIAssociateQueueExtensionRequest) (*http.Response, error)

	/*
		AssociateQueueSchedule Associate queue and schedule

		**Required ACL:** `confd.queues.{queue_id}.schedules.{schedule_id}.update`

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param queueId queue's ID
		@param scheduleId Schedule's ID
		@return QueuesAPIAssociateQueueScheduleRequest
	*/
	AssociateQueueSchedule(ctx context.Context, queueId int32, scheduleId int32) QueuesAPIAssociateQueueScheduleRequest

	// AssociateQueueScheduleExecute executes the request
	AssociateQueueScheduleExecute(r QueuesAPIAssociateQueueScheduleRequest) (*http.Response, error)

	/*
		CreateQueue Create queue

		**Required ACL:** `confd.queues.create`

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@return QueuesAPICreateQueueRequest
	*/
	CreateQueue(ctx context.Context) QueuesAPICreateQueueRequest

	// CreateQueueExecute executes the request
	//  @return Queue
	CreateQueueExecute(r QueuesAPICreateQueueRequest) (*Queue, *http.Response, error)

	/*
		CreateSkillRule Create skill rule

		**Required ACL:** `confd.queues.skillrules.create`

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@return QueuesAPICreateSkillRuleRequest
	*/
	CreateSkillRule(ctx context.Context) QueuesAPICreateSkillRuleRequest

	// CreateSkillRuleExecute executes the request
	//  @return SkillRule
	CreateSkillRuleExecute(r QueuesAPICreateSkillRuleRequest) (*SkillRule, *http.Response, error)

	/*
		DeleteQueue Delete queue

		**Required ACL:** `confd.queues.{queue_id}.delete`

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param queueId queue's ID
		@return QueuesAPIDeleteQueueRequest
	*/
	DeleteQueue(ctx context.Context, queueId int32) QueuesAPIDeleteQueueRequest

	// DeleteQueueExecute executes the request
	DeleteQueueExecute(r QueuesAPIDeleteQueueRequest) (*http.Response, error)

	/*
		DeleteSkillRule Delete skill rule

		**Required ACL:** `confd.queues.skillrules.{skillrule_id}.delete`

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param skillruleId Skill's ID
		@return QueuesAPIDeleteSkillRuleRequest
	*/
	DeleteSkillRule(ctx context.Context, skillruleId int32) QueuesAPIDeleteSkillRuleRequest

	// DeleteSkillRuleExecute executes the request
	DeleteSkillRuleExecute(r QueuesAPIDeleteSkillRuleRequest) (*http.Response, error)

	/*
		DissociateAgentQueue Dissociate agent and queue

		**Required ACL:** `confd.queues.{queue_id}.members.agents.{agent_id}.delete`

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param queueId queue's ID
		@param agentId Agent’s ID
		@return QueuesAPIDissociateAgentQueueRequest
	*/
	DissociateAgentQueue(ctx context.Context, queueId int32, agentId int32) QueuesAPIDissociateAgentQueueRequest

	// DissociateAgentQueueExecute executes the request
	DissociateAgentQueueExecute(r QueuesAPIDissociateAgentQueueRequest) (*http.Response, error)

	/*
		DissociateQueueExtension Dissociate queue and extension

		**Required ACL:** `confd.queues.{queue_id}.extensions.{extension_id}.delete`

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param queueId queue's ID
		@param extensionId
		@return QueuesAPIDissociateQueueExtensionRequest
	*/
	DissociateQueueExtension(ctx context.Context, queueId int32, extensionId int32) QueuesAPIDissociateQueueExtensionRequest

	// DissociateQueueExtensionExecute executes the request
	DissociateQueueExtensionExecute(r QueuesAPIDissociateQueueExtensionRequest) (*http.Response, error)

	/*
		DissociateQueueSchedule Dissociate queue and schedule

		**Required ACL:** `confd.queues.{queue_id}.schedules.{schedule_id}.delete`

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param queueId queue's ID
		@param scheduleId Schedule's ID
		@return QueuesAPIDissociateQueueScheduleRequest
	*/
	DissociateQueueSchedule(ctx context.Context, queueId int32, scheduleId int32) QueuesAPIDissociateQueueScheduleRequest

	// DissociateQueueScheduleExecute executes the request
	DissociateQueueScheduleExecute(r QueuesAPIDissociateQueueScheduleRequest) (*http.Response, error)

	/*
		DissociateUserQueue Dissociate user and queue

		**Required ACL:** `confd.queues.{queue_id}.members.users.{user_id}.delete`

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param queueId queue's ID
		@param userId the user's ID or UUID
		@return QueuesAPIDissociateUserQueueRequest
	*/
	DissociateUserQueue(ctx context.Context, queueId int32, userId string) QueuesAPIDissociateUserQueueRequest

	// DissociateUserQueueExecute executes the request
	DissociateUserQueueExecute(r QueuesAPIDissociateUserQueueRequest) (*http.Response, error)

	/*
		GetQueue Get queue

		**Required ACL:** `confd.queues.{queue_id}.read`

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param queueId queue's ID
		@return QueuesAPIGetQueueRequest
	*/
	GetQueue(ctx context.Context, queueId int32) QueuesAPIGetQueueRequest

	// GetQueueExecute executes the request
	//  @return Queue
	GetQueueExecute(r QueuesAPIGetQueueRequest) (*Queue, *http.Response, error)

	/*
		GetQueueFallback List all fallbacks for queue

		**Required ACL:** `confd.queues.{queue_id}.fallbacks.read`

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param queueId queue's ID
		@return QueuesAPIGetQueueFallbackRequest
	*/
	GetQueueFallback(ctx context.Context, queueId int32) QueuesAPIGetQueueFallbackRequest

	// GetQueueFallbackExecute executes the request
	//  @return QueueFallbacks
	GetQueueFallbackExecute(r QueuesAPIGetQueueFallbackRequest) (*QueueFallbacks, *http.Response, error)

	/*
		GetSkillRule Get skill rule

		**Required ACL:** `confd.queues.skillrules.{skillrule_id}.read`

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param skillruleId Skill's ID
		@return QueuesAPIGetSkillRuleRequest
	*/
	GetSkillRule(ctx context.Context, skillruleId int32) QueuesAPIGetSkillRuleRequest

	// GetSkillRuleExecute executes the request
	//  @return SkillRule
	GetSkillRuleExecute(r QueuesAPIGetSkillRuleRequest) (*SkillRule, *http.Response, error)

	/*
		ListQueues List queues

		**Required ACL:** `confd.queues.read`

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@return QueuesAPIListQueuesRequest
	*/
	ListQueues(ctx context.Context) QueuesAPIListQueuesRequest

	// ListQueuesExecute executes the request
	//  @return QueueItems
	ListQueuesExecute(r QueuesAPIListQueuesRequest) (*QueueItems, *http.Response, error)

	/*
		ListSkillRules List skill rule

		**Required ACL:** `confd.queues.skillrules.read`

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@return QueuesAPIListSkillRulesRequest
	*/
	ListSkillRules(ctx context.Context) QueuesAPIListSkillRulesRequest

	// ListSkillRulesExecute executes the request
	//  @return SkillRuleItems
	ListSkillRulesExecute(r QueuesAPIListSkillRulesRequest) (*SkillRuleItems, *http.Response, error)

	/*
		UpdateAgentQueueAssociation Update Agent-Queue association

		**Required ACL:** `confd.queues.{queue_id}.members.agents.{agent_id}.update`

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param queueId queue's ID
		@param agentId Agent’s ID
		@return QueuesAPIUpdateAgentQueueAssociationRequest
	*/
	UpdateAgentQueueAssociation(ctx context.Context, queueId int32, agentId int32) QueuesAPIUpdateAgentQueueAssociationRequest

	// UpdateAgentQueueAssociationExecute executes the request
	UpdateAgentQueueAssociationExecute(r QueuesAPIUpdateAgentQueueAssociationRequest) (*http.Response, error)

	/*
		UpdateQueue Update queue

		**Required ACL:** `confd.queues.{queue_id}.update`

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param queueId queue's ID
		@return QueuesAPIUpdateQueueRequest
	*/
	UpdateQueue(ctx context.Context, queueId int32) QueuesAPIUpdateQueueRequest

	// UpdateQueueExecute executes the request
	UpdateQueueExecute(r QueuesAPIUpdateQueueRequest) (*http.Response, error)

	/*
		UpdateQueueFallback Update queue's fallbacks

		**Required ACL:** `confd.queues.{queue_id}.fallbacks.update`

	**WARNING** This endpoint delete all fields that are not defined.

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param queueId queue's ID
		@return QueuesAPIUpdateQueueFallbackRequest
	*/
	UpdateQueueFallback(ctx context.Context, queueId int32) QueuesAPIUpdateQueueFallbackRequest

	// UpdateQueueFallbackExecute executes the request
	UpdateQueueFallbackExecute(r QueuesAPIUpdateQueueFallbackRequest) (*http.Response, error)

	/*
		UpdateSkillRule Update skill rule

		**Required ACL:** `confd.queues.skillrules.{skillrule_id}.update`

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param skillruleId Skill's ID
		@return QueuesAPIUpdateSkillRuleRequest
	*/
	UpdateSkillRule(ctx context.Context, skillruleId int32) QueuesAPIUpdateSkillRuleRequest

	// UpdateSkillRuleExecute executes the request
	UpdateSkillRuleExecute(r QueuesAPIUpdateSkillRuleRequest) (*http.Response, error)

	/*
		UpdateUserQueueAssociation Update User-Queue association

		**Required ACL:** `confd.queues.{queue_id}.members.users.{user_id}.update`

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param queueId queue's ID
		@param userId the user's ID or UUID
		@return QueuesAPIUpdateUserQueueAssociationRequest
	*/
	UpdateUserQueueAssociation(ctx context.Context, queueId int32, userId string) QueuesAPIUpdateUserQueueAssociationRequest

	// UpdateUserQueueAssociationExecute executes the request
	UpdateUserQueueAssociationExecute(r QueuesAPIUpdateUserQueueAssociationRequest) (*http.Response, error)
}

// QueuesAPIService QueuesAPI service
type QueuesAPIService service

type QueuesAPIAssociateQueueExtensionRequest struct {
	ctx          context.Context
	ApiService   QueuesAPI
	queueId      int32
	extensionId  int32
	accentTenant *string
}

// The tenant&#39;s UUID, defining the ownership of a given resource.
func (r QueuesAPIAssociateQueueExtensionRequest) AccentTenant(accentTenant string) QueuesAPIAssociateQueueExtensionRequest {
	r.accentTenant = &accentTenant
	return r
}

func (r QueuesAPIAssociateQueueExtensionRequest) Execute() (*http.Response, error) {
	return r.ApiService.AssociateQueueExtensionExecute(r)
}

/*
AssociateQueueExtension Associate queue and extension

**Required ACL:** `confd.queues.{queue_id}.extensions.{extension_id}.update`

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param queueId queue's ID
	@param extensionId
	@return QueuesAPIAssociateQueueExtensionRequest
*/
func (a *QueuesAPIService) AssociateQueueExtension(ctx context.Context, queueId int32, extensionId int32) QueuesAPIAssociateQueueExtensionRequest {
	return QueuesAPIAssociateQueueExtensionRequest{
		ApiService:  a,
		ctx:         ctx,
		queueId:     queueId,
		extensionId: extensionId,
	}
}

// Execute executes the request
func (a *QueuesAPIService) AssociateQueueExtensionExecute(r QueuesAPIAssociateQueueExtensionRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodPut
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "QueuesAPIService.AssociateQueueExtension")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/queues/{queue_id}/extensions/{extension_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"queue_id"+"}", url.PathEscape(parameterValueToString(r.queueId, "queueId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"extension_id"+"}", url.PathEscape(parameterValueToString(r.extensionId, "extensionId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.accentTenant != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accent-Tenant", r.accentTenant, "")
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["accent_auth_token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Auth-Token"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v []string
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v []string
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type QueuesAPIAssociateQueueScheduleRequest struct {
	ctx          context.Context
	ApiService   QueuesAPI
	queueId      int32
	scheduleId   int32
	accentTenant *string
}

// The tenant&#39;s UUID, defining the ownership of a given resource.
func (r QueuesAPIAssociateQueueScheduleRequest) AccentTenant(accentTenant string) QueuesAPIAssociateQueueScheduleRequest {
	r.accentTenant = &accentTenant
	return r
}

func (r QueuesAPIAssociateQueueScheduleRequest) Execute() (*http.Response, error) {
	return r.ApiService.AssociateQueueScheduleExecute(r)
}

/*
AssociateQueueSchedule Associate queue and schedule

**Required ACL:** `confd.queues.{queue_id}.schedules.{schedule_id}.update`

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param queueId queue's ID
	@param scheduleId Schedule's ID
	@return QueuesAPIAssociateQueueScheduleRequest
*/
func (a *QueuesAPIService) AssociateQueueSchedule(ctx context.Context, queueId int32, scheduleId int32) QueuesAPIAssociateQueueScheduleRequest {
	return QueuesAPIAssociateQueueScheduleRequest{
		ApiService: a,
		ctx:        ctx,
		queueId:    queueId,
		scheduleId: scheduleId,
	}
}

// Execute executes the request
func (a *QueuesAPIService) AssociateQueueScheduleExecute(r QueuesAPIAssociateQueueScheduleRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodPut
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "QueuesAPIService.AssociateQueueSchedule")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/queues/{queue_id}/schedules/{schedule_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"queue_id"+"}", url.PathEscape(parameterValueToString(r.queueId, "queueId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"schedule_id"+"}", url.PathEscape(parameterValueToString(r.scheduleId, "scheduleId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.accentTenant != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accent-Tenant", r.accentTenant, "")
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["accent_auth_token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Auth-Token"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v []string
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v []string
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type QueuesAPICreateQueueRequest struct {
	ctx          context.Context
	ApiService   QueuesAPI
	body         *Queue
	accentTenant *string
}

// Queue to create
func (r QueuesAPICreateQueueRequest) Body(body Queue) QueuesAPICreateQueueRequest {
	r.body = &body
	return r
}

// The tenant&#39;s UUID, defining the ownership of a given resource.
func (r QueuesAPICreateQueueRequest) AccentTenant(accentTenant string) QueuesAPICreateQueueRequest {
	r.accentTenant = &accentTenant
	return r
}

func (r QueuesAPICreateQueueRequest) Execute() (*Queue, *http.Response, error) {
	return r.ApiService.CreateQueueExecute(r)
}

/*
CreateQueue Create queue

**Required ACL:** `confd.queues.create`

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return QueuesAPICreateQueueRequest
*/
func (a *QueuesAPIService) CreateQueue(ctx context.Context) QueuesAPICreateQueueRequest {
	return QueuesAPICreateQueueRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return Queue
func (a *QueuesAPIService) CreateQueueExecute(r QueuesAPICreateQueueRequest) (*Queue, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *Queue
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "QueuesAPIService.CreateQueue")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/queues"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("body is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.accentTenant != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accent-Tenant", r.accentTenant, "")
	}
	// body params
	localVarPostBody = r.body
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["accent_auth_token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Auth-Token"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v []string
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type QueuesAPICreateSkillRuleRequest struct {
	ctx          context.Context
	ApiService   QueuesAPI
	body         *SkillRule
	accentTenant *string
}

// Skill rule to create
func (r QueuesAPICreateSkillRuleRequest) Body(body SkillRule) QueuesAPICreateSkillRuleRequest {
	r.body = &body
	return r
}

// The tenant&#39;s UUID, defining the ownership of a given resource.
func (r QueuesAPICreateSkillRuleRequest) AccentTenant(accentTenant string) QueuesAPICreateSkillRuleRequest {
	r.accentTenant = &accentTenant
	return r
}

func (r QueuesAPICreateSkillRuleRequest) Execute() (*SkillRule, *http.Response, error) {
	return r.ApiService.CreateSkillRuleExecute(r)
}

/*
CreateSkillRule Create skill rule

**Required ACL:** `confd.queues.skillrules.create`

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return QueuesAPICreateSkillRuleRequest
*/
func (a *QueuesAPIService) CreateSkillRule(ctx context.Context) QueuesAPICreateSkillRuleRequest {
	return QueuesAPICreateSkillRuleRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return SkillRule
func (a *QueuesAPIService) CreateSkillRuleExecute(r QueuesAPICreateSkillRuleRequest) (*SkillRule, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *SkillRule
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "QueuesAPIService.CreateSkillRule")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/queues/skillrules"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("body is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.accentTenant != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accent-Tenant", r.accentTenant, "")
	}
	// body params
	localVarPostBody = r.body
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["accent_auth_token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Auth-Token"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v []string
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type QueuesAPIDeleteQueueRequest struct {
	ctx          context.Context
	ApiService   QueuesAPI
	queueId      int32
	accentTenant *string
}

// The tenant&#39;s UUID, defining the ownership of a given resource.
func (r QueuesAPIDeleteQueueRequest) AccentTenant(accentTenant string) QueuesAPIDeleteQueueRequest {
	r.accentTenant = &accentTenant
	return r
}

func (r QueuesAPIDeleteQueueRequest) Execute() (*http.Response, error) {
	return r.ApiService.DeleteQueueExecute(r)
}

/*
DeleteQueue Delete queue

**Required ACL:** `confd.queues.{queue_id}.delete`

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param queueId queue's ID
	@return QueuesAPIDeleteQueueRequest
*/
func (a *QueuesAPIService) DeleteQueue(ctx context.Context, queueId int32) QueuesAPIDeleteQueueRequest {
	return QueuesAPIDeleteQueueRequest{
		ApiService: a,
		ctx:        ctx,
		queueId:    queueId,
	}
}

// Execute executes the request
func (a *QueuesAPIService) DeleteQueueExecute(r QueuesAPIDeleteQueueRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodDelete
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "QueuesAPIService.DeleteQueue")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/queues/{queue_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"queue_id"+"}", url.PathEscape(parameterValueToString(r.queueId, "queueId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.accentTenant != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accent-Tenant", r.accentTenant, "")
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["accent_auth_token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Auth-Token"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v []string
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v []string
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type QueuesAPIDeleteSkillRuleRequest struct {
	ctx          context.Context
	ApiService   QueuesAPI
	skillruleId  int32
	accentTenant *string
}

// The tenant&#39;s UUID, defining the ownership of a given resource.
func (r QueuesAPIDeleteSkillRuleRequest) AccentTenant(accentTenant string) QueuesAPIDeleteSkillRuleRequest {
	r.accentTenant = &accentTenant
	return r
}

func (r QueuesAPIDeleteSkillRuleRequest) Execute() (*http.Response, error) {
	return r.ApiService.DeleteSkillRuleExecute(r)
}

/*
DeleteSkillRule Delete skill rule

**Required ACL:** `confd.queues.skillrules.{skillrule_id}.delete`

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param skillruleId Skill's ID
	@return QueuesAPIDeleteSkillRuleRequest
*/
func (a *QueuesAPIService) DeleteSkillRule(ctx context.Context, skillruleId int32) QueuesAPIDeleteSkillRuleRequest {
	return QueuesAPIDeleteSkillRuleRequest{
		ApiService:  a,
		ctx:         ctx,
		skillruleId: skillruleId,
	}
}

// Execute executes the request
func (a *QueuesAPIService) DeleteSkillRuleExecute(r QueuesAPIDeleteSkillRuleRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodDelete
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "QueuesAPIService.DeleteSkillRule")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/queues/skillrules/{skillrule_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"skillrule_id"+"}", url.PathEscape(parameterValueToString(r.skillruleId, "skillruleId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.accentTenant != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accent-Tenant", r.accentTenant, "")
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["accent_auth_token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Auth-Token"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v []string
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v []string
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type QueuesAPIDissociateAgentQueueRequest struct {
	ctx          context.Context
	ApiService   QueuesAPI
	queueId      int32
	agentId      int32
	accentTenant *string
}

// The tenant&#39;s UUID, defining the ownership of a given resource.
func (r QueuesAPIDissociateAgentQueueRequest) AccentTenant(accentTenant string) QueuesAPIDissociateAgentQueueRequest {
	r.accentTenant = &accentTenant
	return r
}

func (r QueuesAPIDissociateAgentQueueRequest) Execute() (*http.Response, error) {
	return r.ApiService.DissociateAgentQueueExecute(r)
}

/*
DissociateAgentQueue Dissociate agent and queue

**Required ACL:** `confd.queues.{queue_id}.members.agents.{agent_id}.delete`

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param queueId queue's ID
	@param agentId Agent’s ID
	@return QueuesAPIDissociateAgentQueueRequest
*/
func (a *QueuesAPIService) DissociateAgentQueue(ctx context.Context, queueId int32, agentId int32) QueuesAPIDissociateAgentQueueRequest {
	return QueuesAPIDissociateAgentQueueRequest{
		ApiService: a,
		ctx:        ctx,
		queueId:    queueId,
		agentId:    agentId,
	}
}

// Execute executes the request
func (a *QueuesAPIService) DissociateAgentQueueExecute(r QueuesAPIDissociateAgentQueueRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodDelete
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "QueuesAPIService.DissociateAgentQueue")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/queues/{queue_id}/members/agents/{agent_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"queue_id"+"}", url.PathEscape(parameterValueToString(r.queueId, "queueId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"agent_id"+"}", url.PathEscape(parameterValueToString(r.agentId, "agentId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.accentTenant != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accent-Tenant", r.accentTenant, "")
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["accent_auth_token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Auth-Token"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v []string
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v []string
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type QueuesAPIDissociateQueueExtensionRequest struct {
	ctx          context.Context
	ApiService   QueuesAPI
	queueId      int32
	extensionId  int32
	accentTenant *string
}

// The tenant&#39;s UUID, defining the ownership of a given resource.
func (r QueuesAPIDissociateQueueExtensionRequest) AccentTenant(accentTenant string) QueuesAPIDissociateQueueExtensionRequest {
	r.accentTenant = &accentTenant
	return r
}

func (r QueuesAPIDissociateQueueExtensionRequest) Execute() (*http.Response, error) {
	return r.ApiService.DissociateQueueExtensionExecute(r)
}

/*
DissociateQueueExtension Dissociate queue and extension

**Required ACL:** `confd.queues.{queue_id}.extensions.{extension_id}.delete`

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param queueId queue's ID
	@param extensionId
	@return QueuesAPIDissociateQueueExtensionRequest
*/
func (a *QueuesAPIService) DissociateQueueExtension(ctx context.Context, queueId int32, extensionId int32) QueuesAPIDissociateQueueExtensionRequest {
	return QueuesAPIDissociateQueueExtensionRequest{
		ApiService:  a,
		ctx:         ctx,
		queueId:     queueId,
		extensionId: extensionId,
	}
}

// Execute executes the request
func (a *QueuesAPIService) DissociateQueueExtensionExecute(r QueuesAPIDissociateQueueExtensionRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodDelete
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "QueuesAPIService.DissociateQueueExtension")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/queues/{queue_id}/extensions/{extension_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"queue_id"+"}", url.PathEscape(parameterValueToString(r.queueId, "queueId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"extension_id"+"}", url.PathEscape(parameterValueToString(r.extensionId, "extensionId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.accentTenant != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accent-Tenant", r.accentTenant, "")
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["accent_auth_token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Auth-Token"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v []string
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v []string
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type QueuesAPIDissociateQueueScheduleRequest struct {
	ctx          context.Context
	ApiService   QueuesAPI
	queueId      int32
	scheduleId   int32
	accentTenant *string
}

// The tenant&#39;s UUID, defining the ownership of a given resource.
func (r QueuesAPIDissociateQueueScheduleRequest) AccentTenant(accentTenant string) QueuesAPIDissociateQueueScheduleRequest {
	r.accentTenant = &accentTenant
	return r
}

func (r QueuesAPIDissociateQueueScheduleRequest) Execute() (*http.Response, error) {
	return r.ApiService.DissociateQueueScheduleExecute(r)
}

/*
DissociateQueueSchedule Dissociate queue and schedule

**Required ACL:** `confd.queues.{queue_id}.schedules.{schedule_id}.delete`

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param queueId queue's ID
	@param scheduleId Schedule's ID
	@return QueuesAPIDissociateQueueScheduleRequest
*/
func (a *QueuesAPIService) DissociateQueueSchedule(ctx context.Context, queueId int32, scheduleId int32) QueuesAPIDissociateQueueScheduleRequest {
	return QueuesAPIDissociateQueueScheduleRequest{
		ApiService: a,
		ctx:        ctx,
		queueId:    queueId,
		scheduleId: scheduleId,
	}
}

// Execute executes the request
func (a *QueuesAPIService) DissociateQueueScheduleExecute(r QueuesAPIDissociateQueueScheduleRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodDelete
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "QueuesAPIService.DissociateQueueSchedule")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/queues/{queue_id}/schedules/{schedule_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"queue_id"+"}", url.PathEscape(parameterValueToString(r.queueId, "queueId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"schedule_id"+"}", url.PathEscape(parameterValueToString(r.scheduleId, "scheduleId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.accentTenant != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accent-Tenant", r.accentTenant, "")
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["accent_auth_token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Auth-Token"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v []string
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v []string
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type QueuesAPIDissociateUserQueueRequest struct {
	ctx          context.Context
	ApiService   QueuesAPI
	queueId      int32
	userId       string
	accentTenant *string
}

// The tenant&#39;s UUID, defining the ownership of a given resource.
func (r QueuesAPIDissociateUserQueueRequest) AccentTenant(accentTenant string) QueuesAPIDissociateUserQueueRequest {
	r.accentTenant = &accentTenant
	return r
}

func (r QueuesAPIDissociateUserQueueRequest) Execute() (*http.Response, error) {
	return r.ApiService.DissociateUserQueueExecute(r)
}

/*
DissociateUserQueue Dissociate user and queue

**Required ACL:** `confd.queues.{queue_id}.members.users.{user_id}.delete`

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param queueId queue's ID
	@param userId the user's ID or UUID
	@return QueuesAPIDissociateUserQueueRequest
*/
func (a *QueuesAPIService) DissociateUserQueue(ctx context.Context, queueId int32, userId string) QueuesAPIDissociateUserQueueRequest {
	return QueuesAPIDissociateUserQueueRequest{
		ApiService: a,
		ctx:        ctx,
		queueId:    queueId,
		userId:     userId,
	}
}

// Execute executes the request
func (a *QueuesAPIService) DissociateUserQueueExecute(r QueuesAPIDissociateUserQueueRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodDelete
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "QueuesAPIService.DissociateUserQueue")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/queues/{queue_id}/members/users/{user_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"queue_id"+"}", url.PathEscape(parameterValueToString(r.queueId, "queueId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"user_id"+"}", url.PathEscape(parameterValueToString(r.userId, "userId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.accentTenant != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accent-Tenant", r.accentTenant, "")
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["accent_auth_token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Auth-Token"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v []string
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v []string
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type QueuesAPIGetQueueRequest struct {
	ctx          context.Context
	ApiService   QueuesAPI
	queueId      int32
	accentTenant *string
}

// The tenant&#39;s UUID, defining the ownership of a given resource.
func (r QueuesAPIGetQueueRequest) AccentTenant(accentTenant string) QueuesAPIGetQueueRequest {
	r.accentTenant = &accentTenant
	return r
}

func (r QueuesAPIGetQueueRequest) Execute() (*Queue, *http.Response, error) {
	return r.ApiService.GetQueueExecute(r)
}

/*
GetQueue Get queue

**Required ACL:** `confd.queues.{queue_id}.read`

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param queueId queue's ID
	@return QueuesAPIGetQueueRequest
*/
func (a *QueuesAPIService) GetQueue(ctx context.Context, queueId int32) QueuesAPIGetQueueRequest {
	return QueuesAPIGetQueueRequest{
		ApiService: a,
		ctx:        ctx,
		queueId:    queueId,
	}
}

// Execute executes the request
//
//	@return Queue
func (a *QueuesAPIService) GetQueueExecute(r QueuesAPIGetQueueRequest) (*Queue, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *Queue
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "QueuesAPIService.GetQueue")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/queues/{queue_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"queue_id"+"}", url.PathEscape(parameterValueToString(r.queueId, "queueId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.accentTenant != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accent-Tenant", r.accentTenant, "")
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["accent_auth_token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Auth-Token"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v []string
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type QueuesAPIGetQueueFallbackRequest struct {
	ctx          context.Context
	ApiService   QueuesAPI
	queueId      int32
	accentTenant *string
}

// The tenant&#39;s UUID, defining the ownership of a given resource.
func (r QueuesAPIGetQueueFallbackRequest) AccentTenant(accentTenant string) QueuesAPIGetQueueFallbackRequest {
	r.accentTenant = &accentTenant
	return r
}

func (r QueuesAPIGetQueueFallbackRequest) Execute() (*QueueFallbacks, *http.Response, error) {
	return r.ApiService.GetQueueFallbackExecute(r)
}

/*
GetQueueFallback List all fallbacks for queue

**Required ACL:** `confd.queues.{queue_id}.fallbacks.read`

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param queueId queue's ID
	@return QueuesAPIGetQueueFallbackRequest
*/
func (a *QueuesAPIService) GetQueueFallback(ctx context.Context, queueId int32) QueuesAPIGetQueueFallbackRequest {
	return QueuesAPIGetQueueFallbackRequest{
		ApiService: a,
		ctx:        ctx,
		queueId:    queueId,
	}
}

// Execute executes the request
//
//	@return QueueFallbacks
func (a *QueuesAPIService) GetQueueFallbackExecute(r QueuesAPIGetQueueFallbackRequest) (*QueueFallbacks, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *QueueFallbacks
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "QueuesAPIService.GetQueueFallback")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/queues/{queue_id}/fallbacks"
	localVarPath = strings.Replace(localVarPath, "{"+"queue_id"+"}", url.PathEscape(parameterValueToString(r.queueId, "queueId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.accentTenant != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accent-Tenant", r.accentTenant, "")
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["accent_auth_token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Auth-Token"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type QueuesAPIGetSkillRuleRequest struct {
	ctx          context.Context
	ApiService   QueuesAPI
	skillruleId  int32
	accentTenant *string
}

// The tenant&#39;s UUID, defining the ownership of a given resource.
func (r QueuesAPIGetSkillRuleRequest) AccentTenant(accentTenant string) QueuesAPIGetSkillRuleRequest {
	r.accentTenant = &accentTenant
	return r
}

func (r QueuesAPIGetSkillRuleRequest) Execute() (*SkillRule, *http.Response, error) {
	return r.ApiService.GetSkillRuleExecute(r)
}

/*
GetSkillRule Get skill rule

**Required ACL:** `confd.queues.skillrules.{skillrule_id}.read`

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param skillruleId Skill's ID
	@return QueuesAPIGetSkillRuleRequest
*/
func (a *QueuesAPIService) GetSkillRule(ctx context.Context, skillruleId int32) QueuesAPIGetSkillRuleRequest {
	return QueuesAPIGetSkillRuleRequest{
		ApiService:  a,
		ctx:         ctx,
		skillruleId: skillruleId,
	}
}

// Execute executes the request
//
//	@return SkillRule
func (a *QueuesAPIService) GetSkillRuleExecute(r QueuesAPIGetSkillRuleRequest) (*SkillRule, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *SkillRule
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "QueuesAPIService.GetSkillRule")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/queues/skillrules/{skillrule_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"skillrule_id"+"}", url.PathEscape(parameterValueToString(r.skillruleId, "skillruleId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.accentTenant != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accent-Tenant", r.accentTenant, "")
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["accent_auth_token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Auth-Token"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v []string
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type QueuesAPIListQueuesRequest struct {
	ctx          context.Context
	ApiService   QueuesAPI
	accentTenant *string
	recurse      *bool
	order        *string
	direction    *string
	limit        *int32
	offset       *int32
	search       *string
}

// The tenant&#39;s UUID, defining the ownership of a given resource.
func (r QueuesAPIListQueuesRequest) AccentTenant(accentTenant string) QueuesAPIListQueuesRequest {
	r.accentTenant = &accentTenant
	return r
}

// Should the query include sub-tenants
func (r QueuesAPIListQueuesRequest) Recurse(recurse bool) QueuesAPIListQueuesRequest {
	r.recurse = &recurse
	return r
}

// Name of the field to use for sorting the list of items returned.
func (r QueuesAPIListQueuesRequest) Order(order string) QueuesAPIListQueuesRequest {
	r.order = &order
	return r
}

// Sort list of items in &#39;asc&#39; (ascending) or &#39;desc&#39; (descending) order
func (r QueuesAPIListQueuesRequest) Direction(direction string) QueuesAPIListQueuesRequest {
	r.direction = &direction
	return r
}

// Maximum number of items to return in the list
func (r QueuesAPIListQueuesRequest) Limit(limit int32) QueuesAPIListQueuesRequest {
	r.limit = &limit
	return r
}

// Number of items to skip over in the list. Useful for pagination.
func (r QueuesAPIListQueuesRequest) Offset(offset int32) QueuesAPIListQueuesRequest {
	r.offset = &offset
	return r
}

// Search term for filtering a list of items. Only items with a field containing the search term will be returned.
func (r QueuesAPIListQueuesRequest) Search(search string) QueuesAPIListQueuesRequest {
	r.search = &search
	return r
}

func (r QueuesAPIListQueuesRequest) Execute() (*QueueItems, *http.Response, error) {
	return r.ApiService.ListQueuesExecute(r)
}

/*
ListQueues List queues

**Required ACL:** `confd.queues.read`

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return QueuesAPIListQueuesRequest
*/
func (a *QueuesAPIService) ListQueues(ctx context.Context) QueuesAPIListQueuesRequest {
	return QueuesAPIListQueuesRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return QueueItems
func (a *QueuesAPIService) ListQueuesExecute(r QueuesAPIListQueuesRequest) (*QueueItems, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *QueueItems
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "QueuesAPIService.ListQueues")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/queues"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.recurse != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "recurse", r.recurse, "")
	} else {
		var defaultValue bool = false
		r.recurse = &defaultValue
	}
	if r.order != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "order", r.order, "")
	}
	if r.direction != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "direction", r.direction, "")
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "")
	}
	if r.offset != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "offset", r.offset, "")
	}
	if r.search != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "search", r.search, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.accentTenant != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accent-Tenant", r.accentTenant, "")
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["accent_auth_token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Auth-Token"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type QueuesAPIListSkillRulesRequest struct {
	ctx          context.Context
	ApiService   QueuesAPI
	accentTenant *string
	recurse      *bool
	order        *string
	direction    *string
	limit        *int32
	offset       *int32
	search       *string
}

// The tenant&#39;s UUID, defining the ownership of a given resource.
func (r QueuesAPIListSkillRulesRequest) AccentTenant(accentTenant string) QueuesAPIListSkillRulesRequest {
	r.accentTenant = &accentTenant
	return r
}

// Should the query include sub-tenants
func (r QueuesAPIListSkillRulesRequest) Recurse(recurse bool) QueuesAPIListSkillRulesRequest {
	r.recurse = &recurse
	return r
}

// Name of the field to use for sorting the list of items returned.
func (r QueuesAPIListSkillRulesRequest) Order(order string) QueuesAPIListSkillRulesRequest {
	r.order = &order
	return r
}

// Sort list of items in &#39;asc&#39; (ascending) or &#39;desc&#39; (descending) order
func (r QueuesAPIListSkillRulesRequest) Direction(direction string) QueuesAPIListSkillRulesRequest {
	r.direction = &direction
	return r
}

// Maximum number of items to return in the list
func (r QueuesAPIListSkillRulesRequest) Limit(limit int32) QueuesAPIListSkillRulesRequest {
	r.limit = &limit
	return r
}

// Number of items to skip over in the list. Useful for pagination.
func (r QueuesAPIListSkillRulesRequest) Offset(offset int32) QueuesAPIListSkillRulesRequest {
	r.offset = &offset
	return r
}

// Search term for filtering a list of items. Only items with a field containing the search term will be returned.
func (r QueuesAPIListSkillRulesRequest) Search(search string) QueuesAPIListSkillRulesRequest {
	r.search = &search
	return r
}

func (r QueuesAPIListSkillRulesRequest) Execute() (*SkillRuleItems, *http.Response, error) {
	return r.ApiService.ListSkillRulesExecute(r)
}

/*
ListSkillRules List skill rule

**Required ACL:** `confd.queues.skillrules.read`

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return QueuesAPIListSkillRulesRequest
*/
func (a *QueuesAPIService) ListSkillRules(ctx context.Context) QueuesAPIListSkillRulesRequest {
	return QueuesAPIListSkillRulesRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return SkillRuleItems
func (a *QueuesAPIService) ListSkillRulesExecute(r QueuesAPIListSkillRulesRequest) (*SkillRuleItems, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *SkillRuleItems
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "QueuesAPIService.ListSkillRules")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/queues/skillrules"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.recurse != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "recurse", r.recurse, "")
	} else {
		var defaultValue bool = false
		r.recurse = &defaultValue
	}
	if r.order != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "order", r.order, "")
	}
	if r.direction != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "direction", r.direction, "")
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "")
	}
	if r.offset != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "offset", r.offset, "")
	}
	if r.search != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "search", r.search, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.accentTenant != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accent-Tenant", r.accentTenant, "")
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["accent_auth_token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Auth-Token"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type QueuesAPIUpdateAgentQueueAssociationRequest struct {
	ctx          context.Context
	ApiService   QueuesAPI
	queueId      int32
	agentId      int32
	body         *QueueMemberAgent
	accentTenant *string
}

func (r QueuesAPIUpdateAgentQueueAssociationRequest) Body(body QueueMemberAgent) QueuesAPIUpdateAgentQueueAssociationRequest {
	r.body = &body
	return r
}

// The tenant&#39;s UUID, defining the ownership of a given resource.
func (r QueuesAPIUpdateAgentQueueAssociationRequest) AccentTenant(accentTenant string) QueuesAPIUpdateAgentQueueAssociationRequest {
	r.accentTenant = &accentTenant
	return r
}

func (r QueuesAPIUpdateAgentQueueAssociationRequest) Execute() (*http.Response, error) {
	return r.ApiService.UpdateAgentQueueAssociationExecute(r)
}

/*
UpdateAgentQueueAssociation Update Agent-Queue association

**Required ACL:** `confd.queues.{queue_id}.members.agents.{agent_id}.update`

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param queueId queue's ID
	@param agentId Agent’s ID
	@return QueuesAPIUpdateAgentQueueAssociationRequest
*/
func (a *QueuesAPIService) UpdateAgentQueueAssociation(ctx context.Context, queueId int32, agentId int32) QueuesAPIUpdateAgentQueueAssociationRequest {
	return QueuesAPIUpdateAgentQueueAssociationRequest{
		ApiService: a,
		ctx:        ctx,
		queueId:    queueId,
		agentId:    agentId,
	}
}

// Execute executes the request
func (a *QueuesAPIService) UpdateAgentQueueAssociationExecute(r QueuesAPIUpdateAgentQueueAssociationRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodPut
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "QueuesAPIService.UpdateAgentQueueAssociation")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/queues/{queue_id}/members/agents/{agent_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"queue_id"+"}", url.PathEscape(parameterValueToString(r.queueId, "queueId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"agent_id"+"}", url.PathEscape(parameterValueToString(r.agentId, "agentId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.accentTenant != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accent-Tenant", r.accentTenant, "")
	}
	// body params
	localVarPostBody = r.body
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["accent_auth_token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Auth-Token"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v []string
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v []string
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type QueuesAPIUpdateQueueRequest struct {
	ctx          context.Context
	ApiService   QueuesAPI
	body         *Queue
	queueId      int32
	accentTenant *string
}

func (r QueuesAPIUpdateQueueRequest) Body(body Queue) QueuesAPIUpdateQueueRequest {
	r.body = &body
	return r
}

// The tenant&#39;s UUID, defining the ownership of a given resource.
func (r QueuesAPIUpdateQueueRequest) AccentTenant(accentTenant string) QueuesAPIUpdateQueueRequest {
	r.accentTenant = &accentTenant
	return r
}

func (r QueuesAPIUpdateQueueRequest) Execute() (*http.Response, error) {
	return r.ApiService.UpdateQueueExecute(r)
}

/*
UpdateQueue Update queue

**Required ACL:** `confd.queues.{queue_id}.update`

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param queueId queue's ID
	@return QueuesAPIUpdateQueueRequest
*/
func (a *QueuesAPIService) UpdateQueue(ctx context.Context, queueId int32) QueuesAPIUpdateQueueRequest {
	return QueuesAPIUpdateQueueRequest{
		ApiService: a,
		ctx:        ctx,
		queueId:    queueId,
	}
}

// Execute executes the request
func (a *QueuesAPIService) UpdateQueueExecute(r QueuesAPIUpdateQueueRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodPut
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "QueuesAPIService.UpdateQueue")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/queues/{queue_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"queue_id"+"}", url.PathEscape(parameterValueToString(r.queueId, "queueId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return nil, reportError("body is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.accentTenant != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accent-Tenant", r.accentTenant, "")
	}
	// body params
	localVarPostBody = r.body
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["accent_auth_token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Auth-Token"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v []string
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v []string
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type QueuesAPIUpdateQueueFallbackRequest struct {
	ctx          context.Context
	ApiService   QueuesAPI
	queueId      int32
	body         *QueueFallbacks
	accentTenant *string
}

// Fallbacks for queue
func (r QueuesAPIUpdateQueueFallbackRequest) Body(body QueueFallbacks) QueuesAPIUpdateQueueFallbackRequest {
	r.body = &body
	return r
}

// The tenant&#39;s UUID, defining the ownership of a given resource.
func (r QueuesAPIUpdateQueueFallbackRequest) AccentTenant(accentTenant string) QueuesAPIUpdateQueueFallbackRequest {
	r.accentTenant = &accentTenant
	return r
}

func (r QueuesAPIUpdateQueueFallbackRequest) Execute() (*http.Response, error) {
	return r.ApiService.UpdateQueueFallbackExecute(r)
}

/*
UpdateQueueFallback Update queue's fallbacks

**Required ACL:** `confd.queues.{queue_id}.fallbacks.update`

**WARNING** This endpoint delete all fields that are not defined.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param queueId queue's ID
	@return QueuesAPIUpdateQueueFallbackRequest
*/
func (a *QueuesAPIService) UpdateQueueFallback(ctx context.Context, queueId int32) QueuesAPIUpdateQueueFallbackRequest {
	return QueuesAPIUpdateQueueFallbackRequest{
		ApiService: a,
		ctx:        ctx,
		queueId:    queueId,
	}
}

// Execute executes the request
func (a *QueuesAPIService) UpdateQueueFallbackExecute(r QueuesAPIUpdateQueueFallbackRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodPut
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "QueuesAPIService.UpdateQueueFallback")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/queues/{queue_id}/fallbacks"
	localVarPath = strings.Replace(localVarPath, "{"+"queue_id"+"}", url.PathEscape(parameterValueToString(r.queueId, "queueId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.accentTenant != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accent-Tenant", r.accentTenant, "")
	}
	// body params
	localVarPostBody = r.body
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["accent_auth_token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Auth-Token"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v []string
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v []string
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type QueuesAPIUpdateSkillRuleRequest struct {
	ctx          context.Context
	ApiService   QueuesAPI
	body         *SkillRule
	skillruleId  int32
	accentTenant *string
}

func (r QueuesAPIUpdateSkillRuleRequest) Body(body SkillRule) QueuesAPIUpdateSkillRuleRequest {
	r.body = &body
	return r
}

// The tenant&#39;s UUID, defining the ownership of a given resource.
func (r QueuesAPIUpdateSkillRuleRequest) AccentTenant(accentTenant string) QueuesAPIUpdateSkillRuleRequest {
	r.accentTenant = &accentTenant
	return r
}

func (r QueuesAPIUpdateSkillRuleRequest) Execute() (*http.Response, error) {
	return r.ApiService.UpdateSkillRuleExecute(r)
}

/*
UpdateSkillRule Update skill rule

**Required ACL:** `confd.queues.skillrules.{skillrule_id}.update`

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param skillruleId Skill's ID
	@return QueuesAPIUpdateSkillRuleRequest
*/
func (a *QueuesAPIService) UpdateSkillRule(ctx context.Context, skillruleId int32) QueuesAPIUpdateSkillRuleRequest {
	return QueuesAPIUpdateSkillRuleRequest{
		ApiService:  a,
		ctx:         ctx,
		skillruleId: skillruleId,
	}
}

// Execute executes the request
func (a *QueuesAPIService) UpdateSkillRuleExecute(r QueuesAPIUpdateSkillRuleRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodPut
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "QueuesAPIService.UpdateSkillRule")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/queues/skillrules/{skillrule_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"skillrule_id"+"}", url.PathEscape(parameterValueToString(r.skillruleId, "skillruleId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return nil, reportError("body is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.accentTenant != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accent-Tenant", r.accentTenant, "")
	}
	// body params
	localVarPostBody = r.body
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["accent_auth_token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Auth-Token"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v []string
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v []string
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type QueuesAPIUpdateUserQueueAssociationRequest struct {
	ctx          context.Context
	ApiService   QueuesAPI
	queueId      int32
	userId       string
	body         *QueueMemberUser
	accentTenant *string
}

func (r QueuesAPIUpdateUserQueueAssociationRequest) Body(body QueueMemberUser) QueuesAPIUpdateUserQueueAssociationRequest {
	r.body = &body
	return r
}

// The tenant&#39;s UUID, defining the ownership of a given resource.
func (r QueuesAPIUpdateUserQueueAssociationRequest) AccentTenant(accentTenant string) QueuesAPIUpdateUserQueueAssociationRequest {
	r.accentTenant = &accentTenant
	return r
}

func (r QueuesAPIUpdateUserQueueAssociationRequest) Execute() (*http.Response, error) {
	return r.ApiService.UpdateUserQueueAssociationExecute(r)
}

/*
UpdateUserQueueAssociation Update User-Queue association

**Required ACL:** `confd.queues.{queue_id}.members.users.{user_id}.update`

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param queueId queue's ID
	@param userId the user's ID or UUID
	@return QueuesAPIUpdateUserQueueAssociationRequest
*/
func (a *QueuesAPIService) UpdateUserQueueAssociation(ctx context.Context, queueId int32, userId string) QueuesAPIUpdateUserQueueAssociationRequest {
	return QueuesAPIUpdateUserQueueAssociationRequest{
		ApiService: a,
		ctx:        ctx,
		queueId:    queueId,
		userId:     userId,
	}
}

// Execute executes the request
func (a *QueuesAPIService) UpdateUserQueueAssociationExecute(r QueuesAPIUpdateUserQueueAssociationRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodPut
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "QueuesAPIService.UpdateUserQueueAssociation")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/queues/{queue_id}/members/users/{user_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"queue_id"+"}", url.PathEscape(parameterValueToString(r.queueId, "queueId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"user_id"+"}", url.PathEscape(parameterValueToString(r.userId, "userId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.accentTenant != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accent-Tenant", r.accentTenant, "")
	}
	// body params
	localVarPostBody = r.body
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["accent_auth_token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Auth-Token"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v []string
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v []string
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

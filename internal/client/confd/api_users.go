/*
accent-confd

Confd exposes an API for managing core resources on a Accent server such as users, extensions, devices, voicemails, queues, etc. Resources can be associated together to provide additional functionality. For example: By associating a voicemail with a user, calls will automatically fallback on to the voicemail when the user cannot answer.  Implementation notes ====================  Errors ------  Responses containing errors will have a status code in the 400 or 500 class. A list of error messages will be returned in the body of the response as a JSON-encoded array:  ~~~ [     \"Input error - User not found\",     \"Resource error - User not associated to a line\" ] ~~~   Updating resources via PUT --------------------------  When updating a resource, all fields become optional. In other words, only values that have been changed need to be sent to the server. Please note that this behavior may change in future versions of the API.

API version: 1.1
Contact: help@accentvoice.io
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package confd

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"strings"
)

type UsersAPI interface {

	/*
		AssociateUserAgent Associate user and agent

		**Required ACL:** `confd.users.{user_id}.agents.{agent_id}.update`

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param userId the user's ID or UUID
		@param agentId Agentâ€™s ID
		@return UsersAPIAssociateUserAgentRequest
	*/
	AssociateUserAgent(ctx context.Context, userId string, agentId int32) UsersAPIAssociateUserAgentRequest

	// AssociateUserAgentExecute executes the request
	AssociateUserAgentExecute(r UsersAPIAssociateUserAgentRequest) (*http.Response, error)

	/*
		AssociateUserCallpermission Associate user and call permission

		**Required ACL:** `confd.users.{user_id}.callpermissions.{call_permission_id}.update`

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param userId the user's ID or UUID
		@param callpermissionId Call Permission's ID
		@return UsersAPIAssociateUserCallpermissionRequest
	*/
	AssociateUserCallpermission(ctx context.Context, userId string, callpermissionId int32) UsersAPIAssociateUserCallpermissionRequest

	// AssociateUserCallpermissionExecute executes the request
	AssociateUserCallpermissionExecute(r UsersAPIAssociateUserCallpermissionRequest) (*http.Response, error)

	/*
		AssociateUserFuncKeyTemplate Associate a func key template to a user

		**Required ACL:** `confd.users.{user_id}.funckeys.templates.{template_id}.update`

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param userId the user's ID or UUID
		@param templateId
		@return UsersAPIAssociateUserFuncKeyTemplateRequest
	*/
	AssociateUserFuncKeyTemplate(ctx context.Context, userId string, templateId int32) UsersAPIAssociateUserFuncKeyTemplateRequest

	// AssociateUserFuncKeyTemplateExecute executes the request
	AssociateUserFuncKeyTemplateExecute(r UsersAPIAssociateUserFuncKeyTemplateRequest) (*http.Response, error)

	/*
		AssociateUserLine Associate user and line

		**Required ACL:** `confd.users.{user_id}.lines.{line_id}.update`

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param userId the user's ID or UUID
		@param lineId
		@return UsersAPIAssociateUserLineRequest
	*/
	AssociateUserLine(ctx context.Context, userId string, lineId int32) UsersAPIAssociateUserLineRequest

	// AssociateUserLineExecute executes the request
	AssociateUserLineExecute(r UsersAPIAssociateUserLineRequest) (*http.Response, error)

	/*
		AssociateUserLines Associate user and lines

		**Required ACL:** `confd.users.{user_id}.lines.update`

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param userId the user's ID or UUID
		@return UsersAPIAssociateUserLinesRequest
	*/
	AssociateUserLines(ctx context.Context, userId string) UsersAPIAssociateUserLinesRequest

	// AssociateUserLinesExecute executes the request
	AssociateUserLinesExecute(r UsersAPIAssociateUserLinesRequest) (*http.Response, error)

	/*
		AssociateUserSchedule Associate user and schedule

		**Required ACL:** `confd.users.{user_id}.schedules.{schedule_id}.update`

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param userId the user's ID or UUID
		@param scheduleId Schedule's ID
		@return UsersAPIAssociateUserScheduleRequest
	*/
	AssociateUserSchedule(ctx context.Context, userId string, scheduleId int32) UsersAPIAssociateUserScheduleRequest

	// AssociateUserScheduleExecute executes the request
	AssociateUserScheduleExecute(r UsersAPIAssociateUserScheduleRequest) (*http.Response, error)

	/*
		AssociateUserVoicemail Associate user and voicemail

		**Required ACL:** `confd.users.{user_id}.voicemails.{voicemail_id}.update`

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param userId the user's ID or UUID
		@param voicemailId
		@return UsersAPIAssociateUserVoicemailRequest
	*/
	AssociateUserVoicemail(ctx context.Context, userId string, voicemailId int32) UsersAPIAssociateUserVoicemailRequest

	// AssociateUserVoicemailExecute executes the request
	AssociateUserVoicemailExecute(r UsersAPIAssociateUserVoicemailRequest) (*http.Response, error)

	/*
		CreateUser Create user

		**Required ACL:** `confd.users.create`

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@return UsersAPICreateUserRequest
	*/
	CreateUser(ctx context.Context) UsersAPICreateUserRequest

	// CreateUserExecute executes the request
	//  @return UserPostResponse
	CreateUserExecute(r UsersAPICreateUserRequest) (*UserPostResponse, *http.Response, error)

	/*
		CreateUserExternalApp Create user external app

		**Required ACL:** `confd.users.{user_uuid}.external.apps.{app_name}.create`

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param userUuid the user's UUID
		@param appName External App's name
		@return UsersAPICreateUserExternalAppRequest
	*/
	CreateUserExternalApp(ctx context.Context, userUuid string, appName string) UsersAPICreateUserExternalAppRequest

	// CreateUserExternalAppExecute executes the request
	//  @return UserExternalApp
	CreateUserExternalAppExecute(r UsersAPICreateUserExternalAppRequest) (*UserExternalApp, *http.Response, error)

	/*
		CreateUserMeeting Create user meeting

		**Required ACL:** `confd.users.me.meetings.create`

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@return UsersAPICreateUserMeetingRequest
	*/
	CreateUserMeeting(ctx context.Context) UsersAPICreateUserMeetingRequest

	// CreateUserMeetingExecute executes the request
	//  @return Meeting
	CreateUserMeetingExecute(r UsersAPICreateUserMeetingRequest) (*Meeting, *http.Response, error)

	/*
		CreateUserVoicemail Create user voicemail

		**Required ACL:** `confd.users.{user_id}.voicemails.create`

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param userId the user's ID or UUID
		@return UsersAPICreateUserVoicemailRequest
	*/
	CreateUserVoicemail(ctx context.Context, userId string) UsersAPICreateUserVoicemailRequest

	// CreateUserVoicemailExecute executes the request
	//  @return Voicemail
	CreateUserVoicemailExecute(r UsersAPICreateUserVoicemailRequest) (*Voicemail, *http.Response, error)

	/*
		DeleteUser Delete user

		**Required ACL:** `confd.users.{user_id}.delete`

	A user can not be deleted if he is associated to a line or a voicemail. Any line or voicemail attached to the user must be dissociated first. The user will also be removed from all queues, groups or other Accent entities whom he is member.

	**Disclaimer**: if `recursive=true`, the user is deleted, all their associations with any related resources are removed, and some resources (lines, extensions, incalls and auth user) are deleted too.

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param userId the user's ID or UUID
		@return UsersAPIDeleteUserRequest
	*/
	DeleteUser(ctx context.Context, userId string) UsersAPIDeleteUserRequest

	// DeleteUserExecute executes the request
	DeleteUserExecute(r UsersAPIDeleteUserRequest) (*http.Response, error)

	/*
		DeleteUserExternalApp Delete user external app

		**Required ACL:** `confd.users.{user_uuid}.external.apps.{app_name}.delete`

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param userUuid the user's UUID
		@param appName External App's name
		@return UsersAPIDeleteUserExternalAppRequest
	*/
	DeleteUserExternalApp(ctx context.Context, userUuid string, appName string) UsersAPIDeleteUserExternalAppRequest

	// DeleteUserExternalAppExecute executes the request
	DeleteUserExternalAppExecute(r UsersAPIDeleteUserExternalAppRequest) (*http.Response, error)

	/*
		DeleteUserFuncKey Remove func key for user

		**Required ACL:** `confd.users.{user_id}.funckeys.{position}.delete`

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param userId the user's ID or UUID
		@param position position of the funckey
		@return UsersAPIDeleteUserFuncKeyRequest
	*/
	DeleteUserFuncKey(ctx context.Context, userId string, position int32) UsersAPIDeleteUserFuncKeyRequest

	// DeleteUserFuncKeyExecute executes the request
	DeleteUserFuncKeyExecute(r UsersAPIDeleteUserFuncKeyRequest) (*http.Response, error)

	/*
		DeleteUserMeeting Delete one of the meetings of the current user

		**Required ACL:** `confd.users.me.meetings.{meeting_uuid}.delete`

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param meetingUuid Meeting UUID
		@return UsersAPIDeleteUserMeetingRequest
	*/
	DeleteUserMeeting(ctx context.Context, meetingUuid string) UsersAPIDeleteUserMeetingRequest

	// DeleteUserMeetingExecute executes the request
	DeleteUserMeetingExecute(r UsersAPIDeleteUserMeetingRequest) (*http.Response, error)

	/*
		DissociateUserAgent Dissociate user and agent

		**Required ACL:** `confd.users.{user_id}.agents.delete`

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param userId the user's ID or UUID
		@return UsersAPIDissociateUserAgentRequest
	*/
	DissociateUserAgent(ctx context.Context, userId string) UsersAPIDissociateUserAgentRequest

	// DissociateUserAgentExecute executes the request
	DissociateUserAgentExecute(r UsersAPIDissociateUserAgentRequest) (*http.Response, error)

	/*
		DissociateUserCallpermission Dissociate user and call permission

		**Required ACL:** `confd.users.{user_id}.callpermissions.{call_permission_id}.delete`

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param userId the user's ID or UUID
		@param callpermissionId Call Permission's ID
		@return UsersAPIDissociateUserCallpermissionRequest
	*/
	DissociateUserCallpermission(ctx context.Context, userId string, callpermissionId int32) UsersAPIDissociateUserCallpermissionRequest

	// DissociateUserCallpermissionExecute executes the request
	DissociateUserCallpermissionExecute(r UsersAPIDissociateUserCallpermissionRequest) (*http.Response, error)

	/*
		DissociateUserFuncKeyTemplate Dissociate a func key template to a user

		**Required ACL:** `confd.users.{user_id}.funckeys.templates.{template_id}.delete`

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param userId the user's ID or UUID
		@param templateId
		@return UsersAPIDissociateUserFuncKeyTemplateRequest
	*/
	DissociateUserFuncKeyTemplate(ctx context.Context, userId string, templateId int32) UsersAPIDissociateUserFuncKeyTemplateRequest

	// DissociateUserFuncKeyTemplateExecute executes the request
	DissociateUserFuncKeyTemplateExecute(r UsersAPIDissociateUserFuncKeyTemplateRequest) (*http.Response, error)

	/*
		DissociateUserLine Dissociate user and line

		**Required ACL:** `confd.users.{user_id}.lines.{line_id}.delete`

	Any devices that are attached the line must be removed before dissociating a user from its line. A device can be dissociated be resetting it to autoprov mode.

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param userId the user's ID or UUID
		@param lineId
		@return UsersAPIDissociateUserLineRequest
	*/
	DissociateUserLine(ctx context.Context, userId string, lineId int32) UsersAPIDissociateUserLineRequest

	// DissociateUserLineExecute executes the request
	DissociateUserLineExecute(r UsersAPIDissociateUserLineRequest) (*http.Response, error)

	/*
		DissociateUserQueue Dissociate user and queue

		**Required ACL:** `confd.queues.{queue_id}.members.users.{user_id}.delete`

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param queueId queue's ID
		@param userId the user's ID or UUID
		@return UsersAPIDissociateUserQueueRequest
	*/
	DissociateUserQueue(ctx context.Context, queueId int32, userId string) UsersAPIDissociateUserQueueRequest

	// DissociateUserQueueExecute executes the request
	DissociateUserQueueExecute(r UsersAPIDissociateUserQueueRequest) (*http.Response, error)

	/*
		DissociateUserSchedule Dissociate user and schedule

		**Required ACL:** `confd.users.{user_id}.schedules.{schedule_id}.delete`

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param userId the user's ID or UUID
		@param scheduleId Schedule's ID
		@return UsersAPIDissociateUserScheduleRequest
	*/
	DissociateUserSchedule(ctx context.Context, userId string, scheduleId int32) UsersAPIDissociateUserScheduleRequest

	// DissociateUserScheduleExecute executes the request
	DissociateUserScheduleExecute(r UsersAPIDissociateUserScheduleRequest) (*http.Response, error)

	/*
		DissociateUserVoicemail Dissociate user and voicemail

		**Required ACL:** `confd.users.{user_id}.voicemails.delete`

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param userId the user's ID or UUID
		@return UsersAPIDissociateUserVoicemailRequest
	*/
	DissociateUserVoicemail(ctx context.Context, userId string) UsersAPIDissociateUserVoicemailRequest

	// DissociateUserVoicemailExecute executes the request
	DissociateUserVoicemailExecute(r UsersAPIDissociateUserVoicemailRequest) (*http.Response, error)

	/*
		ExportUsersCsv Mass export users and associated resources

		**Required ACL:** `confd.users.export.read`

	CSV field list available at https://accentvoice.io/uc-doc/administration/users/csv_import

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@return UsersAPIExportUsersCsvRequest
	*/
	ExportUsersCsv(ctx context.Context) UsersAPIExportUsersCsvRequest

	// ExportUsersCsvExecute executes the request
	//  @return string
	ExportUsersCsvExecute(r UsersAPIExportUsersCsvRequest) (string, *http.Response, error)

	/*
		GetUser Get user

		**Required ACL:** `confd.users.{user_id}.read`

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param userId the user's ID or UUID
		@return UsersAPIGetUserRequest
	*/
	GetUser(ctx context.Context, userId string) UsersAPIGetUserRequest

	// GetUserExecute executes the request
	//  @return User
	GetUserExecute(r UsersAPIGetUserRequest) (*User, *http.Response, error)

	/*
		GetUserExternalApp Get user external app

		**Required ACL:** `confd.users.{user_uuid}.external.apps.{app_name}.read`

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param userUuid the user's UUID
		@param appName External App's name
		@return UsersAPIGetUserExternalAppRequest
	*/
	GetUserExternalApp(ctx context.Context, userUuid string, appName string) UsersAPIGetUserExternalAppRequest

	// GetUserExternalAppExecute executes the request
	//  @return UserExternalApp
	GetUserExternalAppExecute(r UsersAPIGetUserExternalAppRequest) (*UserExternalApp, *http.Response, error)

	/*
		GetUserFallback List all fallbacks for user

		**Required ACL:** `confd.users.{user_id}.fallbacks.read`

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param userId the user's ID or UUID
		@return UsersAPIGetUserFallbackRequest
	*/
	GetUserFallback(ctx context.Context, userId string) UsersAPIGetUserFallbackRequest

	// GetUserFallbackExecute executes the request
	//  @return UserFallbacks
	GetUserFallbackExecute(r UsersAPIGetUserFallbackRequest) (*UserFallbacks, *http.Response, error)

	/*
		GetUserForward Get forward for a user

		**Required ACL:** `confd.users.{user_id}.forward.{forward_name}.read`

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param userId the user's ID or UUID
		@param forwardName the forward name
		@return UsersAPIGetUserForwardRequest
	*/
	GetUserForward(ctx context.Context, userId string, forwardName string) UsersAPIGetUserForwardRequest

	// GetUserForwardExecute executes the request
	//  @return UserForward
	GetUserForwardExecute(r UsersAPIGetUserForwardRequest) (*UserForward, *http.Response, error)

	/*
		GetUserFuncKey Get a func key for a user

		**Required ACL:** `confd.users.{user_id}.funckeys.{position}.read`

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param userId the user's ID or UUID
		@param position position of the funckey
		@return UsersAPIGetUserFuncKeyRequest
	*/
	GetUserFuncKey(ctx context.Context, userId string, position int32) UsersAPIGetUserFuncKeyRequest

	// GetUserFuncKeyExecute executes the request
	//  @return FuncKey
	GetUserFuncKeyExecute(r UsersAPIGetUserFuncKeyRequest) (*FuncKey, *http.Response, error)

	/*
		GetUserLineAssociatedEndpointsSip Get SIP endpoint of a line for a user

		**Required ACL:** `confd.users.{user_uuid}.lines.{line_id}.associated.endpoints.sip.read`

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param userUuid the user's UUID
		@param lineId
		@return UsersAPIGetUserLineAssociatedEndpointsSipRequest
	*/
	GetUserLineAssociatedEndpointsSip(ctx context.Context, userUuid string, lineId int32) UsersAPIGetUserLineAssociatedEndpointsSipRequest

	// GetUserLineAssociatedEndpointsSipExecute executes the request
	//  @return EndpointSIP
	GetUserLineAssociatedEndpointsSipExecute(r UsersAPIGetUserLineAssociatedEndpointsSipRequest) (*EndpointSIP, *http.Response, error)

	/*
		GetUserLineMainAssociatedEndpointsSip Get SIP endpoint of main line for a user

		**Required ACL:** `confd.users.{user_uuid}.lines.main.associated.endpoints.sip.read`

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param userUuid the user's UUID
		@return UsersAPIGetUserLineMainAssociatedEndpointsSipRequest
	*/
	GetUserLineMainAssociatedEndpointsSip(ctx context.Context, userUuid string) UsersAPIGetUserLineMainAssociatedEndpointsSipRequest

	// GetUserLineMainAssociatedEndpointsSipExecute executes the request
	//  @return EndpointSIP
	GetUserLineMainAssociatedEndpointsSipExecute(r UsersAPIGetUserLineMainAssociatedEndpointsSipRequest) (*EndpointSIP, *http.Response, error)

	/*
		GetUserMeeting Get one of the meetings of the current user

		**Required ACL:** `confd.users.me.meetings.{meeting_uuid}.read`

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param meetingUuid Meeting UUID
		@return UsersAPIGetUserMeetingRequest
	*/
	GetUserMeeting(ctx context.Context, meetingUuid string) UsersAPIGetUserMeetingRequest

	// GetUserMeetingExecute executes the request
	//  @return Meeting
	GetUserMeetingExecute(r UsersAPIGetUserMeetingRequest) (*Meeting, *http.Response, error)

	/*
		GetUserService Get status of service

		**Required ACL:** `confd.users.{user_id}.services.{service}.read`

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param userId the user's ID or UUID
		@param serviceName the service name
		@return UsersAPIGetUserServiceRequest
	*/
	GetUserService(ctx context.Context, userId string, serviceName string) UsersAPIGetUserServiceRequest

	// GetUserServiceExecute executes the request
	//  @return UserService
	GetUserServiceExecute(r UsersAPIGetUserServiceRequest) (*UserService, *http.Response, error)

	/*
		GetUserServices Get status of all user's services

		**Required ACL:** `confd.users.{user_id}.services.read`

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param userId the user's ID or UUID
		@return UsersAPIGetUserServicesRequest
	*/
	GetUserServices(ctx context.Context, userId string) UsersAPIGetUserServicesRequest

	// GetUserServicesExecute executes the request
	//  @return UserServices
	GetUserServicesExecute(r UsersAPIGetUserServicesRequest) (*UserServices, *http.Response, error)

	/*
		GetUserVoicemail Get user voicemails

		**Required ACL:** `confd.users.{user_id}.voicemails.read`

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param userId the user's ID or UUID
		@return UsersAPIGetUserVoicemailRequest
	*/
	GetUserVoicemail(ctx context.Context, userId string) UsersAPIGetUserVoicemailRequest

	// GetUserVoicemailExecute executes the request
	//  @return VoicemailItems
	GetUserVoicemailExecute(r UsersAPIGetUserVoicemailRequest) (*VoicemailItems, *http.Response, error)

	/*
		GetUsersSubscriptions Get user subscription

		**Required ACL:** `confd.users.subscriptions.read`

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@return UsersAPIGetUsersSubscriptionsRequest
	*/
	GetUsersSubscriptions(ctx context.Context) UsersAPIGetUsersSubscriptionsRequest

	// GetUsersSubscriptionsExecute executes the request
	//  @return UserSubscriptionItems
	GetUsersSubscriptionsExecute(r UsersAPIGetUsersSubscriptionsRequest) (*UserSubscriptionItems, *http.Response, error)

	/*
		HeadUser Check if user exists

		**Required ACL:** `confd.users.{user_id}.read`

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param userId the user's ID or UUID
		@return UsersAPIHeadUserRequest
	*/
	HeadUser(ctx context.Context, userId string) UsersAPIHeadUserRequest

	// HeadUserExecute executes the request
	HeadUserExecute(r UsersAPIHeadUserRequest) (*http.Response, error)

	/*
		ImportUsersCsv Mass import users and associated resources

		**Required ACL:** `confd.users.import.create`

	CSV field list available at https://accentvoice.io/uc-doc/administration/users/csv_import

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@return UsersAPIImportUsersCsvRequest
	*/
	ImportUsersCsv(ctx context.Context) UsersAPIImportUsersCsvRequest

	// ImportUsersCsvExecute executes the request
	//  @return UserImport
	ImportUsersCsvExecute(r UsersAPIImportUsersCsvRequest) (*UserImport, *http.Response, error)

	/*
		ListFuncKeyTemplateUserAssociations List users associated to template

		**Required ACL:** `confd.funckeys.templates.{template_id}.users.read`

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param templateId
		@return UsersAPIListFuncKeyTemplateUserAssociationsRequest
	*/
	ListFuncKeyTemplateUserAssociations(ctx context.Context, templateId int32) UsersAPIListFuncKeyTemplateUserAssociationsRequest

	// ListFuncKeyTemplateUserAssociationsExecute executes the request
	//  @return UserFuncKeyTemplate
	ListFuncKeyTemplateUserAssociationsExecute(r UsersAPIListFuncKeyTemplateUserAssociationsRequest) (*UserFuncKeyTemplate, *http.Response, error)

	/*
		ListUser List users

		**Required ACL:** `confd.users.read`

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@return UsersAPIListUserRequest
	*/
	ListUser(ctx context.Context) UsersAPIListUserRequest

	// ListUserExecute executes the request
	//  @return UserItems
	ListUserExecute(r UsersAPIListUserRequest) (*UserItems, *http.Response, error)

	/*
		ListUserExternalApps List user external apps

		**Required ACL:** `confd.users.{user_uuid}.external.apps.read`

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param userUuid the user's UUID
		@return UsersAPIListUserExternalAppsRequest
	*/
	ListUserExternalApps(ctx context.Context, userUuid string) UsersAPIListUserExternalAppsRequest

	// ListUserExternalAppsExecute executes the request
	//  @return UserExternalAppItems
	ListUserExternalAppsExecute(r UsersAPIListUserExternalAppsRequest) (*UserExternalAppItems, *http.Response, error)

	/*
		ListUserForwards List forwards for a user

		**Required ACL:** `confd.users.{user_id}.forwards.read`

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param userId the user's ID or UUID
		@return UsersAPIListUserForwardsRequest
	*/
	ListUserForwards(ctx context.Context, userId string) UsersAPIListUserForwardsRequest

	// ListUserForwardsExecute executes the request
	//  @return UserForwards
	ListUserForwardsExecute(r UsersAPIListUserForwardsRequest) (*UserForwards, *http.Response, error)

	/*
		ListUserFuncKeyTemplateAssociations List funckey templates associated to user

		**Required ACL:** `confd.users.{user_id}.funckeys.templates.read`

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param userId the user's ID or UUID
		@return UsersAPIListUserFuncKeyTemplateAssociationsRequest
	*/
	ListUserFuncKeyTemplateAssociations(ctx context.Context, userId string) UsersAPIListUserFuncKeyTemplateAssociationsRequest

	// ListUserFuncKeyTemplateAssociationsExecute executes the request
	//  @return UserFuncKeyTemplate
	ListUserFuncKeyTemplateAssociationsExecute(r UsersAPIListUserFuncKeyTemplateAssociationsRequest) (*UserFuncKeyTemplate, *http.Response, error)

	/*
		ListUserFuncKeys List func keys for a user

		**Required ACL:** `confd.users.{user_id}.funckeys.read`

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param userId the user's ID or UUID
		@return UsersAPIListUserFuncKeysRequest
	*/
	ListUserFuncKeys(ctx context.Context, userId string) UsersAPIListUserFuncKeysRequest

	// ListUserFuncKeysExecute executes the request
	//  @return FuncKeyTemplate
	ListUserFuncKeysExecute(r UsersAPIListUserFuncKeysRequest) (*FuncKeyTemplate, *http.Response, error)

	/*
		ListUserMeetingAuthorizations List all guest authorization requests of a meeting

		**Required ACL:** confd.users.me.meetings.{meeting_uuid}.authorizations.read

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param meetingUuid Meeting UUID
		@return UsersAPIListUserMeetingAuthorizationsRequest
	*/
	ListUserMeetingAuthorizations(ctx context.Context, meetingUuid string) UsersAPIListUserMeetingAuthorizationsRequest

	// ListUserMeetingAuthorizationsExecute executes the request
	//  @return MeetingAuthorizationItems
	ListUserMeetingAuthorizationsExecute(r UsersAPIListUserMeetingAuthorizationsRequest) (*MeetingAuthorizationItems, *http.Response, error)

	/*
		ListUserMeetings List user meetings

		**Required ACL:** `confd.users.me.meetings.read`

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@return UsersAPIListUserMeetingsRequest
	*/
	ListUserMeetings(ctx context.Context) UsersAPIListUserMeetingsRequest

	// ListUserMeetingsExecute executes the request
	//  @return MeetingItems
	ListUserMeetingsExecute(r UsersAPIListUserMeetingsRequest) (*MeetingItems, *http.Response, error)

	/*
		PutUserMeetingAuthorizationAccept Accept a guest authorization request

		**Required ACL:** confd.users.me.meetings.{meeting_uuid}.authorizations.{authorization_uuid}.accept.update

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param meetingUuid Meeting UUID
		@param authorizationUuid Authorization UUID
		@return UsersAPIPutUserMeetingAuthorizationAcceptRequest
	*/
	PutUserMeetingAuthorizationAccept(ctx context.Context, meetingUuid string, authorizationUuid string) UsersAPIPutUserMeetingAuthorizationAcceptRequest

	// PutUserMeetingAuthorizationAcceptExecute executes the request
	//  @return MeetingAuthorization
	PutUserMeetingAuthorizationAcceptExecute(r UsersAPIPutUserMeetingAuthorizationAcceptRequest) (*MeetingAuthorization, *http.Response, error)

	/*
		PutUserMeetingAuthorizationReject Reject a guest authorization request

		**Required ACL:** confd.users.me.meetings.{meeting_uuid}.authorizations.{authorization_uuid}.reject.update

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param meetingUuid Meeting UUID
		@param authorizationUuid Authorization UUID
		@return UsersAPIPutUserMeetingAuthorizationRejectRequest
	*/
	PutUserMeetingAuthorizationReject(ctx context.Context, meetingUuid string, authorizationUuid string) UsersAPIPutUserMeetingAuthorizationRejectRequest

	// PutUserMeetingAuthorizationRejectExecute executes the request
	//  @return MeetingAuthorization
	PutUserMeetingAuthorizationRejectExecute(r UsersAPIPutUserMeetingAuthorizationRejectRequest) (*MeetingAuthorization, *http.Response, error)

	/*
		UpdateCallFilterCallerUsers Update call filter and recipients

		**Required ACL:** `confd.callfilters.{callfilter_id}.recipients.users.update` **WARNING** This endpoint remove all recipients which are not defined.

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param callfilterId Call Filter's ID
		@return UsersAPIUpdateCallFilterCallerUsersRequest
	*/
	UpdateCallFilterCallerUsers(ctx context.Context, callfilterId int32) UsersAPIUpdateCallFilterCallerUsersRequest

	// UpdateCallFilterCallerUsersExecute executes the request
	UpdateCallFilterCallerUsersExecute(r UsersAPIUpdateCallFilterCallerUsersRequest) (*http.Response, error)

	/*
		UpdateCallFilterMemberUsers Update call filter and surrogates

		**Required ACL:** `confd.callfilters.{callfilter_id}.surrogates.users.update` **WARNING** This endpoint remove all surrogates which are not defined.

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param callfilterId Call Filter's ID
		@return UsersAPIUpdateCallFilterMemberUsersRequest
	*/
	UpdateCallFilterMemberUsers(ctx context.Context, callfilterId int32) UsersAPIUpdateCallFilterMemberUsersRequest

	// UpdateCallFilterMemberUsersExecute executes the request
	UpdateCallFilterMemberUsersExecute(r UsersAPIUpdateCallFilterMemberUsersRequest) (*http.Response, error)

	/*
		UpdateCallPickupInterceptorUsers Update call pickup and interceptors

		**Required ACL:** `confd.callpickups.{callpickup_id}.interceptors.users.update` **WARNING** This endpoint remove all interceptors which are not defined.

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param callpickupId Call Pickup's ID
		@return UsersAPIUpdateCallPickupInterceptorUsersRequest
	*/
	UpdateCallPickupInterceptorUsers(ctx context.Context, callpickupId int32) UsersAPIUpdateCallPickupInterceptorUsersRequest

	// UpdateCallPickupInterceptorUsersExecute executes the request
	UpdateCallPickupInterceptorUsersExecute(r UsersAPIUpdateCallPickupInterceptorUsersRequest) (*http.Response, error)

	/*
		UpdateCallPickupTargetUsers Update call pickup and targets

		**Required ACL:** `confd.callpickups.{callpickup_id}.targets.users.update` **WARNING** This endpoint remove all targets which are not defined.

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param callpickupId Call Pickup's ID
		@return UsersAPIUpdateCallPickupTargetUsersRequest
	*/
	UpdateCallPickupTargetUsers(ctx context.Context, callpickupId int32) UsersAPIUpdateCallPickupTargetUsersRequest

	// UpdateCallPickupTargetUsersExecute executes the request
	UpdateCallPickupTargetUsersExecute(r UsersAPIUpdateCallPickupTargetUsersRequest) (*http.Response, error)

	/*
		UpdateGroupMemberUsers Update group and users

		**Required ACL:** `confd.groups.{group_uuid}.members.users.update`

	**WARNING** This endpoint remove all members which are not defined.

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param groupUuid the group's UUID
		@return UsersAPIUpdateGroupMemberUsersRequest
	*/
	UpdateGroupMemberUsers(ctx context.Context, groupUuid string) UsersAPIUpdateGroupMemberUsersRequest

	// UpdateGroupMemberUsersExecute executes the request
	UpdateGroupMemberUsersExecute(r UsersAPIUpdateGroupMemberUsersRequest) (*http.Response, error)

	/*
		UpdatePagingCallerUsers Update paging and callers

		**Required ACL:** `confd.pagings.{paging_id}.callers.users.update`

	**WARNING**
	This endpoint remove all callers which are not defined.


		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param pagingId Paging's ID
		@return UsersAPIUpdatePagingCallerUsersRequest
	*/
	UpdatePagingCallerUsers(ctx context.Context, pagingId int32) UsersAPIUpdatePagingCallerUsersRequest

	// UpdatePagingCallerUsersExecute executes the request
	UpdatePagingCallerUsersExecute(r UsersAPIUpdatePagingCallerUsersRequest) (*http.Response, error)

	/*
		UpdatePagingMemberUsers Update paging and members

		**Required ACL:** `confd.pagings.{paging_id}.members.users.update`

	**WARNING**
	This endpoint remove all members which are not defined.


		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param pagingId Paging's ID
		@return UsersAPIUpdatePagingMemberUsersRequest
	*/
	UpdatePagingMemberUsers(ctx context.Context, pagingId int32) UsersAPIUpdatePagingMemberUsersRequest

	// UpdatePagingMemberUsersExecute executes the request
	UpdatePagingMemberUsersExecute(r UsersAPIUpdatePagingMemberUsersRequest) (*http.Response, error)

	/*
		UpdateSwitchboardMemberUsers Update switchboard and members

		**Required ACL:** `confd.switchboards.{switchboard_uuid}.members.users.update`

	**WARNING**
	This endpoint removes all members which are not defined.


		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param switchboardUuid
		@return UsersAPIUpdateSwitchboardMemberUsersRequest
	*/
	UpdateSwitchboardMemberUsers(ctx context.Context, switchboardUuid string) UsersAPIUpdateSwitchboardMemberUsersRequest

	// UpdateSwitchboardMemberUsersExecute executes the request
	UpdateSwitchboardMemberUsersExecute(r UsersAPIUpdateSwitchboardMemberUsersRequest) (*http.Response, error)

	/*
		UpdateUser Update user

		**Required ACL:** `confd.users.{user_id}.update`

	If the firstname or the lastname is modified, the name of associated voicemail is also updated.

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param userId the user's ID or UUID
		@return UsersAPIUpdateUserRequest
	*/
	UpdateUser(ctx context.Context, userId string) UsersAPIUpdateUserRequest

	// UpdateUserExecute executes the request
	UpdateUserExecute(r UsersAPIUpdateUserRequest) (*http.Response, error)

	/*
		UpdateUserExternalApp Update user external app

		**Required ACL:** `confd.users.{user_uuid}.external.apps.{app_name}.update`

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param userUuid the user's UUID
		@param appName External App's name
		@return UsersAPIUpdateUserExternalAppRequest
	*/
	UpdateUserExternalApp(ctx context.Context, userUuid string, appName string) UsersAPIUpdateUserExternalAppRequest

	// UpdateUserExternalAppExecute executes the request
	UpdateUserExternalAppExecute(r UsersAPIUpdateUserExternalAppRequest) (*http.Response, error)

	/*
		UpdateUserFallback Update user's fallbacks

		**Required ACL:** `confd.users.{user_id}.fallbacks.update`

	**WARNING** This endpoint delete all fields that are not defined.

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param userId the user's ID or UUID
		@return UsersAPIUpdateUserFallbackRequest
	*/
	UpdateUserFallback(ctx context.Context, userId string) UsersAPIUpdateUserFallbackRequest

	// UpdateUserFallbackExecute executes the request
	UpdateUserFallbackExecute(r UsersAPIUpdateUserFallbackRequest) (*http.Response, error)

	/*
		UpdateUserForward Update a forward for a user

		**Required ACL:** `confd.users.{user_id}.forwards.{forward_name}.update`

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param userId the user's ID or UUID
		@param forwardName the forward name
		@return UsersAPIUpdateUserForwardRequest
	*/
	UpdateUserForward(ctx context.Context, userId string, forwardName string) UsersAPIUpdateUserForwardRequest

	// UpdateUserForwardExecute executes the request
	UpdateUserForwardExecute(r UsersAPIUpdateUserForwardRequest) (*http.Response, error)

	/*
		UpdateUserForwards Update all forwards for a user

		**Required ACL:** `confd.users.{user_id}.forwards.update`

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param userId the user's ID or UUID
		@return UsersAPIUpdateUserForwardsRequest
	*/
	UpdateUserForwards(ctx context.Context, userId string) UsersAPIUpdateUserForwardsRequest

	// UpdateUserForwardsExecute executes the request
	UpdateUserForwardsExecute(r UsersAPIUpdateUserForwardsRequest) (*http.Response, error)

	/*
		UpdateUserFuncKey Add/Replace a func key for a user

		**Required ACL:** `confd.users.{user_id}.funckeys.{position}.update`

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param userId the user's ID or UUID
		@param position position of the funckey
		@return UsersAPIUpdateUserFuncKeyRequest
	*/
	UpdateUserFuncKey(ctx context.Context, userId string, position int32) UsersAPIUpdateUserFuncKeyRequest

	// UpdateUserFuncKeyExecute executes the request
	UpdateUserFuncKeyExecute(r UsersAPIUpdateUserFuncKeyRequest) (*http.Response, error)

	/*
		UpdateUserFuncKeys Update func keys for a user

		**Required ACL:** `confd.users.{user_id}.funckeys.update`

	**WARNING** This endpoint restore to default value or delete all fields that are not defined.

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param userId the user's ID or UUID
		@return UsersAPIUpdateUserFuncKeysRequest
	*/
	UpdateUserFuncKeys(ctx context.Context, userId string) UsersAPIUpdateUserFuncKeysRequest

	// UpdateUserFuncKeysExecute executes the request
	UpdateUserFuncKeysExecute(r UsersAPIUpdateUserFuncKeysRequest) (*http.Response, error)

	/*
		UpdateUserGroups Update user and groups

		**Required ACL:** `confd.users.{user_id}.groups`
	**WARNING** This endpoint remove all groups which are not defined.

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param userId the user's ID or UUID
		@return UsersAPIUpdateUserGroupsRequest
	*/
	UpdateUserGroups(ctx context.Context, userId string) UsersAPIUpdateUserGroupsRequest

	// UpdateUserGroupsExecute executes the request
	UpdateUserGroupsExecute(r UsersAPIUpdateUserGroupsRequest) (*http.Response, error)

	/*
		UpdateUserMeeting Update one of the meetings of the current user

		**Required ACL:** `confd.users.me.meetings.{meeting_uuid}.update`

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param meetingUuid Meeting UUID
		@return UsersAPIUpdateUserMeetingRequest
	*/
	UpdateUserMeeting(ctx context.Context, meetingUuid string) UsersAPIUpdateUserMeetingRequest

	// UpdateUserMeetingExecute executes the request
	UpdateUserMeetingExecute(r UsersAPIUpdateUserMeetingRequest) (*http.Response, error)

	/*
		UpdateUserQueueAssociation Update User-Queue association

		**Required ACL:** `confd.queues.{queue_id}.members.users.{user_id}.update`

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param queueId queue's ID
		@param userId the user's ID or UUID
		@return UsersAPIUpdateUserQueueAssociationRequest
	*/
	UpdateUserQueueAssociation(ctx context.Context, queueId int32, userId string) UsersAPIUpdateUserQueueAssociationRequest

	// UpdateUserQueueAssociationExecute executes the request
	UpdateUserQueueAssociationExecute(r UsersAPIUpdateUserQueueAssociationRequest) (*http.Response, error)

	/*
		UpdateUserService Enable/Disable service for a user

		**Required ACL:** `confd.users.{user_id}.services.{service}.update`

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param userId the user's ID or UUID
		@param serviceName the service name
		@return UsersAPIUpdateUserServiceRequest
	*/
	UpdateUserService(ctx context.Context, userId string, serviceName string) UsersAPIUpdateUserServiceRequest

	// UpdateUserServiceExecute executes the request
	UpdateUserServiceExecute(r UsersAPIUpdateUserServiceRequest) (*http.Response, error)

	/*
		UpdateUserServices Update all services for a user

		**Required ACL:** `confd.users.{user_id}.services.update`

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param userId the user's ID or UUID
		@return UsersAPIUpdateUserServicesRequest
	*/
	UpdateUserServices(ctx context.Context, userId string) UsersAPIUpdateUserServicesRequest

	// UpdateUserServicesExecute executes the request
	UpdateUserServicesExecute(r UsersAPIUpdateUserServicesRequest) (*http.Response, error)

	/*
		UpdateUsersCsv **Disabled!** Mass import users and associated resources

		** This endpoint is disabled.**
	**Required ACL:** `confd.users.import.update`

	CSV field list available at https://accentvoice.io/uc-doc/administration/users/csv_import
	This resource has been disabled since it creates invalid configurations

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@return UsersAPIUpdateUsersCsvRequest
	*/
	UpdateUsersCsv(ctx context.Context) UsersAPIUpdateUsersCsvRequest

	// UpdateUsersCsvExecute executes the request
	//  @return UserUpdate
	UpdateUsersCsvExecute(r UsersAPIUpdateUsersCsvRequest) (*UserUpdate, *http.Response, error)
}

// UsersAPIService UsersAPI service
type UsersAPIService service

type UsersAPIAssociateUserAgentRequest struct {
	ctx          context.Context
	ApiService   UsersAPI
	userId       string
	agentId      int32
	accentTenant *string
}

// The tenant&#39;s UUID, defining the ownership of a given resource.
func (r UsersAPIAssociateUserAgentRequest) AccentTenant(accentTenant string) UsersAPIAssociateUserAgentRequest {
	r.accentTenant = &accentTenant
	return r
}

func (r UsersAPIAssociateUserAgentRequest) Execute() (*http.Response, error) {
	return r.ApiService.AssociateUserAgentExecute(r)
}

/*
AssociateUserAgent Associate user and agent

**Required ACL:** `confd.users.{user_id}.agents.{agent_id}.update`

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param userId the user's ID or UUID
	@param agentId Agentâ€™s ID
	@return UsersAPIAssociateUserAgentRequest
*/
func (a *UsersAPIService) AssociateUserAgent(ctx context.Context, userId string, agentId int32) UsersAPIAssociateUserAgentRequest {
	return UsersAPIAssociateUserAgentRequest{
		ApiService: a,
		ctx:        ctx,
		userId:     userId,
		agentId:    agentId,
	}
}

// Execute executes the request
func (a *UsersAPIService) AssociateUserAgentExecute(r UsersAPIAssociateUserAgentRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodPut
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersAPIService.AssociateUserAgent")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/{user_id}/agents/{agent_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"user_id"+"}", url.PathEscape(parameterValueToString(r.userId, "userId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"agent_id"+"}", url.PathEscape(parameterValueToString(r.agentId, "agentId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.accentTenant != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accent-Tenant", r.accentTenant, "")
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["accent_auth_token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Auth-Token"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v []string
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v []string
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type UsersAPIAssociateUserCallpermissionRequest struct {
	ctx              context.Context
	ApiService       UsersAPI
	userId           string
	callpermissionId int32
	accentTenant     *string
}

// The tenant&#39;s UUID, defining the ownership of a given resource.
func (r UsersAPIAssociateUserCallpermissionRequest) AccentTenant(accentTenant string) UsersAPIAssociateUserCallpermissionRequest {
	r.accentTenant = &accentTenant
	return r
}

func (r UsersAPIAssociateUserCallpermissionRequest) Execute() (*http.Response, error) {
	return r.ApiService.AssociateUserCallpermissionExecute(r)
}

/*
AssociateUserCallpermission Associate user and call permission

**Required ACL:** `confd.users.{user_id}.callpermissions.{call_permission_id}.update`

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param userId the user's ID or UUID
	@param callpermissionId Call Permission's ID
	@return UsersAPIAssociateUserCallpermissionRequest
*/
func (a *UsersAPIService) AssociateUserCallpermission(ctx context.Context, userId string, callpermissionId int32) UsersAPIAssociateUserCallpermissionRequest {
	return UsersAPIAssociateUserCallpermissionRequest{
		ApiService:       a,
		ctx:              ctx,
		userId:           userId,
		callpermissionId: callpermissionId,
	}
}

// Execute executes the request
func (a *UsersAPIService) AssociateUserCallpermissionExecute(r UsersAPIAssociateUserCallpermissionRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodPut
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersAPIService.AssociateUserCallpermission")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/{user_id}/callpermissions/{callpermission_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"user_id"+"}", url.PathEscape(parameterValueToString(r.userId, "userId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"callpermission_id"+"}", url.PathEscape(parameterValueToString(r.callpermissionId, "callpermissionId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.accentTenant != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accent-Tenant", r.accentTenant, "")
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["accent_auth_token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Auth-Token"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v []string
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v []string
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type UsersAPIAssociateUserFuncKeyTemplateRequest struct {
	ctx          context.Context
	ApiService   UsersAPI
	userId       string
	templateId   int32
	accentTenant *string
}

// The tenant&#39;s UUID, defining the ownership of a given resource.
func (r UsersAPIAssociateUserFuncKeyTemplateRequest) AccentTenant(accentTenant string) UsersAPIAssociateUserFuncKeyTemplateRequest {
	r.accentTenant = &accentTenant
	return r
}

func (r UsersAPIAssociateUserFuncKeyTemplateRequest) Execute() (*http.Response, error) {
	return r.ApiService.AssociateUserFuncKeyTemplateExecute(r)
}

/*
AssociateUserFuncKeyTemplate Associate a func key template to a user

**Required ACL:** `confd.users.{user_id}.funckeys.templates.{template_id}.update`

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param userId the user's ID or UUID
	@param templateId
	@return UsersAPIAssociateUserFuncKeyTemplateRequest
*/
func (a *UsersAPIService) AssociateUserFuncKeyTemplate(ctx context.Context, userId string, templateId int32) UsersAPIAssociateUserFuncKeyTemplateRequest {
	return UsersAPIAssociateUserFuncKeyTemplateRequest{
		ApiService: a,
		ctx:        ctx,
		userId:     userId,
		templateId: templateId,
	}
}

// Execute executes the request
func (a *UsersAPIService) AssociateUserFuncKeyTemplateExecute(r UsersAPIAssociateUserFuncKeyTemplateRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodPut
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersAPIService.AssociateUserFuncKeyTemplate")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/{user_id}/funckeys/templates/{template_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"user_id"+"}", url.PathEscape(parameterValueToString(r.userId, "userId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"template_id"+"}", url.PathEscape(parameterValueToString(r.templateId, "templateId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.accentTenant != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accent-Tenant", r.accentTenant, "")
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["accent_auth_token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Auth-Token"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v []string
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v []string
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type UsersAPIAssociateUserLineRequest struct {
	ctx        context.Context
	ApiService UsersAPI
	userId     string
	lineId     int32
}

func (r UsersAPIAssociateUserLineRequest) Execute() (*http.Response, error) {
	return r.ApiService.AssociateUserLineExecute(r)
}

/*
AssociateUserLine Associate user and line

**Required ACL:** `confd.users.{user_id}.lines.{line_id}.update`

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param userId the user's ID or UUID
	@param lineId
	@return UsersAPIAssociateUserLineRequest
*/
func (a *UsersAPIService) AssociateUserLine(ctx context.Context, userId string, lineId int32) UsersAPIAssociateUserLineRequest {
	return UsersAPIAssociateUserLineRequest{
		ApiService: a,
		ctx:        ctx,
		userId:     userId,
		lineId:     lineId,
	}
}

// Execute executes the request
func (a *UsersAPIService) AssociateUserLineExecute(r UsersAPIAssociateUserLineRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodPut
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersAPIService.AssociateUserLine")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/{user_id}/lines/{line_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"user_id"+"}", url.PathEscape(parameterValueToString(r.userId, "userId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"line_id"+"}", url.PathEscape(parameterValueToString(r.lineId, "lineId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["accent_auth_token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Auth-Token"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v []string
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v []string
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type UsersAPIAssociateUserLinesRequest struct {
	ctx        context.Context
	ApiService UsersAPI
	body       *LinesID
	userId     string
}

func (r UsersAPIAssociateUserLinesRequest) Body(body LinesID) UsersAPIAssociateUserLinesRequest {
	r.body = &body
	return r
}

func (r UsersAPIAssociateUserLinesRequest) Execute() (*http.Response, error) {
	return r.ApiService.AssociateUserLinesExecute(r)
}

/*
AssociateUserLines Associate user and lines

**Required ACL:** `confd.users.{user_id}.lines.update`

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param userId the user's ID or UUID
	@return UsersAPIAssociateUserLinesRequest
*/
func (a *UsersAPIService) AssociateUserLines(ctx context.Context, userId string) UsersAPIAssociateUserLinesRequest {
	return UsersAPIAssociateUserLinesRequest{
		ApiService: a,
		ctx:        ctx,
		userId:     userId,
	}
}

// Execute executes the request
func (a *UsersAPIService) AssociateUserLinesExecute(r UsersAPIAssociateUserLinesRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodPut
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersAPIService.AssociateUserLines")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/{user_id}/lines"
	localVarPath = strings.Replace(localVarPath, "{"+"user_id"+"}", url.PathEscape(parameterValueToString(r.userId, "userId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return nil, reportError("body is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["accent_auth_token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Auth-Token"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v []string
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v []string
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type UsersAPIAssociateUserScheduleRequest struct {
	ctx          context.Context
	ApiService   UsersAPI
	userId       string
	scheduleId   int32
	accentTenant *string
}

// The tenant&#39;s UUID, defining the ownership of a given resource.
func (r UsersAPIAssociateUserScheduleRequest) AccentTenant(accentTenant string) UsersAPIAssociateUserScheduleRequest {
	r.accentTenant = &accentTenant
	return r
}

func (r UsersAPIAssociateUserScheduleRequest) Execute() (*http.Response, error) {
	return r.ApiService.AssociateUserScheduleExecute(r)
}

/*
AssociateUserSchedule Associate user and schedule

**Required ACL:** `confd.users.{user_id}.schedules.{schedule_id}.update`

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param userId the user's ID or UUID
	@param scheduleId Schedule's ID
	@return UsersAPIAssociateUserScheduleRequest
*/
func (a *UsersAPIService) AssociateUserSchedule(ctx context.Context, userId string, scheduleId int32) UsersAPIAssociateUserScheduleRequest {
	return UsersAPIAssociateUserScheduleRequest{
		ApiService: a,
		ctx:        ctx,
		userId:     userId,
		scheduleId: scheduleId,
	}
}

// Execute executes the request
func (a *UsersAPIService) AssociateUserScheduleExecute(r UsersAPIAssociateUserScheduleRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodPut
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersAPIService.AssociateUserSchedule")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/{user_id}/schedules/{schedule_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"user_id"+"}", url.PathEscape(parameterValueToString(r.userId, "userId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"schedule_id"+"}", url.PathEscape(parameterValueToString(r.scheduleId, "scheduleId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.accentTenant != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accent-Tenant", r.accentTenant, "")
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["accent_auth_token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Auth-Token"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v []string
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v []string
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type UsersAPIAssociateUserVoicemailRequest struct {
	ctx         context.Context
	ApiService  UsersAPI
	userId      string
	voicemailId int32
}

func (r UsersAPIAssociateUserVoicemailRequest) Execute() (*http.Response, error) {
	return r.ApiService.AssociateUserVoicemailExecute(r)
}

/*
AssociateUserVoicemail Associate user and voicemail

**Required ACL:** `confd.users.{user_id}.voicemails.{voicemail_id}.update`

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param userId the user's ID or UUID
	@param voicemailId
	@return UsersAPIAssociateUserVoicemailRequest
*/
func (a *UsersAPIService) AssociateUserVoicemail(ctx context.Context, userId string, voicemailId int32) UsersAPIAssociateUserVoicemailRequest {
	return UsersAPIAssociateUserVoicemailRequest{
		ApiService:  a,
		ctx:         ctx,
		userId:      userId,
		voicemailId: voicemailId,
	}
}

// Execute executes the request
func (a *UsersAPIService) AssociateUserVoicemailExecute(r UsersAPIAssociateUserVoicemailRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodPut
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersAPIService.AssociateUserVoicemail")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/{user_id}/voicemails/{voicemail_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"user_id"+"}", url.PathEscape(parameterValueToString(r.userId, "userId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"voicemail_id"+"}", url.PathEscape(parameterValueToString(r.voicemailId, "voicemailId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["accent_auth_token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Auth-Token"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v []string
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v []string
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type UsersAPICreateUserRequest struct {
	ctx          context.Context
	ApiService   UsersAPI
	body         *UserPost
	accentTenant *string
}

// User to create
func (r UsersAPICreateUserRequest) Body(body UserPost) UsersAPICreateUserRequest {
	r.body = &body
	return r
}

// The tenant&#39;s UUID, defining the ownership of a given resource.
func (r UsersAPICreateUserRequest) AccentTenant(accentTenant string) UsersAPICreateUserRequest {
	r.accentTenant = &accentTenant
	return r
}

func (r UsersAPICreateUserRequest) Execute() (*UserPostResponse, *http.Response, error) {
	return r.ApiService.CreateUserExecute(r)
}

/*
CreateUser Create user

**Required ACL:** `confd.users.create`

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return UsersAPICreateUserRequest
*/
func (a *UsersAPIService) CreateUser(ctx context.Context) UsersAPICreateUserRequest {
	return UsersAPICreateUserRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return UserPostResponse
func (a *UsersAPIService) CreateUserExecute(r UsersAPICreateUserRequest) (*UserPostResponse, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *UserPostResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersAPIService.CreateUser")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("body is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.accentTenant != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accent-Tenant", r.accentTenant, "")
	}
	// body params
	localVarPostBody = r.body
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["accent_auth_token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Auth-Token"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v []string
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type UsersAPICreateUserExternalAppRequest struct {
	ctx          context.Context
	ApiService   UsersAPI
	body         *UserExternalApp
	userUuid     string
	appName      string
	accentTenant *string
}

// External app to create
func (r UsersAPICreateUserExternalAppRequest) Body(body UserExternalApp) UsersAPICreateUserExternalAppRequest {
	r.body = &body
	return r
}

// The tenant&#39;s UUID, defining the ownership of a given resource.
func (r UsersAPICreateUserExternalAppRequest) AccentTenant(accentTenant string) UsersAPICreateUserExternalAppRequest {
	r.accentTenant = &accentTenant
	return r
}

func (r UsersAPICreateUserExternalAppRequest) Execute() (*UserExternalApp, *http.Response, error) {
	return r.ApiService.CreateUserExternalAppExecute(r)
}

/*
CreateUserExternalApp Create user external app

**Required ACL:** `confd.users.{user_uuid}.external.apps.{app_name}.create`

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param userUuid the user's UUID
	@param appName External App's name
	@return UsersAPICreateUserExternalAppRequest
*/
func (a *UsersAPIService) CreateUserExternalApp(ctx context.Context, userUuid string, appName string) UsersAPICreateUserExternalAppRequest {
	return UsersAPICreateUserExternalAppRequest{
		ApiService: a,
		ctx:        ctx,
		userUuid:   userUuid,
		appName:    appName,
	}
}

// Execute executes the request
//
//	@return UserExternalApp
func (a *UsersAPIService) CreateUserExternalAppExecute(r UsersAPICreateUserExternalAppRequest) (*UserExternalApp, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *UserExternalApp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersAPIService.CreateUserExternalApp")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/{user_uuid}/external/apps/{app_name}"
	localVarPath = strings.Replace(localVarPath, "{"+"user_uuid"+"}", url.PathEscape(parameterValueToString(r.userUuid, "userUuid")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"app_name"+"}", url.PathEscape(parameterValueToString(r.appName, "appName")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("body is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.accentTenant != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accent-Tenant", r.accentTenant, "")
	}
	// body params
	localVarPostBody = r.body
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["accent_auth_token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Auth-Token"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v []string
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type UsersAPICreateUserMeetingRequest struct {
	ctx          context.Context
	ApiService   UsersAPI
	body         *MeetingUserRequest
	accentTenant *string
}

// Meeting to create
func (r UsersAPICreateUserMeetingRequest) Body(body MeetingUserRequest) UsersAPICreateUserMeetingRequest {
	r.body = &body
	return r
}

// The tenant&#39;s UUID, defining the ownership of a given resource.
func (r UsersAPICreateUserMeetingRequest) AccentTenant(accentTenant string) UsersAPICreateUserMeetingRequest {
	r.accentTenant = &accentTenant
	return r
}

func (r UsersAPICreateUserMeetingRequest) Execute() (*Meeting, *http.Response, error) {
	return r.ApiService.CreateUserMeetingExecute(r)
}

/*
CreateUserMeeting Create user meeting

**Required ACL:** `confd.users.me.meetings.create`

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return UsersAPICreateUserMeetingRequest
*/
func (a *UsersAPIService) CreateUserMeeting(ctx context.Context) UsersAPICreateUserMeetingRequest {
	return UsersAPICreateUserMeetingRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return Meeting
func (a *UsersAPIService) CreateUserMeetingExecute(r UsersAPICreateUserMeetingRequest) (*Meeting, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *Meeting
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersAPIService.CreateUserMeeting")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/me/meetings"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("body is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.accentTenant != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accent-Tenant", r.accentTenant, "")
	}
	// body params
	localVarPostBody = r.body
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["accent_auth_token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Auth-Token"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v []string
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type UsersAPICreateUserVoicemailRequest struct {
	ctx          context.Context
	ApiService   UsersAPI
	body         *Voicemail
	userId       string
	accentTenant *string
}

// Voicemail to create
func (r UsersAPICreateUserVoicemailRequest) Body(body Voicemail) UsersAPICreateUserVoicemailRequest {
	r.body = &body
	return r
}

// The tenant&#39;s UUID, defining the ownership of a given resource.
func (r UsersAPICreateUserVoicemailRequest) AccentTenant(accentTenant string) UsersAPICreateUserVoicemailRequest {
	r.accentTenant = &accentTenant
	return r
}

func (r UsersAPICreateUserVoicemailRequest) Execute() (*Voicemail, *http.Response, error) {
	return r.ApiService.CreateUserVoicemailExecute(r)
}

/*
CreateUserVoicemail Create user voicemail

**Required ACL:** `confd.users.{user_id}.voicemails.create`

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param userId the user's ID or UUID
	@return UsersAPICreateUserVoicemailRequest
*/
func (a *UsersAPIService) CreateUserVoicemail(ctx context.Context, userId string) UsersAPICreateUserVoicemailRequest {
	return UsersAPICreateUserVoicemailRequest{
		ApiService: a,
		ctx:        ctx,
		userId:     userId,
	}
}

// Execute executes the request
//
//	@return Voicemail
func (a *UsersAPIService) CreateUserVoicemailExecute(r UsersAPICreateUserVoicemailRequest) (*Voicemail, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *Voicemail
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersAPIService.CreateUserVoicemail")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/{user_id}/voicemails"
	localVarPath = strings.Replace(localVarPath, "{"+"user_id"+"}", url.PathEscape(parameterValueToString(r.userId, "userId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("body is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.accentTenant != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accent-Tenant", r.accentTenant, "")
	}
	// body params
	localVarPostBody = r.body
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["accent_auth_token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Auth-Token"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v []string
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v Object
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type UsersAPIDeleteUserRequest struct {
	ctx          context.Context
	ApiService   UsersAPI
	userId       string
	accentTenant *string
	recursive    *bool
}

// The tenant&#39;s UUID, defining the ownership of a given resource.
func (r UsersAPIDeleteUserRequest) AccentTenant(accentTenant string) UsersAPIDeleteUserRequest {
	r.accentTenant = &accentTenant
	return r
}

// Indicates if the resources related to the user must be deleted too.
func (r UsersAPIDeleteUserRequest) Recursive(recursive bool) UsersAPIDeleteUserRequest {
	r.recursive = &recursive
	return r
}

func (r UsersAPIDeleteUserRequest) Execute() (*http.Response, error) {
	return r.ApiService.DeleteUserExecute(r)
}

/*
DeleteUser Delete user

**Required ACL:** `confd.users.{user_id}.delete`

A user can not be deleted if he is associated to a line or a voicemail. Any line or voicemail attached to the user must be dissociated first. The user will also be removed from all queues, groups or other Accent entities whom he is member.

**Disclaimer**: if `recursive=true`, the user is deleted, all their associations with any related resources are removed, and some resources (lines, extensions, incalls and auth user) are deleted too.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param userId the user's ID or UUID
	@return UsersAPIDeleteUserRequest
*/
func (a *UsersAPIService) DeleteUser(ctx context.Context, userId string) UsersAPIDeleteUserRequest {
	return UsersAPIDeleteUserRequest{
		ApiService: a,
		ctx:        ctx,
		userId:     userId,
	}
}

// Execute executes the request
func (a *UsersAPIService) DeleteUserExecute(r UsersAPIDeleteUserRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodDelete
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersAPIService.DeleteUser")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/{user_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"user_id"+"}", url.PathEscape(parameterValueToString(r.userId, "userId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.recursive != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "recursive", r.recursive, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.accentTenant != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accent-Tenant", r.accentTenant, "")
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["accent_auth_token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Auth-Token"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v []string
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v []string
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type UsersAPIDeleteUserExternalAppRequest struct {
	ctx          context.Context
	ApiService   UsersAPI
	userUuid     string
	appName      string
	accentTenant *string
}

// The tenant&#39;s UUID, defining the ownership of a given resource.
func (r UsersAPIDeleteUserExternalAppRequest) AccentTenant(accentTenant string) UsersAPIDeleteUserExternalAppRequest {
	r.accentTenant = &accentTenant
	return r
}

func (r UsersAPIDeleteUserExternalAppRequest) Execute() (*http.Response, error) {
	return r.ApiService.DeleteUserExternalAppExecute(r)
}

/*
DeleteUserExternalApp Delete user external app

**Required ACL:** `confd.users.{user_uuid}.external.apps.{app_name}.delete`

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param userUuid the user's UUID
	@param appName External App's name
	@return UsersAPIDeleteUserExternalAppRequest
*/
func (a *UsersAPIService) DeleteUserExternalApp(ctx context.Context, userUuid string, appName string) UsersAPIDeleteUserExternalAppRequest {
	return UsersAPIDeleteUserExternalAppRequest{
		ApiService: a,
		ctx:        ctx,
		userUuid:   userUuid,
		appName:    appName,
	}
}

// Execute executes the request
func (a *UsersAPIService) DeleteUserExternalAppExecute(r UsersAPIDeleteUserExternalAppRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodDelete
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersAPIService.DeleteUserExternalApp")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/{user_uuid}/external/apps/{app_name}"
	localVarPath = strings.Replace(localVarPath, "{"+"user_uuid"+"}", url.PathEscape(parameterValueToString(r.userUuid, "userUuid")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"app_name"+"}", url.PathEscape(parameterValueToString(r.appName, "appName")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.accentTenant != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accent-Tenant", r.accentTenant, "")
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["accent_auth_token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Auth-Token"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v []string
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v []string
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type UsersAPIDeleteUserFuncKeyRequest struct {
	ctx          context.Context
	ApiService   UsersAPI
	userId       string
	position     int32
	accentTenant *string
}

// The tenant&#39;s UUID, defining the ownership of a given resource.
func (r UsersAPIDeleteUserFuncKeyRequest) AccentTenant(accentTenant string) UsersAPIDeleteUserFuncKeyRequest {
	r.accentTenant = &accentTenant
	return r
}

func (r UsersAPIDeleteUserFuncKeyRequest) Execute() (*http.Response, error) {
	return r.ApiService.DeleteUserFuncKeyExecute(r)
}

/*
DeleteUserFuncKey Remove func key for user

**Required ACL:** `confd.users.{user_id}.funckeys.{position}.delete`

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param userId the user's ID or UUID
	@param position position of the funckey
	@return UsersAPIDeleteUserFuncKeyRequest
*/
func (a *UsersAPIService) DeleteUserFuncKey(ctx context.Context, userId string, position int32) UsersAPIDeleteUserFuncKeyRequest {
	return UsersAPIDeleteUserFuncKeyRequest{
		ApiService: a,
		ctx:        ctx,
		userId:     userId,
		position:   position,
	}
}

// Execute executes the request
func (a *UsersAPIService) DeleteUserFuncKeyExecute(r UsersAPIDeleteUserFuncKeyRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodDelete
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersAPIService.DeleteUserFuncKey")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/{user_id}/funckeys/{position}"
	localVarPath = strings.Replace(localVarPath, "{"+"user_id"+"}", url.PathEscape(parameterValueToString(r.userId, "userId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"position"+"}", url.PathEscape(parameterValueToString(r.position, "position")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.accentTenant != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accent-Tenant", r.accentTenant, "")
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["accent_auth_token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Auth-Token"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v []string
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v []string
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type UsersAPIDeleteUserMeetingRequest struct {
	ctx          context.Context
	ApiService   UsersAPI
	meetingUuid  string
	accentTenant *string
}

// The tenant&#39;s UUID, defining the ownership of a given resource.
func (r UsersAPIDeleteUserMeetingRequest) AccentTenant(accentTenant string) UsersAPIDeleteUserMeetingRequest {
	r.accentTenant = &accentTenant
	return r
}

func (r UsersAPIDeleteUserMeetingRequest) Execute() (*http.Response, error) {
	return r.ApiService.DeleteUserMeetingExecute(r)
}

/*
DeleteUserMeeting Delete one of the meetings of the current user

**Required ACL:** `confd.users.me.meetings.{meeting_uuid}.delete`

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param meetingUuid Meeting UUID
	@return UsersAPIDeleteUserMeetingRequest
*/
func (a *UsersAPIService) DeleteUserMeeting(ctx context.Context, meetingUuid string) UsersAPIDeleteUserMeetingRequest {
	return UsersAPIDeleteUserMeetingRequest{
		ApiService:  a,
		ctx:         ctx,
		meetingUuid: meetingUuid,
	}
}

// Execute executes the request
func (a *UsersAPIService) DeleteUserMeetingExecute(r UsersAPIDeleteUserMeetingRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodDelete
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersAPIService.DeleteUserMeeting")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/me/meetings/{meeting_uuid}"
	localVarPath = strings.Replace(localVarPath, "{"+"meeting_uuid"+"}", url.PathEscape(parameterValueToString(r.meetingUuid, "meetingUuid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.accentTenant != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accent-Tenant", r.accentTenant, "")
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["accent_auth_token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Auth-Token"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v []string
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v []string
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type UsersAPIDissociateUserAgentRequest struct {
	ctx          context.Context
	ApiService   UsersAPI
	userId       string
	accentTenant *string
}

// The tenant&#39;s UUID, defining the ownership of a given resource.
func (r UsersAPIDissociateUserAgentRequest) AccentTenant(accentTenant string) UsersAPIDissociateUserAgentRequest {
	r.accentTenant = &accentTenant
	return r
}

func (r UsersAPIDissociateUserAgentRequest) Execute() (*http.Response, error) {
	return r.ApiService.DissociateUserAgentExecute(r)
}

/*
DissociateUserAgent Dissociate user and agent

**Required ACL:** `confd.users.{user_id}.agents.delete`

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param userId the user's ID or UUID
	@return UsersAPIDissociateUserAgentRequest
*/
func (a *UsersAPIService) DissociateUserAgent(ctx context.Context, userId string) UsersAPIDissociateUserAgentRequest {
	return UsersAPIDissociateUserAgentRequest{
		ApiService: a,
		ctx:        ctx,
		userId:     userId,
	}
}

// Execute executes the request
func (a *UsersAPIService) DissociateUserAgentExecute(r UsersAPIDissociateUserAgentRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodDelete
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersAPIService.DissociateUserAgent")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/{user_id}/agents"
	localVarPath = strings.Replace(localVarPath, "{"+"user_id"+"}", url.PathEscape(parameterValueToString(r.userId, "userId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.accentTenant != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accent-Tenant", r.accentTenant, "")
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["accent_auth_token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Auth-Token"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v []string
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v []string
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type UsersAPIDissociateUserCallpermissionRequest struct {
	ctx              context.Context
	ApiService       UsersAPI
	userId           string
	callpermissionId int32
	accentTenant     *string
}

// The tenant&#39;s UUID, defining the ownership of a given resource.
func (r UsersAPIDissociateUserCallpermissionRequest) AccentTenant(accentTenant string) UsersAPIDissociateUserCallpermissionRequest {
	r.accentTenant = &accentTenant
	return r
}

func (r UsersAPIDissociateUserCallpermissionRequest) Execute() (*http.Response, error) {
	return r.ApiService.DissociateUserCallpermissionExecute(r)
}

/*
DissociateUserCallpermission Dissociate user and call permission

**Required ACL:** `confd.users.{user_id}.callpermissions.{call_permission_id}.delete`

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param userId the user's ID or UUID
	@param callpermissionId Call Permission's ID
	@return UsersAPIDissociateUserCallpermissionRequest
*/
func (a *UsersAPIService) DissociateUserCallpermission(ctx context.Context, userId string, callpermissionId int32) UsersAPIDissociateUserCallpermissionRequest {
	return UsersAPIDissociateUserCallpermissionRequest{
		ApiService:       a,
		ctx:              ctx,
		userId:           userId,
		callpermissionId: callpermissionId,
	}
}

// Execute executes the request
func (a *UsersAPIService) DissociateUserCallpermissionExecute(r UsersAPIDissociateUserCallpermissionRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodDelete
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersAPIService.DissociateUserCallpermission")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/{user_id}/callpermissions/{callpermission_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"user_id"+"}", url.PathEscape(parameterValueToString(r.userId, "userId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"callpermission_id"+"}", url.PathEscape(parameterValueToString(r.callpermissionId, "callpermissionId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.accentTenant != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accent-Tenant", r.accentTenant, "")
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["accent_auth_token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Auth-Token"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v []string
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v []string
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type UsersAPIDissociateUserFuncKeyTemplateRequest struct {
	ctx          context.Context
	ApiService   UsersAPI
	userId       string
	templateId   int32
	accentTenant *string
}

// The tenant&#39;s UUID, defining the ownership of a given resource.
func (r UsersAPIDissociateUserFuncKeyTemplateRequest) AccentTenant(accentTenant string) UsersAPIDissociateUserFuncKeyTemplateRequest {
	r.accentTenant = &accentTenant
	return r
}

func (r UsersAPIDissociateUserFuncKeyTemplateRequest) Execute() (*http.Response, error) {
	return r.ApiService.DissociateUserFuncKeyTemplateExecute(r)
}

/*
DissociateUserFuncKeyTemplate Dissociate a func key template to a user

**Required ACL:** `confd.users.{user_id}.funckeys.templates.{template_id}.delete`

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param userId the user's ID or UUID
	@param templateId
	@return UsersAPIDissociateUserFuncKeyTemplateRequest
*/
func (a *UsersAPIService) DissociateUserFuncKeyTemplate(ctx context.Context, userId string, templateId int32) UsersAPIDissociateUserFuncKeyTemplateRequest {
	return UsersAPIDissociateUserFuncKeyTemplateRequest{
		ApiService: a,
		ctx:        ctx,
		userId:     userId,
		templateId: templateId,
	}
}

// Execute executes the request
func (a *UsersAPIService) DissociateUserFuncKeyTemplateExecute(r UsersAPIDissociateUserFuncKeyTemplateRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodDelete
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersAPIService.DissociateUserFuncKeyTemplate")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/{user_id}/funckeys/templates/{template_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"user_id"+"}", url.PathEscape(parameterValueToString(r.userId, "userId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"template_id"+"}", url.PathEscape(parameterValueToString(r.templateId, "templateId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.accentTenant != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accent-Tenant", r.accentTenant, "")
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["accent_auth_token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Auth-Token"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v []string
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v []string
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type UsersAPIDissociateUserLineRequest struct {
	ctx        context.Context
	ApiService UsersAPI
	userId     string
	lineId     int32
}

func (r UsersAPIDissociateUserLineRequest) Execute() (*http.Response, error) {
	return r.ApiService.DissociateUserLineExecute(r)
}

/*
DissociateUserLine Dissociate user and line

**Required ACL:** `confd.users.{user_id}.lines.{line_id}.delete`

Any devices that are attached the line must be removed before dissociating a user from its line. A device can be dissociated be resetting it to autoprov mode.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param userId the user's ID or UUID
	@param lineId
	@return UsersAPIDissociateUserLineRequest
*/
func (a *UsersAPIService) DissociateUserLine(ctx context.Context, userId string, lineId int32) UsersAPIDissociateUserLineRequest {
	return UsersAPIDissociateUserLineRequest{
		ApiService: a,
		ctx:        ctx,
		userId:     userId,
		lineId:     lineId,
	}
}

// Execute executes the request
func (a *UsersAPIService) DissociateUserLineExecute(r UsersAPIDissociateUserLineRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodDelete
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersAPIService.DissociateUserLine")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/{user_id}/lines/{line_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"user_id"+"}", url.PathEscape(parameterValueToString(r.userId, "userId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"line_id"+"}", url.PathEscape(parameterValueToString(r.lineId, "lineId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["accent_auth_token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Auth-Token"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v []string
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v []string
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type UsersAPIDissociateUserQueueRequest struct {
	ctx          context.Context
	ApiService   UsersAPI
	queueId      int32
	userId       string
	accentTenant *string
}

// The tenant&#39;s UUID, defining the ownership of a given resource.
func (r UsersAPIDissociateUserQueueRequest) AccentTenant(accentTenant string) UsersAPIDissociateUserQueueRequest {
	r.accentTenant = &accentTenant
	return r
}

func (r UsersAPIDissociateUserQueueRequest) Execute() (*http.Response, error) {
	return r.ApiService.DissociateUserQueueExecute(r)
}

/*
DissociateUserQueue Dissociate user and queue

**Required ACL:** `confd.queues.{queue_id}.members.users.{user_id}.delete`

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param queueId queue's ID
	@param userId the user's ID or UUID
	@return UsersAPIDissociateUserQueueRequest
*/
func (a *UsersAPIService) DissociateUserQueue(ctx context.Context, queueId int32, userId string) UsersAPIDissociateUserQueueRequest {
	return UsersAPIDissociateUserQueueRequest{
		ApiService: a,
		ctx:        ctx,
		queueId:    queueId,
		userId:     userId,
	}
}

// Execute executes the request
func (a *UsersAPIService) DissociateUserQueueExecute(r UsersAPIDissociateUserQueueRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodDelete
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersAPIService.DissociateUserQueue")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/queues/{queue_id}/members/users/{user_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"queue_id"+"}", url.PathEscape(parameterValueToString(r.queueId, "queueId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"user_id"+"}", url.PathEscape(parameterValueToString(r.userId, "userId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.accentTenant != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accent-Tenant", r.accentTenant, "")
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["accent_auth_token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Auth-Token"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v []string
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v []string
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type UsersAPIDissociateUserScheduleRequest struct {
	ctx          context.Context
	ApiService   UsersAPI
	userId       string
	scheduleId   int32
	accentTenant *string
}

// The tenant&#39;s UUID, defining the ownership of a given resource.
func (r UsersAPIDissociateUserScheduleRequest) AccentTenant(accentTenant string) UsersAPIDissociateUserScheduleRequest {
	r.accentTenant = &accentTenant
	return r
}

func (r UsersAPIDissociateUserScheduleRequest) Execute() (*http.Response, error) {
	return r.ApiService.DissociateUserScheduleExecute(r)
}

/*
DissociateUserSchedule Dissociate user and schedule

**Required ACL:** `confd.users.{user_id}.schedules.{schedule_id}.delete`

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param userId the user's ID or UUID
	@param scheduleId Schedule's ID
	@return UsersAPIDissociateUserScheduleRequest
*/
func (a *UsersAPIService) DissociateUserSchedule(ctx context.Context, userId string, scheduleId int32) UsersAPIDissociateUserScheduleRequest {
	return UsersAPIDissociateUserScheduleRequest{
		ApiService: a,
		ctx:        ctx,
		userId:     userId,
		scheduleId: scheduleId,
	}
}

// Execute executes the request
func (a *UsersAPIService) DissociateUserScheduleExecute(r UsersAPIDissociateUserScheduleRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodDelete
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersAPIService.DissociateUserSchedule")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/{user_id}/schedules/{schedule_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"user_id"+"}", url.PathEscape(parameterValueToString(r.userId, "userId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"schedule_id"+"}", url.PathEscape(parameterValueToString(r.scheduleId, "scheduleId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.accentTenant != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accent-Tenant", r.accentTenant, "")
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["accent_auth_token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Auth-Token"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v []string
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v []string
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type UsersAPIDissociateUserVoicemailRequest struct {
	ctx        context.Context
	ApiService UsersAPI
	userId     string
}

func (r UsersAPIDissociateUserVoicemailRequest) Execute() (*http.Response, error) {
	return r.ApiService.DissociateUserVoicemailExecute(r)
}

/*
DissociateUserVoicemail Dissociate user and voicemail

**Required ACL:** `confd.users.{user_id}.voicemails.delete`

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param userId the user's ID or UUID
	@return UsersAPIDissociateUserVoicemailRequest
*/
func (a *UsersAPIService) DissociateUserVoicemail(ctx context.Context, userId string) UsersAPIDissociateUserVoicemailRequest {
	return UsersAPIDissociateUserVoicemailRequest{
		ApiService: a,
		ctx:        ctx,
		userId:     userId,
	}
}

// Execute executes the request
func (a *UsersAPIService) DissociateUserVoicemailExecute(r UsersAPIDissociateUserVoicemailRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodDelete
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersAPIService.DissociateUserVoicemail")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/{user_id}/voicemails"
	localVarPath = strings.Replace(localVarPath, "{"+"user_id"+"}", url.PathEscape(parameterValueToString(r.userId, "userId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["accent_auth_token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Auth-Token"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v []string
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v []string
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type UsersAPIExportUsersCsvRequest struct {
	ctx          context.Context
	ApiService   UsersAPI
	accentTenant *string
}

// The tenant&#39;s UUID, defining the ownership of a given resource.
func (r UsersAPIExportUsersCsvRequest) AccentTenant(accentTenant string) UsersAPIExportUsersCsvRequest {
	r.accentTenant = &accentTenant
	return r
}

func (r UsersAPIExportUsersCsvRequest) Execute() (string, *http.Response, error) {
	return r.ApiService.ExportUsersCsvExecute(r)
}

/*
ExportUsersCsv Mass export users and associated resources

**Required ACL:** `confd.users.export.read`

CSV field list available at https://accentvoice.io/uc-doc/administration/users/csv_import

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return UsersAPIExportUsersCsvRequest
*/
func (a *UsersAPIService) ExportUsersCsv(ctx context.Context) UsersAPIExportUsersCsvRequest {
	return UsersAPIExportUsersCsvRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return string
func (a *UsersAPIService) ExportUsersCsvExecute(r UsersAPIExportUsersCsvRequest) (string, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue string
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersAPIService.ExportUsersCsv")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/export"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"text/csv; charset=utf-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.accentTenant != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accent-Tenant", r.accentTenant, "")
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["accent_auth_token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Auth-Token"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type UsersAPIGetUserRequest struct {
	ctx          context.Context
	ApiService   UsersAPI
	userId       string
	accentTenant *string
}

// The tenant&#39;s UUID, defining the ownership of a given resource.
func (r UsersAPIGetUserRequest) AccentTenant(accentTenant string) UsersAPIGetUserRequest {
	r.accentTenant = &accentTenant
	return r
}

func (r UsersAPIGetUserRequest) Execute() (*User, *http.Response, error) {
	return r.ApiService.GetUserExecute(r)
}

/*
GetUser Get user

**Required ACL:** `confd.users.{user_id}.read`

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param userId the user's ID or UUID
	@return UsersAPIGetUserRequest
*/
func (a *UsersAPIService) GetUser(ctx context.Context, userId string) UsersAPIGetUserRequest {
	return UsersAPIGetUserRequest{
		ApiService: a,
		ctx:        ctx,
		userId:     userId,
	}
}

// Execute executes the request
//
//	@return User
func (a *UsersAPIService) GetUserExecute(r UsersAPIGetUserRequest) (*User, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *User
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersAPIService.GetUser")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/{user_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"user_id"+"}", url.PathEscape(parameterValueToString(r.userId, "userId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.accentTenant != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accent-Tenant", r.accentTenant, "")
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["accent_auth_token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Auth-Token"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v []string
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type UsersAPIGetUserExternalAppRequest struct {
	ctx          context.Context
	ApiService   UsersAPI
	userUuid     string
	appName      string
	accentTenant *string
	view         *string
}

// The tenant&#39;s UUID, defining the ownership of a given resource.
func (r UsersAPIGetUserExternalAppRequest) AccentTenant(accentTenant string) UsersAPIGetUserExternalAppRequest {
	r.accentTenant = &accentTenant
	return r
}

// Different view of the external app endpoint  The &#x60;default&#x60; view, when the argument is omitted, is to return the user value for this external app  The &#x60;fallback&#x60; view return the user value for this external app, but if not found, will fallback to the tenant configured value  **WARNING**: Using fallback view on list will disabled all pagination and search features
func (r UsersAPIGetUserExternalAppRequest) View(view string) UsersAPIGetUserExternalAppRequest {
	r.view = &view
	return r
}

func (r UsersAPIGetUserExternalAppRequest) Execute() (*UserExternalApp, *http.Response, error) {
	return r.ApiService.GetUserExternalAppExecute(r)
}

/*
GetUserExternalApp Get user external app

**Required ACL:** `confd.users.{user_uuid}.external.apps.{app_name}.read`

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param userUuid the user's UUID
	@param appName External App's name
	@return UsersAPIGetUserExternalAppRequest
*/
func (a *UsersAPIService) GetUserExternalApp(ctx context.Context, userUuid string, appName string) UsersAPIGetUserExternalAppRequest {
	return UsersAPIGetUserExternalAppRequest{
		ApiService: a,
		ctx:        ctx,
		userUuid:   userUuid,
		appName:    appName,
	}
}

// Execute executes the request
//
//	@return UserExternalApp
func (a *UsersAPIService) GetUserExternalAppExecute(r UsersAPIGetUserExternalAppRequest) (*UserExternalApp, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *UserExternalApp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersAPIService.GetUserExternalApp")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/{user_uuid}/external/apps/{app_name}"
	localVarPath = strings.Replace(localVarPath, "{"+"user_uuid"+"}", url.PathEscape(parameterValueToString(r.userUuid, "userUuid")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"app_name"+"}", url.PathEscape(parameterValueToString(r.appName, "appName")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.view != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "view", r.view, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.accentTenant != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accent-Tenant", r.accentTenant, "")
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["accent_auth_token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Auth-Token"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v []string
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type UsersAPIGetUserFallbackRequest struct {
	ctx        context.Context
	ApiService UsersAPI
	userId     string
}

func (r UsersAPIGetUserFallbackRequest) Execute() (*UserFallbacks, *http.Response, error) {
	return r.ApiService.GetUserFallbackExecute(r)
}

/*
GetUserFallback List all fallbacks for user

**Required ACL:** `confd.users.{user_id}.fallbacks.read`

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param userId the user's ID or UUID
	@return UsersAPIGetUserFallbackRequest
*/
func (a *UsersAPIService) GetUserFallback(ctx context.Context, userId string) UsersAPIGetUserFallbackRequest {
	return UsersAPIGetUserFallbackRequest{
		ApiService: a,
		ctx:        ctx,
		userId:     userId,
	}
}

// Execute executes the request
//
//	@return UserFallbacks
func (a *UsersAPIService) GetUserFallbackExecute(r UsersAPIGetUserFallbackRequest) (*UserFallbacks, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *UserFallbacks
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersAPIService.GetUserFallback")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/{user_id}/fallbacks"
	localVarPath = strings.Replace(localVarPath, "{"+"user_id"+"}", url.PathEscape(parameterValueToString(r.userId, "userId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["accent_auth_token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Auth-Token"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type UsersAPIGetUserForwardRequest struct {
	ctx         context.Context
	ApiService  UsersAPI
	userId      string
	forwardName string
}

func (r UsersAPIGetUserForwardRequest) Execute() (*UserForward, *http.Response, error) {
	return r.ApiService.GetUserForwardExecute(r)
}

/*
GetUserForward Get forward for a user

**Required ACL:** `confd.users.{user_id}.forward.{forward_name}.read`

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param userId the user's ID or UUID
	@param forwardName the forward name
	@return UsersAPIGetUserForwardRequest
*/
func (a *UsersAPIService) GetUserForward(ctx context.Context, userId string, forwardName string) UsersAPIGetUserForwardRequest {
	return UsersAPIGetUserForwardRequest{
		ApiService:  a,
		ctx:         ctx,
		userId:      userId,
		forwardName: forwardName,
	}
}

// Execute executes the request
//
//	@return UserForward
func (a *UsersAPIService) GetUserForwardExecute(r UsersAPIGetUserForwardRequest) (*UserForward, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *UserForward
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersAPIService.GetUserForward")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/{user_id}/forwards/{forward_name}"
	localVarPath = strings.Replace(localVarPath, "{"+"user_id"+"}", url.PathEscape(parameterValueToString(r.userId, "userId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"forward_name"+"}", url.PathEscape(parameterValueToString(r.forwardName, "forwardName")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["accent_auth_token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Auth-Token"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type UsersAPIGetUserFuncKeyRequest struct {
	ctx          context.Context
	ApiService   UsersAPI
	userId       string
	position     int32
	accentTenant *string
}

// The tenant&#39;s UUID, defining the ownership of a given resource.
func (r UsersAPIGetUserFuncKeyRequest) AccentTenant(accentTenant string) UsersAPIGetUserFuncKeyRequest {
	r.accentTenant = &accentTenant
	return r
}

func (r UsersAPIGetUserFuncKeyRequest) Execute() (*FuncKey, *http.Response, error) {
	return r.ApiService.GetUserFuncKeyExecute(r)
}

/*
GetUserFuncKey Get a func key for a user

**Required ACL:** `confd.users.{user_id}.funckeys.{position}.read`

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param userId the user's ID or UUID
	@param position position of the funckey
	@return UsersAPIGetUserFuncKeyRequest
*/
func (a *UsersAPIService) GetUserFuncKey(ctx context.Context, userId string, position int32) UsersAPIGetUserFuncKeyRequest {
	return UsersAPIGetUserFuncKeyRequest{
		ApiService: a,
		ctx:        ctx,
		userId:     userId,
		position:   position,
	}
}

// Execute executes the request
//
//	@return FuncKey
func (a *UsersAPIService) GetUserFuncKeyExecute(r UsersAPIGetUserFuncKeyRequest) (*FuncKey, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *FuncKey
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersAPIService.GetUserFuncKey")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/{user_id}/funckeys/{position}"
	localVarPath = strings.Replace(localVarPath, "{"+"user_id"+"}", url.PathEscape(parameterValueToString(r.userId, "userId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"position"+"}", url.PathEscape(parameterValueToString(r.position, "position")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.accentTenant != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accent-Tenant", r.accentTenant, "")
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["accent_auth_token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Auth-Token"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v []string
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type UsersAPIGetUserLineAssociatedEndpointsSipRequest struct {
	ctx        context.Context
	ApiService UsersAPI
	userUuid   string
	lineId     int32
	view       *string
}

// Different view of the SIP endpoint  The &#x60;default&#x60; view, when the argument is omitted, is to include only options that are defined on the specified endpoint.  The &#x60;merged&#x60; view includes all options from included templates.
func (r UsersAPIGetUserLineAssociatedEndpointsSipRequest) View(view string) UsersAPIGetUserLineAssociatedEndpointsSipRequest {
	r.view = &view
	return r
}

func (r UsersAPIGetUserLineAssociatedEndpointsSipRequest) Execute() (*EndpointSIP, *http.Response, error) {
	return r.ApiService.GetUserLineAssociatedEndpointsSipExecute(r)
}

/*
GetUserLineAssociatedEndpointsSip Get SIP endpoint of a line for a user

**Required ACL:** `confd.users.{user_uuid}.lines.{line_id}.associated.endpoints.sip.read`

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param userUuid the user's UUID
	@param lineId
	@return UsersAPIGetUserLineAssociatedEndpointsSipRequest
*/
func (a *UsersAPIService) GetUserLineAssociatedEndpointsSip(ctx context.Context, userUuid string, lineId int32) UsersAPIGetUserLineAssociatedEndpointsSipRequest {
	return UsersAPIGetUserLineAssociatedEndpointsSipRequest{
		ApiService: a,
		ctx:        ctx,
		userUuid:   userUuid,
		lineId:     lineId,
	}
}

// Execute executes the request
//
//	@return EndpointSIP
func (a *UsersAPIService) GetUserLineAssociatedEndpointsSipExecute(r UsersAPIGetUserLineAssociatedEndpointsSipRequest) (*EndpointSIP, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *EndpointSIP
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersAPIService.GetUserLineAssociatedEndpointsSip")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/{user_uuid}/lines/{line_id}/associated/endpoints/sip"
	localVarPath = strings.Replace(localVarPath, "{"+"user_uuid"+"}", url.PathEscape(parameterValueToString(r.userUuid, "userUuid")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"line_id"+"}", url.PathEscape(parameterValueToString(r.lineId, "lineId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.view != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "view", r.view, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["accent_auth_token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Auth-Token"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type UsersAPIGetUserLineMainAssociatedEndpointsSipRequest struct {
	ctx        context.Context
	ApiService UsersAPI
	userUuid   string
	view       *string
}

// Different view of the SIP endpoint  The &#x60;default&#x60; view, when the argument is omitted, is to include only options that are defined on the specified endpoint.  The &#x60;merged&#x60; view includes all options from included templates.
func (r UsersAPIGetUserLineMainAssociatedEndpointsSipRequest) View(view string) UsersAPIGetUserLineMainAssociatedEndpointsSipRequest {
	r.view = &view
	return r
}

func (r UsersAPIGetUserLineMainAssociatedEndpointsSipRequest) Execute() (*EndpointSIP, *http.Response, error) {
	return r.ApiService.GetUserLineMainAssociatedEndpointsSipExecute(r)
}

/*
GetUserLineMainAssociatedEndpointsSip Get SIP endpoint of main line for a user

**Required ACL:** `confd.users.{user_uuid}.lines.main.associated.endpoints.sip.read`

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param userUuid the user's UUID
	@return UsersAPIGetUserLineMainAssociatedEndpointsSipRequest
*/
func (a *UsersAPIService) GetUserLineMainAssociatedEndpointsSip(ctx context.Context, userUuid string) UsersAPIGetUserLineMainAssociatedEndpointsSipRequest {
	return UsersAPIGetUserLineMainAssociatedEndpointsSipRequest{
		ApiService: a,
		ctx:        ctx,
		userUuid:   userUuid,
	}
}

// Execute executes the request
//
//	@return EndpointSIP
func (a *UsersAPIService) GetUserLineMainAssociatedEndpointsSipExecute(r UsersAPIGetUserLineMainAssociatedEndpointsSipRequest) (*EndpointSIP, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *EndpointSIP
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersAPIService.GetUserLineMainAssociatedEndpointsSip")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/{user_uuid}/lines/main/associated/endpoints/sip"
	localVarPath = strings.Replace(localVarPath, "{"+"user_uuid"+"}", url.PathEscape(parameterValueToString(r.userUuid, "userUuid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.view != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "view", r.view, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["accent_auth_token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Auth-Token"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type UsersAPIGetUserMeetingRequest struct {
	ctx          context.Context
	ApiService   UsersAPI
	meetingUuid  string
	accentTenant *string
}

// The tenant&#39;s UUID, defining the ownership of a given resource.
func (r UsersAPIGetUserMeetingRequest) AccentTenant(accentTenant string) UsersAPIGetUserMeetingRequest {
	r.accentTenant = &accentTenant
	return r
}

func (r UsersAPIGetUserMeetingRequest) Execute() (*Meeting, *http.Response, error) {
	return r.ApiService.GetUserMeetingExecute(r)
}

/*
GetUserMeeting Get one of the meetings of the current user

**Required ACL:** `confd.users.me.meetings.{meeting_uuid}.read`

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param meetingUuid Meeting UUID
	@return UsersAPIGetUserMeetingRequest
*/
func (a *UsersAPIService) GetUserMeeting(ctx context.Context, meetingUuid string) UsersAPIGetUserMeetingRequest {
	return UsersAPIGetUserMeetingRequest{
		ApiService:  a,
		ctx:         ctx,
		meetingUuid: meetingUuid,
	}
}

// Execute executes the request
//
//	@return Meeting
func (a *UsersAPIService) GetUserMeetingExecute(r UsersAPIGetUserMeetingRequest) (*Meeting, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *Meeting
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersAPIService.GetUserMeeting")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/me/meetings/{meeting_uuid}"
	localVarPath = strings.Replace(localVarPath, "{"+"meeting_uuid"+"}", url.PathEscape(parameterValueToString(r.meetingUuid, "meetingUuid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.accentTenant != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accent-Tenant", r.accentTenant, "")
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["accent_auth_token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Auth-Token"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v []string
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type UsersAPIGetUserServiceRequest struct {
	ctx         context.Context
	ApiService  UsersAPI
	userId      string
	serviceName string
}

func (r UsersAPIGetUserServiceRequest) Execute() (*UserService, *http.Response, error) {
	return r.ApiService.GetUserServiceExecute(r)
}

/*
GetUserService Get status of service

**Required ACL:** `confd.users.{user_id}.services.{service}.read`

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param userId the user's ID or UUID
	@param serviceName the service name
	@return UsersAPIGetUserServiceRequest
*/
func (a *UsersAPIService) GetUserService(ctx context.Context, userId string, serviceName string) UsersAPIGetUserServiceRequest {
	return UsersAPIGetUserServiceRequest{
		ApiService:  a,
		ctx:         ctx,
		userId:      userId,
		serviceName: serviceName,
	}
}

// Execute executes the request
//
//	@return UserService
func (a *UsersAPIService) GetUserServiceExecute(r UsersAPIGetUserServiceRequest) (*UserService, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *UserService
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersAPIService.GetUserService")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/{user_id}/services/{service_name}"
	localVarPath = strings.Replace(localVarPath, "{"+"user_id"+"}", url.PathEscape(parameterValueToString(r.userId, "userId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"service_name"+"}", url.PathEscape(parameterValueToString(r.serviceName, "serviceName")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["accent_auth_token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Auth-Token"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v []string
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type UsersAPIGetUserServicesRequest struct {
	ctx        context.Context
	ApiService UsersAPI
	userId     string
}

func (r UsersAPIGetUserServicesRequest) Execute() (*UserServices, *http.Response, error) {
	return r.ApiService.GetUserServicesExecute(r)
}

/*
GetUserServices Get status of all user's services

**Required ACL:** `confd.users.{user_id}.services.read`

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param userId the user's ID or UUID
	@return UsersAPIGetUserServicesRequest
*/
func (a *UsersAPIService) GetUserServices(ctx context.Context, userId string) UsersAPIGetUserServicesRequest {
	return UsersAPIGetUserServicesRequest{
		ApiService: a,
		ctx:        ctx,
		userId:     userId,
	}
}

// Execute executes the request
//
//	@return UserServices
func (a *UsersAPIService) GetUserServicesExecute(r UsersAPIGetUserServicesRequest) (*UserServices, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *UserServices
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersAPIService.GetUserServices")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/{user_id}/services"
	localVarPath = strings.Replace(localVarPath, "{"+"user_id"+"}", url.PathEscape(parameterValueToString(r.userId, "userId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["accent_auth_token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Auth-Token"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v []string
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type UsersAPIGetUserVoicemailRequest struct {
	ctx          context.Context
	ApiService   UsersAPI
	userId       string
	accentTenant *string
}

// The tenant&#39;s UUID, defining the ownership of a given resource.
func (r UsersAPIGetUserVoicemailRequest) AccentTenant(accentTenant string) UsersAPIGetUserVoicemailRequest {
	r.accentTenant = &accentTenant
	return r
}

func (r UsersAPIGetUserVoicemailRequest) Execute() (*VoicemailItems, *http.Response, error) {
	return r.ApiService.GetUserVoicemailExecute(r)
}

/*
GetUserVoicemail Get user voicemails

**Required ACL:** `confd.users.{user_id}.voicemails.read`

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param userId the user's ID or UUID
	@return UsersAPIGetUserVoicemailRequest
*/
func (a *UsersAPIService) GetUserVoicemail(ctx context.Context, userId string) UsersAPIGetUserVoicemailRequest {
	return UsersAPIGetUserVoicemailRequest{
		ApiService: a,
		ctx:        ctx,
		userId:     userId,
	}
}

// Execute executes the request
//
//	@return VoicemailItems
func (a *UsersAPIService) GetUserVoicemailExecute(r UsersAPIGetUserVoicemailRequest) (*VoicemailItems, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *VoicemailItems
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersAPIService.GetUserVoicemail")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/{user_id}/voicemails"
	localVarPath = strings.Replace(localVarPath, "{"+"user_id"+"}", url.PathEscape(parameterValueToString(r.userId, "userId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.accentTenant != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accent-Tenant", r.accentTenant, "")
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["accent_auth_token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Auth-Token"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v []string
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type UsersAPIGetUsersSubscriptionsRequest struct {
	ctx          context.Context
	ApiService   UsersAPI
	accentTenant *string
}

// The tenant&#39;s UUID, defining the ownership of a given resource.
func (r UsersAPIGetUsersSubscriptionsRequest) AccentTenant(accentTenant string) UsersAPIGetUsersSubscriptionsRequest {
	r.accentTenant = &accentTenant
	return r
}

func (r UsersAPIGetUsersSubscriptionsRequest) Execute() (*UserSubscriptionItems, *http.Response, error) {
	return r.ApiService.GetUsersSubscriptionsExecute(r)
}

/*
GetUsersSubscriptions Get user subscription

**Required ACL:** `confd.users.subscriptions.read`

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return UsersAPIGetUsersSubscriptionsRequest
*/
func (a *UsersAPIService) GetUsersSubscriptions(ctx context.Context) UsersAPIGetUsersSubscriptionsRequest {
	return UsersAPIGetUsersSubscriptionsRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return UserSubscriptionItems
func (a *UsersAPIService) GetUsersSubscriptionsExecute(r UsersAPIGetUsersSubscriptionsRequest) (*UserSubscriptionItems, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *UserSubscriptionItems
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersAPIService.GetUsersSubscriptions")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/subscriptions"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.accentTenant != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accent-Tenant", r.accentTenant, "")
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["accent_auth_token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Auth-Token"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type UsersAPIHeadUserRequest struct {
	ctx          context.Context
	ApiService   UsersAPI
	userId       string
	accentTenant *string
}

// The tenant&#39;s UUID, defining the ownership of a given resource.
func (r UsersAPIHeadUserRequest) AccentTenant(accentTenant string) UsersAPIHeadUserRequest {
	r.accentTenant = &accentTenant
	return r
}

func (r UsersAPIHeadUserRequest) Execute() (*http.Response, error) {
	return r.ApiService.HeadUserExecute(r)
}

/*
HeadUser Check if user exists

**Required ACL:** `confd.users.{user_id}.read`

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param userId the user's ID or UUID
	@return UsersAPIHeadUserRequest
*/
func (a *UsersAPIService) HeadUser(ctx context.Context, userId string) UsersAPIHeadUserRequest {
	return UsersAPIHeadUserRequest{
		ApiService: a,
		ctx:        ctx,
		userId:     userId,
	}
}

// Execute executes the request
func (a *UsersAPIService) HeadUserExecute(r UsersAPIHeadUserRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodHead
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersAPIService.HeadUser")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/{user_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"user_id"+"}", url.PathEscape(parameterValueToString(r.userId, "userId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.accentTenant != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accent-Tenant", r.accentTenant, "")
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["accent_auth_token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Auth-Token"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type UsersAPIImportUsersCsvRequest struct {
	ctx          context.Context
	ApiService   UsersAPI
	body         *string
	accentTenant *string
}

// CSV field list available at https://accentvoice.io/uc-doc/administration/users/csv_import
func (r UsersAPIImportUsersCsvRequest) Body(body string) UsersAPIImportUsersCsvRequest {
	r.body = &body
	return r
}

// The tenant&#39;s UUID, defining the ownership of a given resource.
func (r UsersAPIImportUsersCsvRequest) AccentTenant(accentTenant string) UsersAPIImportUsersCsvRequest {
	r.accentTenant = &accentTenant
	return r
}

func (r UsersAPIImportUsersCsvRequest) Execute() (*UserImport, *http.Response, error) {
	return r.ApiService.ImportUsersCsvExecute(r)
}

/*
ImportUsersCsv Mass import users and associated resources

**Required ACL:** `confd.users.import.create`

CSV field list available at https://accentvoice.io/uc-doc/administration/users/csv_import

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return UsersAPIImportUsersCsvRequest
*/
func (a *UsersAPIService) ImportUsersCsv(ctx context.Context) UsersAPIImportUsersCsvRequest {
	return UsersAPIImportUsersCsvRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return UserImport
func (a *UsersAPIService) ImportUsersCsvExecute(r UsersAPIImportUsersCsvRequest) (*UserImport, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *UserImport
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersAPIService.ImportUsersCsv")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/import"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("body is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"text/csv; charset=utf-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.accentTenant != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accent-Tenant", r.accentTenant, "")
	}
	// body params
	localVarPostBody = r.body
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["accent_auth_token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Auth-Token"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v UserImportError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type UsersAPIListFuncKeyTemplateUserAssociationsRequest struct {
	ctx          context.Context
	ApiService   UsersAPI
	templateId   int32
	accentTenant *string
}

// The tenant&#39;s UUID, defining the ownership of a given resource.
func (r UsersAPIListFuncKeyTemplateUserAssociationsRequest) AccentTenant(accentTenant string) UsersAPIListFuncKeyTemplateUserAssociationsRequest {
	r.accentTenant = &accentTenant
	return r
}

func (r UsersAPIListFuncKeyTemplateUserAssociationsRequest) Execute() (*UserFuncKeyTemplate, *http.Response, error) {
	return r.ApiService.ListFuncKeyTemplateUserAssociationsExecute(r)
}

/*
ListFuncKeyTemplateUserAssociations List users associated to template

**Required ACL:** `confd.funckeys.templates.{template_id}.users.read`

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param templateId
	@return UsersAPIListFuncKeyTemplateUserAssociationsRequest
*/
func (a *UsersAPIService) ListFuncKeyTemplateUserAssociations(ctx context.Context, templateId int32) UsersAPIListFuncKeyTemplateUserAssociationsRequest {
	return UsersAPIListFuncKeyTemplateUserAssociationsRequest{
		ApiService: a,
		ctx:        ctx,
		templateId: templateId,
	}
}

// Execute executes the request
//
//	@return UserFuncKeyTemplate
func (a *UsersAPIService) ListFuncKeyTemplateUserAssociationsExecute(r UsersAPIListFuncKeyTemplateUserAssociationsRequest) (*UserFuncKeyTemplate, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *UserFuncKeyTemplate
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersAPIService.ListFuncKeyTemplateUserAssociations")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/funckeys/templates/{template_id}/users"
	localVarPath = strings.Replace(localVarPath, "{"+"template_id"+"}", url.PathEscape(parameterValueToString(r.templateId, "templateId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.accentTenant != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accent-Tenant", r.accentTenant, "")
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["accent_auth_token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Auth-Token"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v []string
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type UsersAPIListUserRequest struct {
	ctx          context.Context
	ApiService   UsersAPI
	accentTenant *string
	recurse      *bool
	order        *string
	direction    *string
	limit        *int32
	offset       *int32
	search       *string
	view         *string
}

// The tenant&#39;s UUID, defining the ownership of a given resource.
func (r UsersAPIListUserRequest) AccentTenant(accentTenant string) UsersAPIListUserRequest {
	r.accentTenant = &accentTenant
	return r
}

// Should the query include sub-tenants
func (r UsersAPIListUserRequest) Recurse(recurse bool) UsersAPIListUserRequest {
	r.recurse = &recurse
	return r
}

// Name of the field to use for sorting the list of items returned.
func (r UsersAPIListUserRequest) Order(order string) UsersAPIListUserRequest {
	r.order = &order
	return r
}

// Sort list of items in &#39;asc&#39; (ascending) or &#39;desc&#39; (descending) order
func (r UsersAPIListUserRequest) Direction(direction string) UsersAPIListUserRequest {
	r.direction = &direction
	return r
}

// Maximum number of items to return in the list
func (r UsersAPIListUserRequest) Limit(limit int32) UsersAPIListUserRequest {
	r.limit = &limit
	return r
}

// Number of items to skip over in the list. Useful for pagination.
func (r UsersAPIListUserRequest) Offset(offset int32) UsersAPIListUserRequest {
	r.offset = &offset
	return r
}

// Search term for filtering a list of items. Only items with a field containing the search term will be returned.
func (r UsersAPIListUserRequest) Search(search string) UsersAPIListUserRequest {
	r.search = &search
	return r
}

// Different view of the list of users.
func (r UsersAPIListUserRequest) View(view string) UsersAPIListUserRequest {
	r.view = &view
	return r
}

func (r UsersAPIListUserRequest) Execute() (*UserItems, *http.Response, error) {
	return r.ApiService.ListUserExecute(r)
}

/*
ListUser List users

**Required ACL:** `confd.users.read`

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return UsersAPIListUserRequest
*/
func (a *UsersAPIService) ListUser(ctx context.Context) UsersAPIListUserRequest {
	return UsersAPIListUserRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return UserItems
func (a *UsersAPIService) ListUserExecute(r UsersAPIListUserRequest) (*UserItems, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *UserItems
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersAPIService.ListUser")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.recurse != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "recurse", r.recurse, "")
	} else {
		var defaultValue bool = false
		r.recurse = &defaultValue
	}
	if r.order != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "order", r.order, "")
	}
	if r.direction != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "direction", r.direction, "")
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "")
	}
	if r.offset != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "offset", r.offset, "")
	}
	if r.search != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "search", r.search, "")
	}
	if r.view != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "view", r.view, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.accentTenant != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accent-Tenant", r.accentTenant, "")
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["accent_auth_token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Auth-Token"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type UsersAPIListUserExternalAppsRequest struct {
	ctx          context.Context
	ApiService   UsersAPI
	userUuid     string
	accentTenant *string
	order        *string
	direction    *string
	limit        *int32
	offset       *int32
	search       *string
	view         *string
}

// The tenant&#39;s UUID, defining the ownership of a given resource.
func (r UsersAPIListUserExternalAppsRequest) AccentTenant(accentTenant string) UsersAPIListUserExternalAppsRequest {
	r.accentTenant = &accentTenant
	return r
}

// Name of the field to use for sorting the list of items returned.
func (r UsersAPIListUserExternalAppsRequest) Order(order string) UsersAPIListUserExternalAppsRequest {
	r.order = &order
	return r
}

// Sort list of items in &#39;asc&#39; (ascending) or &#39;desc&#39; (descending) order
func (r UsersAPIListUserExternalAppsRequest) Direction(direction string) UsersAPIListUserExternalAppsRequest {
	r.direction = &direction
	return r
}

// Maximum number of items to return in the list
func (r UsersAPIListUserExternalAppsRequest) Limit(limit int32) UsersAPIListUserExternalAppsRequest {
	r.limit = &limit
	return r
}

// Number of items to skip over in the list. Useful for pagination.
func (r UsersAPIListUserExternalAppsRequest) Offset(offset int32) UsersAPIListUserExternalAppsRequest {
	r.offset = &offset
	return r
}

// Search term for filtering a list of items. Only items with a field containing the search term will be returned.
func (r UsersAPIListUserExternalAppsRequest) Search(search string) UsersAPIListUserExternalAppsRequest {
	r.search = &search
	return r
}

// Different view of the external app endpoint  The &#x60;default&#x60; view, when the argument is omitted, is to return the user value for this external app  The &#x60;fallback&#x60; view return the user value for this external app, but if not found, will fallback to the tenant configured value  **WARNING**: Using fallback view on list will disabled all pagination and search features
func (r UsersAPIListUserExternalAppsRequest) View(view string) UsersAPIListUserExternalAppsRequest {
	r.view = &view
	return r
}

func (r UsersAPIListUserExternalAppsRequest) Execute() (*UserExternalAppItems, *http.Response, error) {
	return r.ApiService.ListUserExternalAppsExecute(r)
}

/*
ListUserExternalApps List user external apps

**Required ACL:** `confd.users.{user_uuid}.external.apps.read`

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param userUuid the user's UUID
	@return UsersAPIListUserExternalAppsRequest
*/
func (a *UsersAPIService) ListUserExternalApps(ctx context.Context, userUuid string) UsersAPIListUserExternalAppsRequest {
	return UsersAPIListUserExternalAppsRequest{
		ApiService: a,
		ctx:        ctx,
		userUuid:   userUuid,
	}
}

// Execute executes the request
//
//	@return UserExternalAppItems
func (a *UsersAPIService) ListUserExternalAppsExecute(r UsersAPIListUserExternalAppsRequest) (*UserExternalAppItems, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *UserExternalAppItems
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersAPIService.ListUserExternalApps")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/{user_uuid}/external/apps"
	localVarPath = strings.Replace(localVarPath, "{"+"user_uuid"+"}", url.PathEscape(parameterValueToString(r.userUuid, "userUuid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.order != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "order", r.order, "")
	}
	if r.direction != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "direction", r.direction, "")
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "")
	}
	if r.offset != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "offset", r.offset, "")
	}
	if r.search != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "search", r.search, "")
	}
	if r.view != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "view", r.view, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.accentTenant != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accent-Tenant", r.accentTenant, "")
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["accent_auth_token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Auth-Token"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type UsersAPIListUserForwardsRequest struct {
	ctx        context.Context
	ApiService UsersAPI
	userId     string
}

func (r UsersAPIListUserForwardsRequest) Execute() (*UserForwards, *http.Response, error) {
	return r.ApiService.ListUserForwardsExecute(r)
}

/*
ListUserForwards List forwards for a user

**Required ACL:** `confd.users.{user_id}.forwards.read`

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param userId the user's ID or UUID
	@return UsersAPIListUserForwardsRequest
*/
func (a *UsersAPIService) ListUserForwards(ctx context.Context, userId string) UsersAPIListUserForwardsRequest {
	return UsersAPIListUserForwardsRequest{
		ApiService: a,
		ctx:        ctx,
		userId:     userId,
	}
}

// Execute executes the request
//
//	@return UserForwards
func (a *UsersAPIService) ListUserForwardsExecute(r UsersAPIListUserForwardsRequest) (*UserForwards, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *UserForwards
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersAPIService.ListUserForwards")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/{user_id}/forwards"
	localVarPath = strings.Replace(localVarPath, "{"+"user_id"+"}", url.PathEscape(parameterValueToString(r.userId, "userId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["accent_auth_token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Auth-Token"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type UsersAPIListUserFuncKeyTemplateAssociationsRequest struct {
	ctx          context.Context
	ApiService   UsersAPI
	userId       string
	accentTenant *string
}

// The tenant&#39;s UUID, defining the ownership of a given resource.
func (r UsersAPIListUserFuncKeyTemplateAssociationsRequest) AccentTenant(accentTenant string) UsersAPIListUserFuncKeyTemplateAssociationsRequest {
	r.accentTenant = &accentTenant
	return r
}

func (r UsersAPIListUserFuncKeyTemplateAssociationsRequest) Execute() (*UserFuncKeyTemplate, *http.Response, error) {
	return r.ApiService.ListUserFuncKeyTemplateAssociationsExecute(r)
}

/*
ListUserFuncKeyTemplateAssociations List funckey templates associated to user

**Required ACL:** `confd.users.{user_id}.funckeys.templates.read`

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param userId the user's ID or UUID
	@return UsersAPIListUserFuncKeyTemplateAssociationsRequest
*/
func (a *UsersAPIService) ListUserFuncKeyTemplateAssociations(ctx context.Context, userId string) UsersAPIListUserFuncKeyTemplateAssociationsRequest {
	return UsersAPIListUserFuncKeyTemplateAssociationsRequest{
		ApiService: a,
		ctx:        ctx,
		userId:     userId,
	}
}

// Execute executes the request
//
//	@return UserFuncKeyTemplate
func (a *UsersAPIService) ListUserFuncKeyTemplateAssociationsExecute(r UsersAPIListUserFuncKeyTemplateAssociationsRequest) (*UserFuncKeyTemplate, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *UserFuncKeyTemplate
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersAPIService.ListUserFuncKeyTemplateAssociations")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/{user_id}/funckeys/templates"
	localVarPath = strings.Replace(localVarPath, "{"+"user_id"+"}", url.PathEscape(parameterValueToString(r.userId, "userId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.accentTenant != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accent-Tenant", r.accentTenant, "")
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["accent_auth_token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Auth-Token"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v []string
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type UsersAPIListUserFuncKeysRequest struct {
	ctx          context.Context
	ApiService   UsersAPI
	userId       string
	accentTenant *string
}

// The tenant&#39;s UUID, defining the ownership of a given resource.
func (r UsersAPIListUserFuncKeysRequest) AccentTenant(accentTenant string) UsersAPIListUserFuncKeysRequest {
	r.accentTenant = &accentTenant
	return r
}

func (r UsersAPIListUserFuncKeysRequest) Execute() (*FuncKeyTemplate, *http.Response, error) {
	return r.ApiService.ListUserFuncKeysExecute(r)
}

/*
ListUserFuncKeys List func keys for a user

**Required ACL:** `confd.users.{user_id}.funckeys.read`

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param userId the user's ID or UUID
	@return UsersAPIListUserFuncKeysRequest
*/
func (a *UsersAPIService) ListUserFuncKeys(ctx context.Context, userId string) UsersAPIListUserFuncKeysRequest {
	return UsersAPIListUserFuncKeysRequest{
		ApiService: a,
		ctx:        ctx,
		userId:     userId,
	}
}

// Execute executes the request
//
//	@return FuncKeyTemplate
func (a *UsersAPIService) ListUserFuncKeysExecute(r UsersAPIListUserFuncKeysRequest) (*FuncKeyTemplate, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *FuncKeyTemplate
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersAPIService.ListUserFuncKeys")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/{user_id}/funckeys"
	localVarPath = strings.Replace(localVarPath, "{"+"user_id"+"}", url.PathEscape(parameterValueToString(r.userId, "userId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.accentTenant != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accent-Tenant", r.accentTenant, "")
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["accent_auth_token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Auth-Token"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type UsersAPIListUserMeetingAuthorizationsRequest struct {
	ctx         context.Context
	ApiService  UsersAPI
	meetingUuid string
}

func (r UsersAPIListUserMeetingAuthorizationsRequest) Execute() (*MeetingAuthorizationItems, *http.Response, error) {
	return r.ApiService.ListUserMeetingAuthorizationsExecute(r)
}

/*
ListUserMeetingAuthorizations List all guest authorization requests of a meeting

**Required ACL:** confd.users.me.meetings.{meeting_uuid}.authorizations.read

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param meetingUuid Meeting UUID
	@return UsersAPIListUserMeetingAuthorizationsRequest
*/
func (a *UsersAPIService) ListUserMeetingAuthorizations(ctx context.Context, meetingUuid string) UsersAPIListUserMeetingAuthorizationsRequest {
	return UsersAPIListUserMeetingAuthorizationsRequest{
		ApiService:  a,
		ctx:         ctx,
		meetingUuid: meetingUuid,
	}
}

// Execute executes the request
//
//	@return MeetingAuthorizationItems
func (a *UsersAPIService) ListUserMeetingAuthorizationsExecute(r UsersAPIListUserMeetingAuthorizationsRequest) (*MeetingAuthorizationItems, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *MeetingAuthorizationItems
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersAPIService.ListUserMeetingAuthorizations")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/user/me/meetings/{meeting_uuid}/authorizations"
	localVarPath = strings.Replace(localVarPath, "{"+"meeting_uuid"+"}", url.PathEscape(parameterValueToString(r.meetingUuid, "meetingUuid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["accent_auth_token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Auth-Token"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v []string
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type UsersAPIListUserMeetingsRequest struct {
	ctx          context.Context
	ApiService   UsersAPI
	accentTenant *string
	recurse      *bool
	order        *string
	direction    *string
	limit        *int32
	offset       *int32
	search       *string
}

// The tenant&#39;s UUID, defining the ownership of a given resource.
func (r UsersAPIListUserMeetingsRequest) AccentTenant(accentTenant string) UsersAPIListUserMeetingsRequest {
	r.accentTenant = &accentTenant
	return r
}

// Should the query include sub-tenants
func (r UsersAPIListUserMeetingsRequest) Recurse(recurse bool) UsersAPIListUserMeetingsRequest {
	r.recurse = &recurse
	return r
}

// Name of the field to use for sorting the list of items returned.
func (r UsersAPIListUserMeetingsRequest) Order(order string) UsersAPIListUserMeetingsRequest {
	r.order = &order
	return r
}

// Sort list of items in &#39;asc&#39; (ascending) or &#39;desc&#39; (descending) order
func (r UsersAPIListUserMeetingsRequest) Direction(direction string) UsersAPIListUserMeetingsRequest {
	r.direction = &direction
	return r
}

// Maximum number of items to return in the list
func (r UsersAPIListUserMeetingsRequest) Limit(limit int32) UsersAPIListUserMeetingsRequest {
	r.limit = &limit
	return r
}

// Number of items to skip over in the list. Useful for pagination.
func (r UsersAPIListUserMeetingsRequest) Offset(offset int32) UsersAPIListUserMeetingsRequest {
	r.offset = &offset
	return r
}

// Search term for filtering a list of items. Only items with a field containing the search term will be returned.
func (r UsersAPIListUserMeetingsRequest) Search(search string) UsersAPIListUserMeetingsRequest {
	r.search = &search
	return r
}

func (r UsersAPIListUserMeetingsRequest) Execute() (*MeetingItems, *http.Response, error) {
	return r.ApiService.ListUserMeetingsExecute(r)
}

/*
ListUserMeetings List user meetings

**Required ACL:** `confd.users.me.meetings.read`

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return UsersAPIListUserMeetingsRequest
*/
func (a *UsersAPIService) ListUserMeetings(ctx context.Context) UsersAPIListUserMeetingsRequest {
	return UsersAPIListUserMeetingsRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return MeetingItems
func (a *UsersAPIService) ListUserMeetingsExecute(r UsersAPIListUserMeetingsRequest) (*MeetingItems, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *MeetingItems
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersAPIService.ListUserMeetings")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/me/meetings"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.recurse != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "recurse", r.recurse, "")
	} else {
		var defaultValue bool = false
		r.recurse = &defaultValue
	}
	if r.order != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "order", r.order, "")
	}
	if r.direction != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "direction", r.direction, "")
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "")
	}
	if r.offset != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "offset", r.offset, "")
	}
	if r.search != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "search", r.search, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.accentTenant != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accent-Tenant", r.accentTenant, "")
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["accent_auth_token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Auth-Token"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type UsersAPIPutUserMeetingAuthorizationAcceptRequest struct {
	ctx               context.Context
	ApiService        UsersAPI
	meetingUuid       string
	authorizationUuid string
}

func (r UsersAPIPutUserMeetingAuthorizationAcceptRequest) Execute() (*MeetingAuthorization, *http.Response, error) {
	return r.ApiService.PutUserMeetingAuthorizationAcceptExecute(r)
}

/*
PutUserMeetingAuthorizationAccept Accept a guest authorization request

**Required ACL:** confd.users.me.meetings.{meeting_uuid}.authorizations.{authorization_uuid}.accept.update

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param meetingUuid Meeting UUID
	@param authorizationUuid Authorization UUID
	@return UsersAPIPutUserMeetingAuthorizationAcceptRequest
*/
func (a *UsersAPIService) PutUserMeetingAuthorizationAccept(ctx context.Context, meetingUuid string, authorizationUuid string) UsersAPIPutUserMeetingAuthorizationAcceptRequest {
	return UsersAPIPutUserMeetingAuthorizationAcceptRequest{
		ApiService:        a,
		ctx:               ctx,
		meetingUuid:       meetingUuid,
		authorizationUuid: authorizationUuid,
	}
}

// Execute executes the request
//
//	@return MeetingAuthorization
func (a *UsersAPIService) PutUserMeetingAuthorizationAcceptExecute(r UsersAPIPutUserMeetingAuthorizationAcceptRequest) (*MeetingAuthorization, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPut
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *MeetingAuthorization
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersAPIService.PutUserMeetingAuthorizationAccept")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/user/me/meetings/{meeting_uuid}/authorizations/{authorization_uuid}/accept"
	localVarPath = strings.Replace(localVarPath, "{"+"meeting_uuid"+"}", url.PathEscape(parameterValueToString(r.meetingUuid, "meetingUuid")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"authorization_uuid"+"}", url.PathEscape(parameterValueToString(r.authorizationUuid, "authorizationUuid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["accent_auth_token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Auth-Token"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v []string
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v []string
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type UsersAPIPutUserMeetingAuthorizationRejectRequest struct {
	ctx               context.Context
	ApiService        UsersAPI
	meetingUuid       string
	authorizationUuid string
}

func (r UsersAPIPutUserMeetingAuthorizationRejectRequest) Execute() (*MeetingAuthorization, *http.Response, error) {
	return r.ApiService.PutUserMeetingAuthorizationRejectExecute(r)
}

/*
PutUserMeetingAuthorizationReject Reject a guest authorization request

**Required ACL:** confd.users.me.meetings.{meeting_uuid}.authorizations.{authorization_uuid}.reject.update

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param meetingUuid Meeting UUID
	@param authorizationUuid Authorization UUID
	@return UsersAPIPutUserMeetingAuthorizationRejectRequest
*/
func (a *UsersAPIService) PutUserMeetingAuthorizationReject(ctx context.Context, meetingUuid string, authorizationUuid string) UsersAPIPutUserMeetingAuthorizationRejectRequest {
	return UsersAPIPutUserMeetingAuthorizationRejectRequest{
		ApiService:        a,
		ctx:               ctx,
		meetingUuid:       meetingUuid,
		authorizationUuid: authorizationUuid,
	}
}

// Execute executes the request
//
//	@return MeetingAuthorization
func (a *UsersAPIService) PutUserMeetingAuthorizationRejectExecute(r UsersAPIPutUserMeetingAuthorizationRejectRequest) (*MeetingAuthorization, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPut
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *MeetingAuthorization
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersAPIService.PutUserMeetingAuthorizationReject")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/user/me/meetings/{meeting_uuid}/authorizations/{authorization_uuid}/reject"
	localVarPath = strings.Replace(localVarPath, "{"+"meeting_uuid"+"}", url.PathEscape(parameterValueToString(r.meetingUuid, "meetingUuid")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"authorization_uuid"+"}", url.PathEscape(parameterValueToString(r.authorizationUuid, "authorizationUuid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["accent_auth_token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Auth-Token"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v []string
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v []string
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type UsersAPIUpdateCallFilterCallerUsersRequest struct {
	ctx          context.Context
	ApiService   UsersAPI
	body         *CallFilterRecipientUsersUuid
	callfilterId int32
}

// Users to associated
func (r UsersAPIUpdateCallFilterCallerUsersRequest) Body(body CallFilterRecipientUsersUuid) UsersAPIUpdateCallFilterCallerUsersRequest {
	r.body = &body
	return r
}

func (r UsersAPIUpdateCallFilterCallerUsersRequest) Execute() (*http.Response, error) {
	return r.ApiService.UpdateCallFilterCallerUsersExecute(r)
}

/*
UpdateCallFilterCallerUsers Update call filter and recipients

**Required ACL:** `confd.callfilters.{callfilter_id}.recipients.users.update` **WARNING** This endpoint remove all recipients which are not defined.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param callfilterId Call Filter's ID
	@return UsersAPIUpdateCallFilterCallerUsersRequest
*/
func (a *UsersAPIService) UpdateCallFilterCallerUsers(ctx context.Context, callfilterId int32) UsersAPIUpdateCallFilterCallerUsersRequest {
	return UsersAPIUpdateCallFilterCallerUsersRequest{
		ApiService:   a,
		ctx:          ctx,
		callfilterId: callfilterId,
	}
}

// Execute executes the request
func (a *UsersAPIService) UpdateCallFilterCallerUsersExecute(r UsersAPIUpdateCallFilterCallerUsersRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodPut
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersAPIService.UpdateCallFilterCallerUsers")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/callfilters/{callfilter_id}/recipients/users"
	localVarPath = strings.Replace(localVarPath, "{"+"callfilter_id"+"}", url.PathEscape(parameterValueToString(r.callfilterId, "callfilterId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return nil, reportError("body is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["accent_auth_token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Auth-Token"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v []string
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v []string
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type UsersAPIUpdateCallFilterMemberUsersRequest struct {
	ctx          context.Context
	ApiService   UsersAPI
	body         *UsersUuid
	callfilterId int32
}

// Users to associated
func (r UsersAPIUpdateCallFilterMemberUsersRequest) Body(body UsersUuid) UsersAPIUpdateCallFilterMemberUsersRequest {
	r.body = &body
	return r
}

func (r UsersAPIUpdateCallFilterMemberUsersRequest) Execute() (*http.Response, error) {
	return r.ApiService.UpdateCallFilterMemberUsersExecute(r)
}

/*
UpdateCallFilterMemberUsers Update call filter and surrogates

**Required ACL:** `confd.callfilters.{callfilter_id}.surrogates.users.update` **WARNING** This endpoint remove all surrogates which are not defined.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param callfilterId Call Filter's ID
	@return UsersAPIUpdateCallFilterMemberUsersRequest
*/
func (a *UsersAPIService) UpdateCallFilterMemberUsers(ctx context.Context, callfilterId int32) UsersAPIUpdateCallFilterMemberUsersRequest {
	return UsersAPIUpdateCallFilterMemberUsersRequest{
		ApiService:   a,
		ctx:          ctx,
		callfilterId: callfilterId,
	}
}

// Execute executes the request
func (a *UsersAPIService) UpdateCallFilterMemberUsersExecute(r UsersAPIUpdateCallFilterMemberUsersRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodPut
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersAPIService.UpdateCallFilterMemberUsers")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/callfilters/{callfilter_id}/surrogates/users"
	localVarPath = strings.Replace(localVarPath, "{"+"callfilter_id"+"}", url.PathEscape(parameterValueToString(r.callfilterId, "callfilterId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return nil, reportError("body is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["accent_auth_token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Auth-Token"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v []string
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v []string
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type UsersAPIUpdateCallPickupInterceptorUsersRequest struct {
	ctx          context.Context
	ApiService   UsersAPI
	body         *UsersUuid
	callpickupId int32
	accentTenant *string
}

// Users to associated
func (r UsersAPIUpdateCallPickupInterceptorUsersRequest) Body(body UsersUuid) UsersAPIUpdateCallPickupInterceptorUsersRequest {
	r.body = &body
	return r
}

// The tenant&#39;s UUID, defining the ownership of a given resource.
func (r UsersAPIUpdateCallPickupInterceptorUsersRequest) AccentTenant(accentTenant string) UsersAPIUpdateCallPickupInterceptorUsersRequest {
	r.accentTenant = &accentTenant
	return r
}

func (r UsersAPIUpdateCallPickupInterceptorUsersRequest) Execute() (*http.Response, error) {
	return r.ApiService.UpdateCallPickupInterceptorUsersExecute(r)
}

/*
UpdateCallPickupInterceptorUsers Update call pickup and interceptors

**Required ACL:** `confd.callpickups.{callpickup_id}.interceptors.users.update` **WARNING** This endpoint remove all interceptors which are not defined.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param callpickupId Call Pickup's ID
	@return UsersAPIUpdateCallPickupInterceptorUsersRequest
*/
func (a *UsersAPIService) UpdateCallPickupInterceptorUsers(ctx context.Context, callpickupId int32) UsersAPIUpdateCallPickupInterceptorUsersRequest {
	return UsersAPIUpdateCallPickupInterceptorUsersRequest{
		ApiService:   a,
		ctx:          ctx,
		callpickupId: callpickupId,
	}
}

// Execute executes the request
func (a *UsersAPIService) UpdateCallPickupInterceptorUsersExecute(r UsersAPIUpdateCallPickupInterceptorUsersRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodPut
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersAPIService.UpdateCallPickupInterceptorUsers")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/callpickups/{callpickup_id}/interceptors/users"
	localVarPath = strings.Replace(localVarPath, "{"+"callpickup_id"+"}", url.PathEscape(parameterValueToString(r.callpickupId, "callpickupId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return nil, reportError("body is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.accentTenant != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accent-Tenant", r.accentTenant, "")
	}
	// body params
	localVarPostBody = r.body
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["accent_auth_token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Auth-Token"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v []string
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v []string
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type UsersAPIUpdateCallPickupTargetUsersRequest struct {
	ctx          context.Context
	ApiService   UsersAPI
	body         *UsersUuid
	callpickupId int32
	accentTenant *string
}

// Users to associated
func (r UsersAPIUpdateCallPickupTargetUsersRequest) Body(body UsersUuid) UsersAPIUpdateCallPickupTargetUsersRequest {
	r.body = &body
	return r
}

// The tenant&#39;s UUID, defining the ownership of a given resource.
func (r UsersAPIUpdateCallPickupTargetUsersRequest) AccentTenant(accentTenant string) UsersAPIUpdateCallPickupTargetUsersRequest {
	r.accentTenant = &accentTenant
	return r
}

func (r UsersAPIUpdateCallPickupTargetUsersRequest) Execute() (*http.Response, error) {
	return r.ApiService.UpdateCallPickupTargetUsersExecute(r)
}

/*
UpdateCallPickupTargetUsers Update call pickup and targets

**Required ACL:** `confd.callpickups.{callpickup_id}.targets.users.update` **WARNING** This endpoint remove all targets which are not defined.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param callpickupId Call Pickup's ID
	@return UsersAPIUpdateCallPickupTargetUsersRequest
*/
func (a *UsersAPIService) UpdateCallPickupTargetUsers(ctx context.Context, callpickupId int32) UsersAPIUpdateCallPickupTargetUsersRequest {
	return UsersAPIUpdateCallPickupTargetUsersRequest{
		ApiService:   a,
		ctx:          ctx,
		callpickupId: callpickupId,
	}
}

// Execute executes the request
func (a *UsersAPIService) UpdateCallPickupTargetUsersExecute(r UsersAPIUpdateCallPickupTargetUsersRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodPut
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersAPIService.UpdateCallPickupTargetUsers")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/callpickups/{callpickup_id}/targets/users"
	localVarPath = strings.Replace(localVarPath, "{"+"callpickup_id"+"}", url.PathEscape(parameterValueToString(r.callpickupId, "callpickupId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return nil, reportError("body is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.accentTenant != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accent-Tenant", r.accentTenant, "")
	}
	// body params
	localVarPostBody = r.body
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["accent_auth_token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Auth-Token"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v []string
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v []string
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type UsersAPIUpdateGroupMemberUsersRequest struct {
	ctx        context.Context
	ApiService UsersAPI
	body       *GroupMemberUsers
	groupUuid  string
}

// Users to associated
func (r UsersAPIUpdateGroupMemberUsersRequest) Body(body GroupMemberUsers) UsersAPIUpdateGroupMemberUsersRequest {
	r.body = &body
	return r
}

func (r UsersAPIUpdateGroupMemberUsersRequest) Execute() (*http.Response, error) {
	return r.ApiService.UpdateGroupMemberUsersExecute(r)
}

/*
UpdateGroupMemberUsers Update group and users

**Required ACL:** `confd.groups.{group_uuid}.members.users.update`

**WARNING** This endpoint remove all members which are not defined.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param groupUuid the group's UUID
	@return UsersAPIUpdateGroupMemberUsersRequest
*/
func (a *UsersAPIService) UpdateGroupMemberUsers(ctx context.Context, groupUuid string) UsersAPIUpdateGroupMemberUsersRequest {
	return UsersAPIUpdateGroupMemberUsersRequest{
		ApiService: a,
		ctx:        ctx,
		groupUuid:  groupUuid,
	}
}

// Execute executes the request
func (a *UsersAPIService) UpdateGroupMemberUsersExecute(r UsersAPIUpdateGroupMemberUsersRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodPut
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersAPIService.UpdateGroupMemberUsers")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/groups/{group_uuid}/members/users"
	localVarPath = strings.Replace(localVarPath, "{"+"group_uuid"+"}", url.PathEscape(parameterValueToString(r.groupUuid, "groupUuid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return nil, reportError("body is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["accent_auth_token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Auth-Token"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v []string
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v []string
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type UsersAPIUpdatePagingCallerUsersRequest struct {
	ctx        context.Context
	ApiService UsersAPI
	body       *UsersUuid
	pagingId   int32
}

// Users to associated
func (r UsersAPIUpdatePagingCallerUsersRequest) Body(body UsersUuid) UsersAPIUpdatePagingCallerUsersRequest {
	r.body = &body
	return r
}

func (r UsersAPIUpdatePagingCallerUsersRequest) Execute() (*http.Response, error) {
	return r.ApiService.UpdatePagingCallerUsersExecute(r)
}

/*
UpdatePagingCallerUsers Update paging and callers

**Required ACL:** `confd.pagings.{paging_id}.callers.users.update`

**WARNING**
This endpoint remove all callers which are not defined.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param pagingId Paging's ID
	@return UsersAPIUpdatePagingCallerUsersRequest
*/
func (a *UsersAPIService) UpdatePagingCallerUsers(ctx context.Context, pagingId int32) UsersAPIUpdatePagingCallerUsersRequest {
	return UsersAPIUpdatePagingCallerUsersRequest{
		ApiService: a,
		ctx:        ctx,
		pagingId:   pagingId,
	}
}

// Execute executes the request
func (a *UsersAPIService) UpdatePagingCallerUsersExecute(r UsersAPIUpdatePagingCallerUsersRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodPut
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersAPIService.UpdatePagingCallerUsers")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/pagings/{paging_id}/callers/users"
	localVarPath = strings.Replace(localVarPath, "{"+"paging_id"+"}", url.PathEscape(parameterValueToString(r.pagingId, "pagingId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return nil, reportError("body is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["accent_auth_token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Auth-Token"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v []string
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v []string
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type UsersAPIUpdatePagingMemberUsersRequest struct {
	ctx        context.Context
	ApiService UsersAPI
	body       *UsersUuid
	pagingId   int32
}

// Users to associated
func (r UsersAPIUpdatePagingMemberUsersRequest) Body(body UsersUuid) UsersAPIUpdatePagingMemberUsersRequest {
	r.body = &body
	return r
}

func (r UsersAPIUpdatePagingMemberUsersRequest) Execute() (*http.Response, error) {
	return r.ApiService.UpdatePagingMemberUsersExecute(r)
}

/*
UpdatePagingMemberUsers Update paging and members

**Required ACL:** `confd.pagings.{paging_id}.members.users.update`

**WARNING**
This endpoint remove all members which are not defined.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param pagingId Paging's ID
	@return UsersAPIUpdatePagingMemberUsersRequest
*/
func (a *UsersAPIService) UpdatePagingMemberUsers(ctx context.Context, pagingId int32) UsersAPIUpdatePagingMemberUsersRequest {
	return UsersAPIUpdatePagingMemberUsersRequest{
		ApiService: a,
		ctx:        ctx,
		pagingId:   pagingId,
	}
}

// Execute executes the request
func (a *UsersAPIService) UpdatePagingMemberUsersExecute(r UsersAPIUpdatePagingMemberUsersRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodPut
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersAPIService.UpdatePagingMemberUsers")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/pagings/{paging_id}/members/users"
	localVarPath = strings.Replace(localVarPath, "{"+"paging_id"+"}", url.PathEscape(parameterValueToString(r.pagingId, "pagingId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return nil, reportError("body is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["accent_auth_token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Auth-Token"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v []string
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v []string
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type UsersAPIUpdateSwitchboardMemberUsersRequest struct {
	ctx             context.Context
	ApiService      UsersAPI
	body            *UsersUuid
	switchboardUuid string
}

// Users to associate with the switchboard
func (r UsersAPIUpdateSwitchboardMemberUsersRequest) Body(body UsersUuid) UsersAPIUpdateSwitchboardMemberUsersRequest {
	r.body = &body
	return r
}

func (r UsersAPIUpdateSwitchboardMemberUsersRequest) Execute() (*http.Response, error) {
	return r.ApiService.UpdateSwitchboardMemberUsersExecute(r)
}

/*
UpdateSwitchboardMemberUsers Update switchboard and members

**Required ACL:** `confd.switchboards.{switchboard_uuid}.members.users.update`

**WARNING**
This endpoint removes all members which are not defined.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param switchboardUuid
	@return UsersAPIUpdateSwitchboardMemberUsersRequest
*/
func (a *UsersAPIService) UpdateSwitchboardMemberUsers(ctx context.Context, switchboardUuid string) UsersAPIUpdateSwitchboardMemberUsersRequest {
	return UsersAPIUpdateSwitchboardMemberUsersRequest{
		ApiService:      a,
		ctx:             ctx,
		switchboardUuid: switchboardUuid,
	}
}

// Execute executes the request
func (a *UsersAPIService) UpdateSwitchboardMemberUsersExecute(r UsersAPIUpdateSwitchboardMemberUsersRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodPut
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersAPIService.UpdateSwitchboardMemberUsers")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/switchboards/{switchboard_uuid}/members/users"
	localVarPath = strings.Replace(localVarPath, "{"+"switchboard_uuid"+"}", url.PathEscape(parameterValueToString(r.switchboardUuid, "switchboardUuid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return nil, reportError("body is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["accent_auth_token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Auth-Token"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v []string
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v []string
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type UsersAPIUpdateUserRequest struct {
	ctx          context.Context
	ApiService   UsersAPI
	body         *User
	userId       string
	accentTenant *string
}

func (r UsersAPIUpdateUserRequest) Body(body User) UsersAPIUpdateUserRequest {
	r.body = &body
	return r
}

// The tenant&#39;s UUID, defining the ownership of a given resource.
func (r UsersAPIUpdateUserRequest) AccentTenant(accentTenant string) UsersAPIUpdateUserRequest {
	r.accentTenant = &accentTenant
	return r
}

func (r UsersAPIUpdateUserRequest) Execute() (*http.Response, error) {
	return r.ApiService.UpdateUserExecute(r)
}

/*
UpdateUser Update user

**Required ACL:** `confd.users.{user_id}.update`

If the firstname or the lastname is modified, the name of associated voicemail is also updated.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param userId the user's ID or UUID
	@return UsersAPIUpdateUserRequest
*/
func (a *UsersAPIService) UpdateUser(ctx context.Context, userId string) UsersAPIUpdateUserRequest {
	return UsersAPIUpdateUserRequest{
		ApiService: a,
		ctx:        ctx,
		userId:     userId,
	}
}

// Execute executes the request
func (a *UsersAPIService) UpdateUserExecute(r UsersAPIUpdateUserRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodPut
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersAPIService.UpdateUser")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/{user_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"user_id"+"}", url.PathEscape(parameterValueToString(r.userId, "userId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return nil, reportError("body is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.accentTenant != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accent-Tenant", r.accentTenant, "")
	}
	// body params
	localVarPostBody = r.body
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["accent_auth_token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Auth-Token"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v []string
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v []string
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type UsersAPIUpdateUserExternalAppRequest struct {
	ctx          context.Context
	ApiService   UsersAPI
	body         *UserExternalApp
	userUuid     string
	appName      string
	accentTenant *string
}

func (r UsersAPIUpdateUserExternalAppRequest) Body(body UserExternalApp) UsersAPIUpdateUserExternalAppRequest {
	r.body = &body
	return r
}

// The tenant&#39;s UUID, defining the ownership of a given resource.
func (r UsersAPIUpdateUserExternalAppRequest) AccentTenant(accentTenant string) UsersAPIUpdateUserExternalAppRequest {
	r.accentTenant = &accentTenant
	return r
}

func (r UsersAPIUpdateUserExternalAppRequest) Execute() (*http.Response, error) {
	return r.ApiService.UpdateUserExternalAppExecute(r)
}

/*
UpdateUserExternalApp Update user external app

**Required ACL:** `confd.users.{user_uuid}.external.apps.{app_name}.update`

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param userUuid the user's UUID
	@param appName External App's name
	@return UsersAPIUpdateUserExternalAppRequest
*/
func (a *UsersAPIService) UpdateUserExternalApp(ctx context.Context, userUuid string, appName string) UsersAPIUpdateUserExternalAppRequest {
	return UsersAPIUpdateUserExternalAppRequest{
		ApiService: a,
		ctx:        ctx,
		userUuid:   userUuid,
		appName:    appName,
	}
}

// Execute executes the request
func (a *UsersAPIService) UpdateUserExternalAppExecute(r UsersAPIUpdateUserExternalAppRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodPut
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersAPIService.UpdateUserExternalApp")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/{user_uuid}/external/apps/{app_name}"
	localVarPath = strings.Replace(localVarPath, "{"+"user_uuid"+"}", url.PathEscape(parameterValueToString(r.userUuid, "userUuid")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"app_name"+"}", url.PathEscape(parameterValueToString(r.appName, "appName")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return nil, reportError("body is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.accentTenant != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accent-Tenant", r.accentTenant, "")
	}
	// body params
	localVarPostBody = r.body
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["accent_auth_token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Auth-Token"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v []string
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v []string
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type UsersAPIUpdateUserFallbackRequest struct {
	ctx        context.Context
	ApiService UsersAPI
	userId     string
	body       *UserFallbacks
}

// Fallbacks for user
func (r UsersAPIUpdateUserFallbackRequest) Body(body UserFallbacks) UsersAPIUpdateUserFallbackRequest {
	r.body = &body
	return r
}

func (r UsersAPIUpdateUserFallbackRequest) Execute() (*http.Response, error) {
	return r.ApiService.UpdateUserFallbackExecute(r)
}

/*
UpdateUserFallback Update user's fallbacks

**Required ACL:** `confd.users.{user_id}.fallbacks.update`

**WARNING** This endpoint delete all fields that are not defined.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param userId the user's ID or UUID
	@return UsersAPIUpdateUserFallbackRequest
*/
func (a *UsersAPIService) UpdateUserFallback(ctx context.Context, userId string) UsersAPIUpdateUserFallbackRequest {
	return UsersAPIUpdateUserFallbackRequest{
		ApiService: a,
		ctx:        ctx,
		userId:     userId,
	}
}

// Execute executes the request
func (a *UsersAPIService) UpdateUserFallbackExecute(r UsersAPIUpdateUserFallbackRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodPut
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersAPIService.UpdateUserFallback")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/{user_id}/fallbacks"
	localVarPath = strings.Replace(localVarPath, "{"+"user_id"+"}", url.PathEscape(parameterValueToString(r.userId, "userId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["accent_auth_token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Auth-Token"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v []string
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v []string
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type UsersAPIUpdateUserForwardRequest struct {
	ctx         context.Context
	ApiService  UsersAPI
	body        *UserForward
	userId      string
	forwardName string
}

func (r UsersAPIUpdateUserForwardRequest) Body(body UserForward) UsersAPIUpdateUserForwardRequest {
	r.body = &body
	return r
}

func (r UsersAPIUpdateUserForwardRequest) Execute() (*http.Response, error) {
	return r.ApiService.UpdateUserForwardExecute(r)
}

/*
UpdateUserForward Update a forward for a user

**Required ACL:** `confd.users.{user_id}.forwards.{forward_name}.update`

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param userId the user's ID or UUID
	@param forwardName the forward name
	@return UsersAPIUpdateUserForwardRequest
*/
func (a *UsersAPIService) UpdateUserForward(ctx context.Context, userId string, forwardName string) UsersAPIUpdateUserForwardRequest {
	return UsersAPIUpdateUserForwardRequest{
		ApiService:  a,
		ctx:         ctx,
		userId:      userId,
		forwardName: forwardName,
	}
}

// Execute executes the request
func (a *UsersAPIService) UpdateUserForwardExecute(r UsersAPIUpdateUserForwardRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodPut
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersAPIService.UpdateUserForward")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/{user_id}/forwards/{forward_name}"
	localVarPath = strings.Replace(localVarPath, "{"+"user_id"+"}", url.PathEscape(parameterValueToString(r.userId, "userId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"forward_name"+"}", url.PathEscape(parameterValueToString(r.forwardName, "forwardName")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return nil, reportError("body is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["accent_auth_token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Auth-Token"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v []string
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type UsersAPIUpdateUserForwardsRequest struct {
	ctx        context.Context
	ApiService UsersAPI
	body       *UserForwards
	userId     string
}

func (r UsersAPIUpdateUserForwardsRequest) Body(body UserForwards) UsersAPIUpdateUserForwardsRequest {
	r.body = &body
	return r
}

func (r UsersAPIUpdateUserForwardsRequest) Execute() (*http.Response, error) {
	return r.ApiService.UpdateUserForwardsExecute(r)
}

/*
UpdateUserForwards Update all forwards for a user

**Required ACL:** `confd.users.{user_id}.forwards.update`

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param userId the user's ID or UUID
	@return UsersAPIUpdateUserForwardsRequest
*/
func (a *UsersAPIService) UpdateUserForwards(ctx context.Context, userId string) UsersAPIUpdateUserForwardsRequest {
	return UsersAPIUpdateUserForwardsRequest{
		ApiService: a,
		ctx:        ctx,
		userId:     userId,
	}
}

// Execute executes the request
func (a *UsersAPIService) UpdateUserForwardsExecute(r UsersAPIUpdateUserForwardsRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodPut
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersAPIService.UpdateUserForwards")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/{user_id}/forwards"
	localVarPath = strings.Replace(localVarPath, "{"+"user_id"+"}", url.PathEscape(parameterValueToString(r.userId, "userId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return nil, reportError("body is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["accent_auth_token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Auth-Token"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v []string
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type UsersAPIUpdateUserFuncKeyRequest struct {
	ctx          context.Context
	ApiService   UsersAPI
	body         *FuncKey
	userId       string
	position     int32
	accentTenant *string
}

func (r UsersAPIUpdateUserFuncKeyRequest) Body(body FuncKey) UsersAPIUpdateUserFuncKeyRequest {
	r.body = &body
	return r
}

// The tenant&#39;s UUID, defining the ownership of a given resource.
func (r UsersAPIUpdateUserFuncKeyRequest) AccentTenant(accentTenant string) UsersAPIUpdateUserFuncKeyRequest {
	r.accentTenant = &accentTenant
	return r
}

func (r UsersAPIUpdateUserFuncKeyRequest) Execute() (*http.Response, error) {
	return r.ApiService.UpdateUserFuncKeyExecute(r)
}

/*
UpdateUserFuncKey Add/Replace a func key for a user

**Required ACL:** `confd.users.{user_id}.funckeys.{position}.update`

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param userId the user's ID or UUID
	@param position position of the funckey
	@return UsersAPIUpdateUserFuncKeyRequest
*/
func (a *UsersAPIService) UpdateUserFuncKey(ctx context.Context, userId string, position int32) UsersAPIUpdateUserFuncKeyRequest {
	return UsersAPIUpdateUserFuncKeyRequest{
		ApiService: a,
		ctx:        ctx,
		userId:     userId,
		position:   position,
	}
}

// Execute executes the request
func (a *UsersAPIService) UpdateUserFuncKeyExecute(r UsersAPIUpdateUserFuncKeyRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodPut
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersAPIService.UpdateUserFuncKey")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/{user_id}/funckeys/{position}"
	localVarPath = strings.Replace(localVarPath, "{"+"user_id"+"}", url.PathEscape(parameterValueToString(r.userId, "userId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"position"+"}", url.PathEscape(parameterValueToString(r.position, "position")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return nil, reportError("body is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.accentTenant != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accent-Tenant", r.accentTenant, "")
	}
	// body params
	localVarPostBody = r.body
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["accent_auth_token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Auth-Token"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v []string
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type UsersAPIUpdateUserFuncKeysRequest struct {
	ctx          context.Context
	ApiService   UsersAPI
	body         *FuncKeyTemplate
	userId       string
	accentTenant *string
}

func (r UsersAPIUpdateUserFuncKeysRequest) Body(body FuncKeyTemplate) UsersAPIUpdateUserFuncKeysRequest {
	r.body = &body
	return r
}

// The tenant&#39;s UUID, defining the ownership of a given resource.
func (r UsersAPIUpdateUserFuncKeysRequest) AccentTenant(accentTenant string) UsersAPIUpdateUserFuncKeysRequest {
	r.accentTenant = &accentTenant
	return r
}

func (r UsersAPIUpdateUserFuncKeysRequest) Execute() (*http.Response, error) {
	return r.ApiService.UpdateUserFuncKeysExecute(r)
}

/*
UpdateUserFuncKeys Update func keys for a user

**Required ACL:** `confd.users.{user_id}.funckeys.update`

**WARNING** This endpoint restore to default value or delete all fields that are not defined.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param userId the user's ID or UUID
	@return UsersAPIUpdateUserFuncKeysRequest
*/
func (a *UsersAPIService) UpdateUserFuncKeys(ctx context.Context, userId string) UsersAPIUpdateUserFuncKeysRequest {
	return UsersAPIUpdateUserFuncKeysRequest{
		ApiService: a,
		ctx:        ctx,
		userId:     userId,
	}
}

// Execute executes the request
func (a *UsersAPIService) UpdateUserFuncKeysExecute(r UsersAPIUpdateUserFuncKeysRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodPut
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersAPIService.UpdateUserFuncKeys")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/{user_id}/funckeys"
	localVarPath = strings.Replace(localVarPath, "{"+"user_id"+"}", url.PathEscape(parameterValueToString(r.userId, "userId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return nil, reportError("body is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.accentTenant != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accent-Tenant", r.accentTenant, "")
	}
	// body params
	localVarPostBody = r.body
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["accent_auth_token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Auth-Token"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v []string
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type UsersAPIUpdateUserGroupsRequest struct {
	ctx        context.Context
	ApiService UsersAPI
	body       *UserGroupsID
	userId     string
}

// Users to associated
func (r UsersAPIUpdateUserGroupsRequest) Body(body UserGroupsID) UsersAPIUpdateUserGroupsRequest {
	r.body = &body
	return r
}

func (r UsersAPIUpdateUserGroupsRequest) Execute() (*http.Response, error) {
	return r.ApiService.UpdateUserGroupsExecute(r)
}

/*
UpdateUserGroups Update user and groups

**Required ACL:** `confd.users.{user_id}.groups`
**WARNING** This endpoint remove all groups which are not defined.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param userId the user's ID or UUID
	@return UsersAPIUpdateUserGroupsRequest
*/
func (a *UsersAPIService) UpdateUserGroups(ctx context.Context, userId string) UsersAPIUpdateUserGroupsRequest {
	return UsersAPIUpdateUserGroupsRequest{
		ApiService: a,
		ctx:        ctx,
		userId:     userId,
	}
}

// Execute executes the request
func (a *UsersAPIService) UpdateUserGroupsExecute(r UsersAPIUpdateUserGroupsRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodPut
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersAPIService.UpdateUserGroups")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/{user_id}/groups"
	localVarPath = strings.Replace(localVarPath, "{"+"user_id"+"}", url.PathEscape(parameterValueToString(r.userId, "userId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return nil, reportError("body is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["accent_auth_token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Auth-Token"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v []string
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v []string
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type UsersAPIUpdateUserMeetingRequest struct {
	ctx          context.Context
	ApiService   UsersAPI
	body         *MeetingRequest
	meetingUuid  string
	accentTenant *string
}

func (r UsersAPIUpdateUserMeetingRequest) Body(body MeetingRequest) UsersAPIUpdateUserMeetingRequest {
	r.body = &body
	return r
}

// The tenant&#39;s UUID, defining the ownership of a given resource.
func (r UsersAPIUpdateUserMeetingRequest) AccentTenant(accentTenant string) UsersAPIUpdateUserMeetingRequest {
	r.accentTenant = &accentTenant
	return r
}

func (r UsersAPIUpdateUserMeetingRequest) Execute() (*http.Response, error) {
	return r.ApiService.UpdateUserMeetingExecute(r)
}

/*
UpdateUserMeeting Update one of the meetings of the current user

**Required ACL:** `confd.users.me.meetings.{meeting_uuid}.update`

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param meetingUuid Meeting UUID
	@return UsersAPIUpdateUserMeetingRequest
*/
func (a *UsersAPIService) UpdateUserMeeting(ctx context.Context, meetingUuid string) UsersAPIUpdateUserMeetingRequest {
	return UsersAPIUpdateUserMeetingRequest{
		ApiService:  a,
		ctx:         ctx,
		meetingUuid: meetingUuid,
	}
}

// Execute executes the request
func (a *UsersAPIService) UpdateUserMeetingExecute(r UsersAPIUpdateUserMeetingRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodPut
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersAPIService.UpdateUserMeeting")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/me/meetings/{meeting_uuid}"
	localVarPath = strings.Replace(localVarPath, "{"+"meeting_uuid"+"}", url.PathEscape(parameterValueToString(r.meetingUuid, "meetingUuid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return nil, reportError("body is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.accentTenant != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accent-Tenant", r.accentTenant, "")
	}
	// body params
	localVarPostBody = r.body
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["accent_auth_token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Auth-Token"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v []string
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v []string
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type UsersAPIUpdateUserQueueAssociationRequest struct {
	ctx          context.Context
	ApiService   UsersAPI
	queueId      int32
	userId       string
	body         *QueueMemberUser
	accentTenant *string
}

func (r UsersAPIUpdateUserQueueAssociationRequest) Body(body QueueMemberUser) UsersAPIUpdateUserQueueAssociationRequest {
	r.body = &body
	return r
}

// The tenant&#39;s UUID, defining the ownership of a given resource.
func (r UsersAPIUpdateUserQueueAssociationRequest) AccentTenant(accentTenant string) UsersAPIUpdateUserQueueAssociationRequest {
	r.accentTenant = &accentTenant
	return r
}

func (r UsersAPIUpdateUserQueueAssociationRequest) Execute() (*http.Response, error) {
	return r.ApiService.UpdateUserQueueAssociationExecute(r)
}

/*
UpdateUserQueueAssociation Update User-Queue association

**Required ACL:** `confd.queues.{queue_id}.members.users.{user_id}.update`

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param queueId queue's ID
	@param userId the user's ID or UUID
	@return UsersAPIUpdateUserQueueAssociationRequest
*/
func (a *UsersAPIService) UpdateUserQueueAssociation(ctx context.Context, queueId int32, userId string) UsersAPIUpdateUserQueueAssociationRequest {
	return UsersAPIUpdateUserQueueAssociationRequest{
		ApiService: a,
		ctx:        ctx,
		queueId:    queueId,
		userId:     userId,
	}
}

// Execute executes the request
func (a *UsersAPIService) UpdateUserQueueAssociationExecute(r UsersAPIUpdateUserQueueAssociationRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodPut
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersAPIService.UpdateUserQueueAssociation")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/queues/{queue_id}/members/users/{user_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"queue_id"+"}", url.PathEscape(parameterValueToString(r.queueId, "queueId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"user_id"+"}", url.PathEscape(parameterValueToString(r.userId, "userId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.accentTenant != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accent-Tenant", r.accentTenant, "")
	}
	// body params
	localVarPostBody = r.body
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["accent_auth_token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Auth-Token"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v []string
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v []string
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type UsersAPIUpdateUserServiceRequest struct {
	ctx         context.Context
	ApiService  UsersAPI
	body        *UserService
	userId      string
	serviceName string
}

func (r UsersAPIUpdateUserServiceRequest) Body(body UserService) UsersAPIUpdateUserServiceRequest {
	r.body = &body
	return r
}

func (r UsersAPIUpdateUserServiceRequest) Execute() (*http.Response, error) {
	return r.ApiService.UpdateUserServiceExecute(r)
}

/*
UpdateUserService Enable/Disable service for a user

**Required ACL:** `confd.users.{user_id}.services.{service}.update`

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param userId the user's ID or UUID
	@param serviceName the service name
	@return UsersAPIUpdateUserServiceRequest
*/
func (a *UsersAPIService) UpdateUserService(ctx context.Context, userId string, serviceName string) UsersAPIUpdateUserServiceRequest {
	return UsersAPIUpdateUserServiceRequest{
		ApiService:  a,
		ctx:         ctx,
		userId:      userId,
		serviceName: serviceName,
	}
}

// Execute executes the request
func (a *UsersAPIService) UpdateUserServiceExecute(r UsersAPIUpdateUserServiceRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodPut
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersAPIService.UpdateUserService")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/{user_id}/services/{service_name}"
	localVarPath = strings.Replace(localVarPath, "{"+"user_id"+"}", url.PathEscape(parameterValueToString(r.userId, "userId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"service_name"+"}", url.PathEscape(parameterValueToString(r.serviceName, "serviceName")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return nil, reportError("body is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["accent_auth_token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Auth-Token"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v []string
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type UsersAPIUpdateUserServicesRequest struct {
	ctx        context.Context
	ApiService UsersAPI
	body       *UserServices
	userId     string
}

func (r UsersAPIUpdateUserServicesRequest) Body(body UserServices) UsersAPIUpdateUserServicesRequest {
	r.body = &body
	return r
}

func (r UsersAPIUpdateUserServicesRequest) Execute() (*http.Response, error) {
	return r.ApiService.UpdateUserServicesExecute(r)
}

/*
UpdateUserServices Update all services for a user

**Required ACL:** `confd.users.{user_id}.services.update`

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param userId the user's ID or UUID
	@return UsersAPIUpdateUserServicesRequest
*/
func (a *UsersAPIService) UpdateUserServices(ctx context.Context, userId string) UsersAPIUpdateUserServicesRequest {
	return UsersAPIUpdateUserServicesRequest{
		ApiService: a,
		ctx:        ctx,
		userId:     userId,
	}
}

// Execute executes the request
func (a *UsersAPIService) UpdateUserServicesExecute(r UsersAPIUpdateUserServicesRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodPut
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersAPIService.UpdateUserServices")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/{user_id}/services"
	localVarPath = strings.Replace(localVarPath, "{"+"user_id"+"}", url.PathEscape(parameterValueToString(r.userId, "userId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return nil, reportError("body is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["accent_auth_token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Auth-Token"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v []string
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type UsersAPIUpdateUsersCsvRequest struct {
	ctx          context.Context
	ApiService   UsersAPI
	body         *string
	accentTenant *string
}

// CSV field list available at https://accentvoice.io/uc-doc/administration/users/csv_import
func (r UsersAPIUpdateUsersCsvRequest) Body(body string) UsersAPIUpdateUsersCsvRequest {
	r.body = &body
	return r
}

// The tenant&#39;s UUID, defining the ownership of a given resource.
func (r UsersAPIUpdateUsersCsvRequest) AccentTenant(accentTenant string) UsersAPIUpdateUsersCsvRequest {
	r.accentTenant = &accentTenant
	return r
}

func (r UsersAPIUpdateUsersCsvRequest) Execute() (*UserUpdate, *http.Response, error) {
	return r.ApiService.UpdateUsersCsvExecute(r)
}

/*
UpdateUsersCsv **Disabled!** Mass import users and associated resources

** This endpoint is disabled.**
**Required ACL:** `confd.users.import.update`

CSV field list available at https://accentvoice.io/uc-doc/administration/users/csv_import
This resource has been disabled since it creates invalid configurations

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return UsersAPIUpdateUsersCsvRequest
*/
func (a *UsersAPIService) UpdateUsersCsv(ctx context.Context) UsersAPIUpdateUsersCsvRequest {
	return UsersAPIUpdateUsersCsvRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return UserUpdate
func (a *UsersAPIService) UpdateUsersCsvExecute(r UsersAPIUpdateUsersCsvRequest) (*UserUpdate, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPut
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *UserUpdate
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersAPIService.UpdateUsersCsv")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/import"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("body is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"text/csv; charset=utf-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.accentTenant != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accent-Tenant", r.accentTenant, "")
	}
	// body params
	localVarPostBody = r.body
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["accent_auth_token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Auth-Token"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v UserImportError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

/*
accent-confd

Confd exposes an API for managing core resources on a Accent server such as users, extensions, devices, voicemails, queues, etc. Resources can be associated together to provide additional functionality. For example: By associating a voicemail with a user, calls will automatically fallback on to the voicemail when the user cannot answer.  Implementation notes ====================  Errors ------  Responses containing errors will have a status code in the 400 or 500 class. A list of error messages will be returned in the body of the response as a JSON-encoded array:  ~~~ [     \"Input error - User not found\",     \"Resource error - User not associated to a line\" ] ~~~   Updating resources via PUT --------------------------  When updating a resource, all fields become optional. In other words, only values that have been changed need to be sent to the server. Please note that this behavior may change in future versions of the API.

API version: 1.1
Contact: help@accentvoice.io
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package confd

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"strings"
)

type LinesAPI interface {

	/*
		AssociateLineApplication Associate line and application

		'**Required ACL:** `confd.lines.{line_id}.applications.{application_uuid}.update`'

	**WARNING**: Association will disable the effect of the line `context` field


		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param lineId
		@param applicationUuid Application's UUID
		@return LinesAPIAssociateLineApplicationRequest
	*/
	AssociateLineApplication(ctx context.Context, lineId int32, applicationUuid int32) LinesAPIAssociateLineApplicationRequest

	// AssociateLineApplicationExecute executes the request
	AssociateLineApplicationExecute(r LinesAPIAssociateLineApplicationRequest) (*http.Response, error)

	/*
		AssociateLineDevice Associate line and device

		**Required ACL:** `confd.lines.{line_id}.devices.{device_id}.update`

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param lineId
		@param deviceId Device's ID
		@return LinesAPIAssociateLineDeviceRequest
	*/
	AssociateLineDevice(ctx context.Context, lineId int32, deviceId string) LinesAPIAssociateLineDeviceRequest

	// AssociateLineDeviceExecute executes the request
	AssociateLineDeviceExecute(r LinesAPIAssociateLineDeviceRequest) (*http.Response, error)

	/*
		AssociateLineEndpointCustom Associate line and Custom endpoint

		**Required ACL:** `confd.lines.{line_id}.endpoints.custom.{custom_id}.update`

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param lineId
		@param customId
		@return LinesAPIAssociateLineEndpointCustomRequest
	*/
	AssociateLineEndpointCustom(ctx context.Context, lineId int32, customId int32) LinesAPIAssociateLineEndpointCustomRequest

	// AssociateLineEndpointCustomExecute executes the request
	AssociateLineEndpointCustomExecute(r LinesAPIAssociateLineEndpointCustomRequest) (*http.Response, error)

	/*
		AssociateLineEndpointSccp Associate line and SCCP endpoint

		**Required ACL:** `confd.lines.{line_id}.endpoints.sccp.{sccp_id}.update`

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param lineId
		@param sccpId
		@return LinesAPIAssociateLineEndpointSccpRequest
	*/
	AssociateLineEndpointSccp(ctx context.Context, lineId int32, sccpId int32) LinesAPIAssociateLineEndpointSccpRequest

	// AssociateLineEndpointSccpExecute executes the request
	AssociateLineEndpointSccpExecute(r LinesAPIAssociateLineEndpointSccpRequest) (*http.Response, error)

	/*
		AssociateLineEndpointSip Associate line and SIP endpoint

		**Required ACL:** `confd.lines.{line_id}.endpoints.sip.{sip_uuid}.update`

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param lineId
		@param sipUuid
		@return LinesAPIAssociateLineEndpointSipRequest
	*/
	AssociateLineEndpointSip(ctx context.Context, lineId int32, sipUuid string) LinesAPIAssociateLineEndpointSipRequest

	// AssociateLineEndpointSipExecute executes the request
	AssociateLineEndpointSipExecute(r LinesAPIAssociateLineEndpointSipRequest) (*http.Response, error)

	/*
		AssociateLineExtension Associate line and extension

		**Required ACL:** `confd.lines.{line_id}.extensions.{extension_id}.update`

	Because of technical limitations, a line can only have a single ‘internal’ extension associated (i.e. an extension with a context of type ‘internal’)

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param lineId
		@param extensionId
		@return LinesAPIAssociateLineExtensionRequest
	*/
	AssociateLineExtension(ctx context.Context, lineId int32, extensionId int32) LinesAPIAssociateLineExtensionRequest

	// AssociateLineExtensionExecute executes the request
	AssociateLineExtensionExecute(r LinesAPIAssociateLineExtensionRequest) (*http.Response, error)

	/*
		AssociateUserLine Associate user and line

		**Required ACL:** `confd.users.{user_id}.lines.{line_id}.update`

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param userId the user's ID or UUID
		@param lineId
		@return LinesAPIAssociateUserLineRequest
	*/
	AssociateUserLine(ctx context.Context, userId string, lineId int32) LinesAPIAssociateUserLineRequest

	// AssociateUserLineExecute executes the request
	AssociateUserLineExecute(r LinesAPIAssociateUserLineRequest) (*http.Response, error)

	/*
		AssociateUserLines Associate user and lines

		**Required ACL:** `confd.users.{user_id}.lines.update`

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param userId the user's ID or UUID
		@return LinesAPIAssociateUserLinesRequest
	*/
	AssociateUserLines(ctx context.Context, userId string) LinesAPIAssociateUserLinesRequest

	// AssociateUserLinesExecute executes the request
	AssociateUserLinesExecute(r LinesAPIAssociateUserLinesRequest) (*http.Response, error)

	/*
		CreateLine Create line

		**Required ACL:** `confd.lines.create`

	When creating a line with an extension or a SIP endpoint as part of it's body, the line's context
	will be used as a default for the endpoint and context if ommited.


		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@return LinesAPICreateLineRequest
	*/
	CreateLine(ctx context.Context) LinesAPICreateLineRequest

	// CreateLineExecute executes the request
	//  @return LineView
	CreateLineExecute(r LinesAPICreateLineRequest) (*LineView, *http.Response, error)

	/*
		CreateLineExtension Create extension

		**Required ACL:** `confd.lines.{line_id}.extensions.create`
	The extension number must be included in one of the extension ranges for the given context.

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param lineId
		@return LinesAPICreateLineExtensionRequest
	*/
	CreateLineExtension(ctx context.Context, lineId int32) LinesAPICreateLineExtensionRequest

	// CreateLineExtensionExecute executes the request
	//  @return Extension
	CreateLineExtensionExecute(r LinesAPICreateLineExtensionRequest) (*Extension, *http.Response, error)

	/*
		DeleteLine Delete line

		**Required ACL:** `confd.lines.{line_id}.delete`

	**Disclaimer**: if `recursive=true`, the line is deleted, all their associations with any related resources are removed.

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param lineId
		@return LinesAPIDeleteLineRequest
	*/
	DeleteLine(ctx context.Context, lineId int32) LinesAPIDeleteLineRequest

	// DeleteLineExecute executes the request
	DeleteLineExecute(r LinesAPIDeleteLineRequest) (*http.Response, error)

	/*
		DissociateLineApplication Dissociate line and application

		**Required ACL:** `confd.lines.{line_id}.applications.{application_uuid}.delete`

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param lineId
		@param applicationUuid Application's UUID
		@return LinesAPIDissociateLineApplicationRequest
	*/
	DissociateLineApplication(ctx context.Context, lineId int32, applicationUuid int32) LinesAPIDissociateLineApplicationRequest

	// DissociateLineApplicationExecute executes the request
	DissociateLineApplicationExecute(r LinesAPIDissociateLineApplicationRequest) (*http.Response, error)

	/*
		DissociateLineDevice Dissociate line and device

		**Required ACL:** `confd.lines.{line_id}.devices.{device_id}.delete`

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param lineId
		@param deviceId Device's ID
		@return LinesAPIDissociateLineDeviceRequest
	*/
	DissociateLineDevice(ctx context.Context, lineId int32, deviceId string) LinesAPIDissociateLineDeviceRequest

	// DissociateLineDeviceExecute executes the request
	DissociateLineDeviceExecute(r LinesAPIDissociateLineDeviceRequest) (*http.Response, error)

	/*
		DissociateLineEndpointCustom Dissociate line and Custom endpoint

		**Required ACL:** `confd.lines.{line_id}.endpoints.custom.{custom_id}.delete`

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param lineId
		@param customId
		@return LinesAPIDissociateLineEndpointCustomRequest
	*/
	DissociateLineEndpointCustom(ctx context.Context, lineId int32, customId int32) LinesAPIDissociateLineEndpointCustomRequest

	// DissociateLineEndpointCustomExecute executes the request
	DissociateLineEndpointCustomExecute(r LinesAPIDissociateLineEndpointCustomRequest) (*http.Response, error)

	/*
		DissociateLineEndpointSccp Dissociate line and SCCP endpoint

		**Required ACL:** `confd.lines.{line_id}.endpoints.sccp.{sccp_id}.delete`

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param lineId
		@param sccpId
		@return LinesAPIDissociateLineEndpointSccpRequest
	*/
	DissociateLineEndpointSccp(ctx context.Context, lineId int32, sccpId int32) LinesAPIDissociateLineEndpointSccpRequest

	// DissociateLineEndpointSccpExecute executes the request
	DissociateLineEndpointSccpExecute(r LinesAPIDissociateLineEndpointSccpRequest) (*http.Response, error)

	/*
		DissociateLineEndpointSip Dissociate line and SIP endpoint

		**Required ACL:** `confd.lines.{line_id}.endpoints.sip.{sip_uuid}.delete`

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param lineId
		@param sipUuid
		@return LinesAPIDissociateLineEndpointSipRequest
	*/
	DissociateLineEndpointSip(ctx context.Context, lineId int32, sipUuid string) LinesAPIDissociateLineEndpointSipRequest

	// DissociateLineEndpointSipExecute executes the request
	DissociateLineEndpointSipExecute(r LinesAPIDissociateLineEndpointSipRequest) (*http.Response, error)

	/*
		DissociateLineExtension Dissociate line and extension

		**Required ACL:** `confd.lines.{line_id}.extensions.{extension_id}.delete`

	Any devices that are attached to a line must be removed before dissociating an extension from its line. A device can be dissociated by resetting it to autoprov mode.

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param lineId
		@param extensionId
		@return LinesAPIDissociateLineExtensionRequest
	*/
	DissociateLineExtension(ctx context.Context, lineId int32, extensionId int32) LinesAPIDissociateLineExtensionRequest

	// DissociateLineExtensionExecute executes the request
	DissociateLineExtensionExecute(r LinesAPIDissociateLineExtensionRequest) (*http.Response, error)

	/*
		DissociateUserLine Dissociate user and line

		**Required ACL:** `confd.users.{user_id}.lines.{line_id}.delete`

	Any devices that are attached the line must be removed before dissociating a user from its line. A device can be dissociated be resetting it to autoprov mode.

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param userId the user's ID or UUID
		@param lineId
		@return LinesAPIDissociateUserLineRequest
	*/
	DissociateUserLine(ctx context.Context, userId string, lineId int32) LinesAPIDissociateUserLineRequest

	// DissociateUserLineExecute executes the request
	DissociateUserLineExecute(r LinesAPIDissociateUserLineRequest) (*http.Response, error)

	/*
		GetDeviceLineAssociation List lines associated to device

		**Required ACL:** `confd.devices.{device_id}.lines.read`

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param deviceId Device's ID
		@return LinesAPIGetDeviceLineAssociationRequest
	*/
	GetDeviceLineAssociation(ctx context.Context, deviceId string) LinesAPIGetDeviceLineAssociationRequest

	// GetDeviceLineAssociationExecute executes the request
	//  @return LineDeviceItems
	GetDeviceLineAssociationExecute(r LinesAPIGetDeviceLineAssociationRequest) (*LineDeviceItems, *http.Response, error)

	/*
		GetLine Get line

		**Required ACL:** `confd.lines.{line_id}.read`

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param lineId
		@return LinesAPIGetLineRequest
	*/
	GetLine(ctx context.Context, lineId int32) LinesAPIGetLineRequest

	// GetLineExecute executes the request
	//  @return LineView
	GetLineExecute(r LinesAPIGetLineRequest) (*LineView, *http.Response, error)

	/*
		GetLineDevice Get Device associated to Line

		**Required ACL:** `confd.lines.{line_id}.devices.read`

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param lineId
		@return LinesAPIGetLineDeviceRequest
	*/
	GetLineDevice(ctx context.Context, lineId int32) LinesAPIGetLineDeviceRequest

	// GetLineDeviceExecute executes the request
	//  @return LineDevice
	GetLineDeviceExecute(r LinesAPIGetLineDeviceRequest) (*LineDevice, *http.Response, error)

	/*
		GetUserLineAssociatedEndpointsSip Get SIP endpoint of a line for a user

		**Required ACL:** `confd.users.{user_uuid}.lines.{line_id}.associated.endpoints.sip.read`

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param userUuid the user's UUID
		@param lineId
		@return LinesAPIGetUserLineAssociatedEndpointsSipRequest
	*/
	GetUserLineAssociatedEndpointsSip(ctx context.Context, userUuid string, lineId int32) LinesAPIGetUserLineAssociatedEndpointsSipRequest

	// GetUserLineAssociatedEndpointsSipExecute executes the request
	//  @return EndpointSIP
	GetUserLineAssociatedEndpointsSipExecute(r LinesAPIGetUserLineAssociatedEndpointsSipRequest) (*EndpointSIP, *http.Response, error)

	/*
		GetUserLineMainAssociatedEndpointsSip Get SIP endpoint of main line for a user

		**Required ACL:** `confd.users.{user_uuid}.lines.main.associated.endpoints.sip.read`

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param userUuid the user's UUID
		@return LinesAPIGetUserLineMainAssociatedEndpointsSipRequest
	*/
	GetUserLineMainAssociatedEndpointsSip(ctx context.Context, userUuid string) LinesAPIGetUserLineMainAssociatedEndpointsSipRequest

	// GetUserLineMainAssociatedEndpointsSipExecute executes the request
	//  @return EndpointSIP
	GetUserLineMainAssociatedEndpointsSipExecute(r LinesAPIGetUserLineMainAssociatedEndpointsSipRequest) (*EndpointSIP, *http.Response, error)

	/*
		ListLines List lines

		**Required ACL:** `confd.lines.read`

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@return LinesAPIListLinesRequest
	*/
	ListLines(ctx context.Context) LinesAPIListLinesRequest

	// ListLinesExecute executes the request
	//  @return LineItems
	ListLinesExecute(r LinesAPIListLinesRequest) (*LineItems, *http.Response, error)

	/*
		UpdateLine Update line

		**Required ACL:** `confd.lines.{line_id}.update`

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param lineId
		@return LinesAPIUpdateLineRequest
	*/
	UpdateLine(ctx context.Context, lineId int32) LinesAPIUpdateLineRequest

	// UpdateLineExecute executes the request
	UpdateLineExecute(r LinesAPIUpdateLineRequest) (*http.Response, error)
}

// LinesAPIService LinesAPI service
type LinesAPIService service

type LinesAPIAssociateLineApplicationRequest struct {
	ctx             context.Context
	ApiService      LinesAPI
	lineId          int32
	applicationUuid int32
	accentTenant    *string
}

// The tenant&#39;s UUID, defining the ownership of a given resource.
func (r LinesAPIAssociateLineApplicationRequest) AccentTenant(accentTenant string) LinesAPIAssociateLineApplicationRequest {
	r.accentTenant = &accentTenant
	return r
}

func (r LinesAPIAssociateLineApplicationRequest) Execute() (*http.Response, error) {
	return r.ApiService.AssociateLineApplicationExecute(r)
}

/*
AssociateLineApplication Associate line and application

'**Required ACL:** `confd.lines.{line_id}.applications.{application_uuid}.update`'

**WARNING**: Association will disable the effect of the line `context` field

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param lineId
	@param applicationUuid Application's UUID
	@return LinesAPIAssociateLineApplicationRequest
*/
func (a *LinesAPIService) AssociateLineApplication(ctx context.Context, lineId int32, applicationUuid int32) LinesAPIAssociateLineApplicationRequest {
	return LinesAPIAssociateLineApplicationRequest{
		ApiService:      a,
		ctx:             ctx,
		lineId:          lineId,
		applicationUuid: applicationUuid,
	}
}

// Execute executes the request
func (a *LinesAPIService) AssociateLineApplicationExecute(r LinesAPIAssociateLineApplicationRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodPut
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LinesAPIService.AssociateLineApplication")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/lines/{line_id}/applications/{application_uuid}"
	localVarPath = strings.Replace(localVarPath, "{"+"line_id"+"}", url.PathEscape(parameterValueToString(r.lineId, "lineId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"application_uuid"+"}", url.PathEscape(parameterValueToString(r.applicationUuid, "applicationUuid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.accentTenant != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accent-Tenant", r.accentTenant, "")
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["accent_auth_token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Auth-Token"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v []string
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v []string
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type LinesAPIAssociateLineDeviceRequest struct {
	ctx          context.Context
	ApiService   LinesAPI
	lineId       int32
	deviceId     string
	accentTenant *string
}

// The tenant&#39;s UUID, defining the ownership of a given resource.
func (r LinesAPIAssociateLineDeviceRequest) AccentTenant(accentTenant string) LinesAPIAssociateLineDeviceRequest {
	r.accentTenant = &accentTenant
	return r
}

func (r LinesAPIAssociateLineDeviceRequest) Execute() (*http.Response, error) {
	return r.ApiService.AssociateLineDeviceExecute(r)
}

/*
AssociateLineDevice Associate line and device

**Required ACL:** `confd.lines.{line_id}.devices.{device_id}.update`

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param lineId
	@param deviceId Device's ID
	@return LinesAPIAssociateLineDeviceRequest
*/
func (a *LinesAPIService) AssociateLineDevice(ctx context.Context, lineId int32, deviceId string) LinesAPIAssociateLineDeviceRequest {
	return LinesAPIAssociateLineDeviceRequest{
		ApiService: a,
		ctx:        ctx,
		lineId:     lineId,
		deviceId:   deviceId,
	}
}

// Execute executes the request
func (a *LinesAPIService) AssociateLineDeviceExecute(r LinesAPIAssociateLineDeviceRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodPut
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LinesAPIService.AssociateLineDevice")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/lines/{line_id}/devices/{device_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"line_id"+"}", url.PathEscape(parameterValueToString(r.lineId, "lineId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"device_id"+"}", url.PathEscape(parameterValueToString(r.deviceId, "deviceId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.accentTenant != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accent-Tenant", r.accentTenant, "")
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["accent_auth_token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Auth-Token"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v []string
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v []string
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type LinesAPIAssociateLineEndpointCustomRequest struct {
	ctx        context.Context
	ApiService LinesAPI
	lineId     int32
	customId   int32
}

func (r LinesAPIAssociateLineEndpointCustomRequest) Execute() (*http.Response, error) {
	return r.ApiService.AssociateLineEndpointCustomExecute(r)
}

/*
AssociateLineEndpointCustom Associate line and Custom endpoint

**Required ACL:** `confd.lines.{line_id}.endpoints.custom.{custom_id}.update`

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param lineId
	@param customId
	@return LinesAPIAssociateLineEndpointCustomRequest
*/
func (a *LinesAPIService) AssociateLineEndpointCustom(ctx context.Context, lineId int32, customId int32) LinesAPIAssociateLineEndpointCustomRequest {
	return LinesAPIAssociateLineEndpointCustomRequest{
		ApiService: a,
		ctx:        ctx,
		lineId:     lineId,
		customId:   customId,
	}
}

// Execute executes the request
func (a *LinesAPIService) AssociateLineEndpointCustomExecute(r LinesAPIAssociateLineEndpointCustomRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodPut
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LinesAPIService.AssociateLineEndpointCustom")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/lines/{line_id}/endpoints/custom/{custom_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"line_id"+"}", url.PathEscape(parameterValueToString(r.lineId, "lineId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"custom_id"+"}", url.PathEscape(parameterValueToString(r.customId, "customId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["accent_auth_token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Auth-Token"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v []string
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v []string
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type LinesAPIAssociateLineEndpointSccpRequest struct {
	ctx        context.Context
	ApiService LinesAPI
	lineId     int32
	sccpId     int32
}

func (r LinesAPIAssociateLineEndpointSccpRequest) Execute() (*http.Response, error) {
	return r.ApiService.AssociateLineEndpointSccpExecute(r)
}

/*
AssociateLineEndpointSccp Associate line and SCCP endpoint

**Required ACL:** `confd.lines.{line_id}.endpoints.sccp.{sccp_id}.update`

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param lineId
	@param sccpId
	@return LinesAPIAssociateLineEndpointSccpRequest
*/
func (a *LinesAPIService) AssociateLineEndpointSccp(ctx context.Context, lineId int32, sccpId int32) LinesAPIAssociateLineEndpointSccpRequest {
	return LinesAPIAssociateLineEndpointSccpRequest{
		ApiService: a,
		ctx:        ctx,
		lineId:     lineId,
		sccpId:     sccpId,
	}
}

// Execute executes the request
func (a *LinesAPIService) AssociateLineEndpointSccpExecute(r LinesAPIAssociateLineEndpointSccpRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodPut
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LinesAPIService.AssociateLineEndpointSccp")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/lines/{line_id}/endpoints/sccp/{sccp_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"line_id"+"}", url.PathEscape(parameterValueToString(r.lineId, "lineId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"sccp_id"+"}", url.PathEscape(parameterValueToString(r.sccpId, "sccpId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["accent_auth_token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Auth-Token"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v []string
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v []string
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type LinesAPIAssociateLineEndpointSipRequest struct {
	ctx        context.Context
	ApiService LinesAPI
	lineId     int32
	sipUuid    string
}

func (r LinesAPIAssociateLineEndpointSipRequest) Execute() (*http.Response, error) {
	return r.ApiService.AssociateLineEndpointSipExecute(r)
}

/*
AssociateLineEndpointSip Associate line and SIP endpoint

**Required ACL:** `confd.lines.{line_id}.endpoints.sip.{sip_uuid}.update`

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param lineId
	@param sipUuid
	@return LinesAPIAssociateLineEndpointSipRequest
*/
func (a *LinesAPIService) AssociateLineEndpointSip(ctx context.Context, lineId int32, sipUuid string) LinesAPIAssociateLineEndpointSipRequest {
	return LinesAPIAssociateLineEndpointSipRequest{
		ApiService: a,
		ctx:        ctx,
		lineId:     lineId,
		sipUuid:    sipUuid,
	}
}

// Execute executes the request
func (a *LinesAPIService) AssociateLineEndpointSipExecute(r LinesAPIAssociateLineEndpointSipRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodPut
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LinesAPIService.AssociateLineEndpointSip")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/lines/{line_id}/endpoints/sip/{sip_uuid}"
	localVarPath = strings.Replace(localVarPath, "{"+"line_id"+"}", url.PathEscape(parameterValueToString(r.lineId, "lineId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"sip_uuid"+"}", url.PathEscape(parameterValueToString(r.sipUuid, "sipUuid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["accent_auth_token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Auth-Token"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v []string
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v []string
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type LinesAPIAssociateLineExtensionRequest struct {
	ctx         context.Context
	ApiService  LinesAPI
	lineId      int32
	extensionId int32
}

func (r LinesAPIAssociateLineExtensionRequest) Execute() (*http.Response, error) {
	return r.ApiService.AssociateLineExtensionExecute(r)
}

/*
AssociateLineExtension Associate line and extension

**Required ACL:** `confd.lines.{line_id}.extensions.{extension_id}.update`

Because of technical limitations, a line can only have a single ‘internal’ extension associated (i.e. an extension with a context of type ‘internal’)

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param lineId
	@param extensionId
	@return LinesAPIAssociateLineExtensionRequest
*/
func (a *LinesAPIService) AssociateLineExtension(ctx context.Context, lineId int32, extensionId int32) LinesAPIAssociateLineExtensionRequest {
	return LinesAPIAssociateLineExtensionRequest{
		ApiService:  a,
		ctx:         ctx,
		lineId:      lineId,
		extensionId: extensionId,
	}
}

// Execute executes the request
func (a *LinesAPIService) AssociateLineExtensionExecute(r LinesAPIAssociateLineExtensionRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodPut
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LinesAPIService.AssociateLineExtension")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/lines/{line_id}/extensions/{extension_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"line_id"+"}", url.PathEscape(parameterValueToString(r.lineId, "lineId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"extension_id"+"}", url.PathEscape(parameterValueToString(r.extensionId, "extensionId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["accent_auth_token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Auth-Token"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v []string
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v []string
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type LinesAPIAssociateUserLineRequest struct {
	ctx        context.Context
	ApiService LinesAPI
	userId     string
	lineId     int32
}

func (r LinesAPIAssociateUserLineRequest) Execute() (*http.Response, error) {
	return r.ApiService.AssociateUserLineExecute(r)
}

/*
AssociateUserLine Associate user and line

**Required ACL:** `confd.users.{user_id}.lines.{line_id}.update`

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param userId the user's ID or UUID
	@param lineId
	@return LinesAPIAssociateUserLineRequest
*/
func (a *LinesAPIService) AssociateUserLine(ctx context.Context, userId string, lineId int32) LinesAPIAssociateUserLineRequest {
	return LinesAPIAssociateUserLineRequest{
		ApiService: a,
		ctx:        ctx,
		userId:     userId,
		lineId:     lineId,
	}
}

// Execute executes the request
func (a *LinesAPIService) AssociateUserLineExecute(r LinesAPIAssociateUserLineRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodPut
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LinesAPIService.AssociateUserLine")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/{user_id}/lines/{line_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"user_id"+"}", url.PathEscape(parameterValueToString(r.userId, "userId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"line_id"+"}", url.PathEscape(parameterValueToString(r.lineId, "lineId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["accent_auth_token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Auth-Token"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v []string
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v []string
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type LinesAPIAssociateUserLinesRequest struct {
	ctx        context.Context
	ApiService LinesAPI
	body       *LinesID
	userId     string
}

func (r LinesAPIAssociateUserLinesRequest) Body(body LinesID) LinesAPIAssociateUserLinesRequest {
	r.body = &body
	return r
}

func (r LinesAPIAssociateUserLinesRequest) Execute() (*http.Response, error) {
	return r.ApiService.AssociateUserLinesExecute(r)
}

/*
AssociateUserLines Associate user and lines

**Required ACL:** `confd.users.{user_id}.lines.update`

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param userId the user's ID or UUID
	@return LinesAPIAssociateUserLinesRequest
*/
func (a *LinesAPIService) AssociateUserLines(ctx context.Context, userId string) LinesAPIAssociateUserLinesRequest {
	return LinesAPIAssociateUserLinesRequest{
		ApiService: a,
		ctx:        ctx,
		userId:     userId,
	}
}

// Execute executes the request
func (a *LinesAPIService) AssociateUserLinesExecute(r LinesAPIAssociateUserLinesRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodPut
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LinesAPIService.AssociateUserLines")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/{user_id}/lines"
	localVarPath = strings.Replace(localVarPath, "{"+"user_id"+"}", url.PathEscape(parameterValueToString(r.userId, "userId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return nil, reportError("body is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["accent_auth_token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Auth-Token"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v []string
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v []string
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type LinesAPICreateLineRequest struct {
	ctx          context.Context
	ApiService   LinesAPI
	body         *LineCreate
	accentTenant *string
}

func (r LinesAPICreateLineRequest) Body(body LineCreate) LinesAPICreateLineRequest {
	r.body = &body
	return r
}

// The tenant&#39;s UUID, defining the ownership of a given resource.
func (r LinesAPICreateLineRequest) AccentTenant(accentTenant string) LinesAPICreateLineRequest {
	r.accentTenant = &accentTenant
	return r
}

func (r LinesAPICreateLineRequest) Execute() (*LineView, *http.Response, error) {
	return r.ApiService.CreateLineExecute(r)
}

/*
CreateLine Create line

**Required ACL:** `confd.lines.create`

When creating a line with an extension or a SIP endpoint as part of it's body, the line's context
will be used as a default for the endpoint and context if ommited.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return LinesAPICreateLineRequest
*/
func (a *LinesAPIService) CreateLine(ctx context.Context) LinesAPICreateLineRequest {
	return LinesAPICreateLineRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return LineView
func (a *LinesAPIService) CreateLineExecute(r LinesAPICreateLineRequest) (*LineView, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *LineView
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LinesAPIService.CreateLine")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/lines"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("body is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.accentTenant != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accent-Tenant", r.accentTenant, "")
	}
	// body params
	localVarPostBody = r.body
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["accent_auth_token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Auth-Token"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v []string
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type LinesAPICreateLineExtensionRequest struct {
	ctx          context.Context
	ApiService   LinesAPI
	body         *Extension
	lineId       int32
	accentTenant *string
}

// Extension to create
func (r LinesAPICreateLineExtensionRequest) Body(body Extension) LinesAPICreateLineExtensionRequest {
	r.body = &body
	return r
}

// The tenant&#39;s UUID, defining the ownership of a given resource.
func (r LinesAPICreateLineExtensionRequest) AccentTenant(accentTenant string) LinesAPICreateLineExtensionRequest {
	r.accentTenant = &accentTenant
	return r
}

func (r LinesAPICreateLineExtensionRequest) Execute() (*Extension, *http.Response, error) {
	return r.ApiService.CreateLineExtensionExecute(r)
}

/*
CreateLineExtension Create extension

**Required ACL:** `confd.lines.{line_id}.extensions.create`
The extension number must be included in one of the extension ranges for the given context.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param lineId
	@return LinesAPICreateLineExtensionRequest
*/
func (a *LinesAPIService) CreateLineExtension(ctx context.Context, lineId int32) LinesAPICreateLineExtensionRequest {
	return LinesAPICreateLineExtensionRequest{
		ApiService: a,
		ctx:        ctx,
		lineId:     lineId,
	}
}

// Execute executes the request
//
//	@return Extension
func (a *LinesAPIService) CreateLineExtensionExecute(r LinesAPICreateLineExtensionRequest) (*Extension, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *Extension
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LinesAPIService.CreateLineExtension")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/lines/{line_id}/extensions"
	localVarPath = strings.Replace(localVarPath, "{"+"line_id"+"}", url.PathEscape(parameterValueToString(r.lineId, "lineId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("body is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.accentTenant != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accent-Tenant", r.accentTenant, "")
	}
	// body params
	localVarPostBody = r.body
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["accent_auth_token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Auth-Token"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v []string
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v Object
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type LinesAPIDeleteLineRequest struct {
	ctx          context.Context
	ApiService   LinesAPI
	lineId       int32
	accentTenant *string
}

// The tenant&#39;s UUID, defining the ownership of a given resource.
func (r LinesAPIDeleteLineRequest) AccentTenant(accentTenant string) LinesAPIDeleteLineRequest {
	r.accentTenant = &accentTenant
	return r
}

func (r LinesAPIDeleteLineRequest) Execute() (*http.Response, error) {
	return r.ApiService.DeleteLineExecute(r)
}

/*
DeleteLine Delete line

**Required ACL:** `confd.lines.{line_id}.delete`

**Disclaimer**: if `recursive=true`, the line is deleted, all their associations with any related resources are removed.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param lineId
	@return LinesAPIDeleteLineRequest
*/
func (a *LinesAPIService) DeleteLine(ctx context.Context, lineId int32) LinesAPIDeleteLineRequest {
	return LinesAPIDeleteLineRequest{
		ApiService: a,
		ctx:        ctx,
		lineId:     lineId,
	}
}

// Execute executes the request
func (a *LinesAPIService) DeleteLineExecute(r LinesAPIDeleteLineRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodDelete
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LinesAPIService.DeleteLine")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/lines/{line_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"line_id"+"}", url.PathEscape(parameterValueToString(r.lineId, "lineId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.accentTenant != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accent-Tenant", r.accentTenant, "")
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["accent_auth_token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Auth-Token"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v []string
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type LinesAPIDissociateLineApplicationRequest struct {
	ctx             context.Context
	ApiService      LinesAPI
	lineId          int32
	applicationUuid int32
	accentTenant    *string
}

// The tenant&#39;s UUID, defining the ownership of a given resource.
func (r LinesAPIDissociateLineApplicationRequest) AccentTenant(accentTenant string) LinesAPIDissociateLineApplicationRequest {
	r.accentTenant = &accentTenant
	return r
}

func (r LinesAPIDissociateLineApplicationRequest) Execute() (*http.Response, error) {
	return r.ApiService.DissociateLineApplicationExecute(r)
}

/*
DissociateLineApplication Dissociate line and application

**Required ACL:** `confd.lines.{line_id}.applications.{application_uuid}.delete`

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param lineId
	@param applicationUuid Application's UUID
	@return LinesAPIDissociateLineApplicationRequest
*/
func (a *LinesAPIService) DissociateLineApplication(ctx context.Context, lineId int32, applicationUuid int32) LinesAPIDissociateLineApplicationRequest {
	return LinesAPIDissociateLineApplicationRequest{
		ApiService:      a,
		ctx:             ctx,
		lineId:          lineId,
		applicationUuid: applicationUuid,
	}
}

// Execute executes the request
func (a *LinesAPIService) DissociateLineApplicationExecute(r LinesAPIDissociateLineApplicationRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodDelete
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LinesAPIService.DissociateLineApplication")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/lines/{line_id}/applications/{application_uuid}"
	localVarPath = strings.Replace(localVarPath, "{"+"line_id"+"}", url.PathEscape(parameterValueToString(r.lineId, "lineId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"application_uuid"+"}", url.PathEscape(parameterValueToString(r.applicationUuid, "applicationUuid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.accentTenant != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accent-Tenant", r.accentTenant, "")
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["accent_auth_token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Auth-Token"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v []string
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v []string
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type LinesAPIDissociateLineDeviceRequest struct {
	ctx          context.Context
	ApiService   LinesAPI
	lineId       int32
	deviceId     string
	accentTenant *string
}

// The tenant&#39;s UUID, defining the ownership of a given resource.
func (r LinesAPIDissociateLineDeviceRequest) AccentTenant(accentTenant string) LinesAPIDissociateLineDeviceRequest {
	r.accentTenant = &accentTenant
	return r
}

func (r LinesAPIDissociateLineDeviceRequest) Execute() (*http.Response, error) {
	return r.ApiService.DissociateLineDeviceExecute(r)
}

/*
DissociateLineDevice Dissociate line and device

**Required ACL:** `confd.lines.{line_id}.devices.{device_id}.delete`

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param lineId
	@param deviceId Device's ID
	@return LinesAPIDissociateLineDeviceRequest
*/
func (a *LinesAPIService) DissociateLineDevice(ctx context.Context, lineId int32, deviceId string) LinesAPIDissociateLineDeviceRequest {
	return LinesAPIDissociateLineDeviceRequest{
		ApiService: a,
		ctx:        ctx,
		lineId:     lineId,
		deviceId:   deviceId,
	}
}

// Execute executes the request
func (a *LinesAPIService) DissociateLineDeviceExecute(r LinesAPIDissociateLineDeviceRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodDelete
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LinesAPIService.DissociateLineDevice")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/lines/{line_id}/devices/{device_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"line_id"+"}", url.PathEscape(parameterValueToString(r.lineId, "lineId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"device_id"+"}", url.PathEscape(parameterValueToString(r.deviceId, "deviceId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.accentTenant != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accent-Tenant", r.accentTenant, "")
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["accent_auth_token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Auth-Token"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v []string
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v []string
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type LinesAPIDissociateLineEndpointCustomRequest struct {
	ctx        context.Context
	ApiService LinesAPI
	lineId     int32
	customId   int32
}

func (r LinesAPIDissociateLineEndpointCustomRequest) Execute() (*http.Response, error) {
	return r.ApiService.DissociateLineEndpointCustomExecute(r)
}

/*
DissociateLineEndpointCustom Dissociate line and Custom endpoint

**Required ACL:** `confd.lines.{line_id}.endpoints.custom.{custom_id}.delete`

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param lineId
	@param customId
	@return LinesAPIDissociateLineEndpointCustomRequest
*/
func (a *LinesAPIService) DissociateLineEndpointCustom(ctx context.Context, lineId int32, customId int32) LinesAPIDissociateLineEndpointCustomRequest {
	return LinesAPIDissociateLineEndpointCustomRequest{
		ApiService: a,
		ctx:        ctx,
		lineId:     lineId,
		customId:   customId,
	}
}

// Execute executes the request
func (a *LinesAPIService) DissociateLineEndpointCustomExecute(r LinesAPIDissociateLineEndpointCustomRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodDelete
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LinesAPIService.DissociateLineEndpointCustom")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/lines/{line_id}/endpoints/custom/{custom_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"line_id"+"}", url.PathEscape(parameterValueToString(r.lineId, "lineId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"custom_id"+"}", url.PathEscape(parameterValueToString(r.customId, "customId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["accent_auth_token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Auth-Token"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v []string
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v []string
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type LinesAPIDissociateLineEndpointSccpRequest struct {
	ctx        context.Context
	ApiService LinesAPI
	lineId     int32
	sccpId     int32
}

func (r LinesAPIDissociateLineEndpointSccpRequest) Execute() (*http.Response, error) {
	return r.ApiService.DissociateLineEndpointSccpExecute(r)
}

/*
DissociateLineEndpointSccp Dissociate line and SCCP endpoint

**Required ACL:** `confd.lines.{line_id}.endpoints.sccp.{sccp_id}.delete`

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param lineId
	@param sccpId
	@return LinesAPIDissociateLineEndpointSccpRequest
*/
func (a *LinesAPIService) DissociateLineEndpointSccp(ctx context.Context, lineId int32, sccpId int32) LinesAPIDissociateLineEndpointSccpRequest {
	return LinesAPIDissociateLineEndpointSccpRequest{
		ApiService: a,
		ctx:        ctx,
		lineId:     lineId,
		sccpId:     sccpId,
	}
}

// Execute executes the request
func (a *LinesAPIService) DissociateLineEndpointSccpExecute(r LinesAPIDissociateLineEndpointSccpRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodDelete
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LinesAPIService.DissociateLineEndpointSccp")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/lines/{line_id}/endpoints/sccp/{sccp_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"line_id"+"}", url.PathEscape(parameterValueToString(r.lineId, "lineId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"sccp_id"+"}", url.PathEscape(parameterValueToString(r.sccpId, "sccpId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["accent_auth_token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Auth-Token"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v []string
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v []string
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type LinesAPIDissociateLineEndpointSipRequest struct {
	ctx        context.Context
	ApiService LinesAPI
	lineId     int32
	sipUuid    string
}

func (r LinesAPIDissociateLineEndpointSipRequest) Execute() (*http.Response, error) {
	return r.ApiService.DissociateLineEndpointSipExecute(r)
}

/*
DissociateLineEndpointSip Dissociate line and SIP endpoint

**Required ACL:** `confd.lines.{line_id}.endpoints.sip.{sip_uuid}.delete`

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param lineId
	@param sipUuid
	@return LinesAPIDissociateLineEndpointSipRequest
*/
func (a *LinesAPIService) DissociateLineEndpointSip(ctx context.Context, lineId int32, sipUuid string) LinesAPIDissociateLineEndpointSipRequest {
	return LinesAPIDissociateLineEndpointSipRequest{
		ApiService: a,
		ctx:        ctx,
		lineId:     lineId,
		sipUuid:    sipUuid,
	}
}

// Execute executes the request
func (a *LinesAPIService) DissociateLineEndpointSipExecute(r LinesAPIDissociateLineEndpointSipRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodDelete
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LinesAPIService.DissociateLineEndpointSip")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/lines/{line_id}/endpoints/sip/{sip_uuid}"
	localVarPath = strings.Replace(localVarPath, "{"+"line_id"+"}", url.PathEscape(parameterValueToString(r.lineId, "lineId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"sip_uuid"+"}", url.PathEscape(parameterValueToString(r.sipUuid, "sipUuid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["accent_auth_token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Auth-Token"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v []string
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v []string
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type LinesAPIDissociateLineExtensionRequest struct {
	ctx         context.Context
	ApiService  LinesAPI
	lineId      int32
	extensionId int32
}

func (r LinesAPIDissociateLineExtensionRequest) Execute() (*http.Response, error) {
	return r.ApiService.DissociateLineExtensionExecute(r)
}

/*
DissociateLineExtension Dissociate line and extension

**Required ACL:** `confd.lines.{line_id}.extensions.{extension_id}.delete`

Any devices that are attached to a line must be removed before dissociating an extension from its line. A device can be dissociated by resetting it to autoprov mode.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param lineId
	@param extensionId
	@return LinesAPIDissociateLineExtensionRequest
*/
func (a *LinesAPIService) DissociateLineExtension(ctx context.Context, lineId int32, extensionId int32) LinesAPIDissociateLineExtensionRequest {
	return LinesAPIDissociateLineExtensionRequest{
		ApiService:  a,
		ctx:         ctx,
		lineId:      lineId,
		extensionId: extensionId,
	}
}

// Execute executes the request
func (a *LinesAPIService) DissociateLineExtensionExecute(r LinesAPIDissociateLineExtensionRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodDelete
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LinesAPIService.DissociateLineExtension")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/lines/{line_id}/extensions/{extension_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"line_id"+"}", url.PathEscape(parameterValueToString(r.lineId, "lineId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"extension_id"+"}", url.PathEscape(parameterValueToString(r.extensionId, "extensionId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["accent_auth_token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Auth-Token"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v []string
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v []string
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type LinesAPIDissociateUserLineRequest struct {
	ctx        context.Context
	ApiService LinesAPI
	userId     string
	lineId     int32
}

func (r LinesAPIDissociateUserLineRequest) Execute() (*http.Response, error) {
	return r.ApiService.DissociateUserLineExecute(r)
}

/*
DissociateUserLine Dissociate user and line

**Required ACL:** `confd.users.{user_id}.lines.{line_id}.delete`

Any devices that are attached the line must be removed before dissociating a user from its line. A device can be dissociated be resetting it to autoprov mode.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param userId the user's ID or UUID
	@param lineId
	@return LinesAPIDissociateUserLineRequest
*/
func (a *LinesAPIService) DissociateUserLine(ctx context.Context, userId string, lineId int32) LinesAPIDissociateUserLineRequest {
	return LinesAPIDissociateUserLineRequest{
		ApiService: a,
		ctx:        ctx,
		userId:     userId,
		lineId:     lineId,
	}
}

// Execute executes the request
func (a *LinesAPIService) DissociateUserLineExecute(r LinesAPIDissociateUserLineRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodDelete
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LinesAPIService.DissociateUserLine")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/{user_id}/lines/{line_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"user_id"+"}", url.PathEscape(parameterValueToString(r.userId, "userId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"line_id"+"}", url.PathEscape(parameterValueToString(r.lineId, "lineId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["accent_auth_token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Auth-Token"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v []string
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v []string
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type LinesAPIGetDeviceLineAssociationRequest struct {
	ctx          context.Context
	ApiService   LinesAPI
	deviceId     string
	accentTenant *string
}

// The tenant&#39;s UUID, defining the ownership of a given resource.
func (r LinesAPIGetDeviceLineAssociationRequest) AccentTenant(accentTenant string) LinesAPIGetDeviceLineAssociationRequest {
	r.accentTenant = &accentTenant
	return r
}

func (r LinesAPIGetDeviceLineAssociationRequest) Execute() (*LineDeviceItems, *http.Response, error) {
	return r.ApiService.GetDeviceLineAssociationExecute(r)
}

/*
GetDeviceLineAssociation List lines associated to device

**Required ACL:** `confd.devices.{device_id}.lines.read`

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param deviceId Device's ID
	@return LinesAPIGetDeviceLineAssociationRequest
*/
func (a *LinesAPIService) GetDeviceLineAssociation(ctx context.Context, deviceId string) LinesAPIGetDeviceLineAssociationRequest {
	return LinesAPIGetDeviceLineAssociationRequest{
		ApiService: a,
		ctx:        ctx,
		deviceId:   deviceId,
	}
}

// Execute executes the request
//
//	@return LineDeviceItems
func (a *LinesAPIService) GetDeviceLineAssociationExecute(r LinesAPIGetDeviceLineAssociationRequest) (*LineDeviceItems, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *LineDeviceItems
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LinesAPIService.GetDeviceLineAssociation")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/devices/{device_id}/lines"
	localVarPath = strings.Replace(localVarPath, "{"+"device_id"+"}", url.PathEscape(parameterValueToString(r.deviceId, "deviceId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.accentTenant != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accent-Tenant", r.accentTenant, "")
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["accent_auth_token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Auth-Token"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v []string
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type LinesAPIGetLineRequest struct {
	ctx          context.Context
	ApiService   LinesAPI
	lineId       int32
	accentTenant *string
}

// The tenant&#39;s UUID, defining the ownership of a given resource.
func (r LinesAPIGetLineRequest) AccentTenant(accentTenant string) LinesAPIGetLineRequest {
	r.accentTenant = &accentTenant
	return r
}

func (r LinesAPIGetLineRequest) Execute() (*LineView, *http.Response, error) {
	return r.ApiService.GetLineExecute(r)
}

/*
GetLine Get line

**Required ACL:** `confd.lines.{line_id}.read`

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param lineId
	@return LinesAPIGetLineRequest
*/
func (a *LinesAPIService) GetLine(ctx context.Context, lineId int32) LinesAPIGetLineRequest {
	return LinesAPIGetLineRequest{
		ApiService: a,
		ctx:        ctx,
		lineId:     lineId,
	}
}

// Execute executes the request
//
//	@return LineView
func (a *LinesAPIService) GetLineExecute(r LinesAPIGetLineRequest) (*LineView, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *LineView
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LinesAPIService.GetLine")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/lines/{line_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"line_id"+"}", url.PathEscape(parameterValueToString(r.lineId, "lineId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.accentTenant != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accent-Tenant", r.accentTenant, "")
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["accent_auth_token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Auth-Token"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v []string
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type LinesAPIGetLineDeviceRequest struct {
	ctx          context.Context
	ApiService   LinesAPI
	lineId       int32
	accentTenant *string
}

// The tenant&#39;s UUID, defining the ownership of a given resource.
func (r LinesAPIGetLineDeviceRequest) AccentTenant(accentTenant string) LinesAPIGetLineDeviceRequest {
	r.accentTenant = &accentTenant
	return r
}

func (r LinesAPIGetLineDeviceRequest) Execute() (*LineDevice, *http.Response, error) {
	return r.ApiService.GetLineDeviceExecute(r)
}

/*
GetLineDevice Get Device associated to Line

**Required ACL:** `confd.lines.{line_id}.devices.read`

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param lineId
	@return LinesAPIGetLineDeviceRequest
*/
func (a *LinesAPIService) GetLineDevice(ctx context.Context, lineId int32) LinesAPIGetLineDeviceRequest {
	return LinesAPIGetLineDeviceRequest{
		ApiService: a,
		ctx:        ctx,
		lineId:     lineId,
	}
}

// Execute executes the request
//
//	@return LineDevice
func (a *LinesAPIService) GetLineDeviceExecute(r LinesAPIGetLineDeviceRequest) (*LineDevice, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *LineDevice
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LinesAPIService.GetLineDevice")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/lines/{line_id}/devices"
	localVarPath = strings.Replace(localVarPath, "{"+"line_id"+"}", url.PathEscape(parameterValueToString(r.lineId, "lineId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.accentTenant != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accent-Tenant", r.accentTenant, "")
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["accent_auth_token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Auth-Token"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v []string
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v []string
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type LinesAPIGetUserLineAssociatedEndpointsSipRequest struct {
	ctx        context.Context
	ApiService LinesAPI
	userUuid   string
	lineId     int32
	view       *string
}

// Different view of the SIP endpoint  The &#x60;default&#x60; view, when the argument is omitted, is to include only options that are defined on the specified endpoint.  The &#x60;merged&#x60; view includes all options from included templates.
func (r LinesAPIGetUserLineAssociatedEndpointsSipRequest) View(view string) LinesAPIGetUserLineAssociatedEndpointsSipRequest {
	r.view = &view
	return r
}

func (r LinesAPIGetUserLineAssociatedEndpointsSipRequest) Execute() (*EndpointSIP, *http.Response, error) {
	return r.ApiService.GetUserLineAssociatedEndpointsSipExecute(r)
}

/*
GetUserLineAssociatedEndpointsSip Get SIP endpoint of a line for a user

**Required ACL:** `confd.users.{user_uuid}.lines.{line_id}.associated.endpoints.sip.read`

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param userUuid the user's UUID
	@param lineId
	@return LinesAPIGetUserLineAssociatedEndpointsSipRequest
*/
func (a *LinesAPIService) GetUserLineAssociatedEndpointsSip(ctx context.Context, userUuid string, lineId int32) LinesAPIGetUserLineAssociatedEndpointsSipRequest {
	return LinesAPIGetUserLineAssociatedEndpointsSipRequest{
		ApiService: a,
		ctx:        ctx,
		userUuid:   userUuid,
		lineId:     lineId,
	}
}

// Execute executes the request
//
//	@return EndpointSIP
func (a *LinesAPIService) GetUserLineAssociatedEndpointsSipExecute(r LinesAPIGetUserLineAssociatedEndpointsSipRequest) (*EndpointSIP, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *EndpointSIP
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LinesAPIService.GetUserLineAssociatedEndpointsSip")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/{user_uuid}/lines/{line_id}/associated/endpoints/sip"
	localVarPath = strings.Replace(localVarPath, "{"+"user_uuid"+"}", url.PathEscape(parameterValueToString(r.userUuid, "userUuid")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"line_id"+"}", url.PathEscape(parameterValueToString(r.lineId, "lineId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.view != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "view", r.view, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["accent_auth_token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Auth-Token"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type LinesAPIGetUserLineMainAssociatedEndpointsSipRequest struct {
	ctx        context.Context
	ApiService LinesAPI
	userUuid   string
	view       *string
}

// Different view of the SIP endpoint  The &#x60;default&#x60; view, when the argument is omitted, is to include only options that are defined on the specified endpoint.  The &#x60;merged&#x60; view includes all options from included templates.
func (r LinesAPIGetUserLineMainAssociatedEndpointsSipRequest) View(view string) LinesAPIGetUserLineMainAssociatedEndpointsSipRequest {
	r.view = &view
	return r
}

func (r LinesAPIGetUserLineMainAssociatedEndpointsSipRequest) Execute() (*EndpointSIP, *http.Response, error) {
	return r.ApiService.GetUserLineMainAssociatedEndpointsSipExecute(r)
}

/*
GetUserLineMainAssociatedEndpointsSip Get SIP endpoint of main line for a user

**Required ACL:** `confd.users.{user_uuid}.lines.main.associated.endpoints.sip.read`

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param userUuid the user's UUID
	@return LinesAPIGetUserLineMainAssociatedEndpointsSipRequest
*/
func (a *LinesAPIService) GetUserLineMainAssociatedEndpointsSip(ctx context.Context, userUuid string) LinesAPIGetUserLineMainAssociatedEndpointsSipRequest {
	return LinesAPIGetUserLineMainAssociatedEndpointsSipRequest{
		ApiService: a,
		ctx:        ctx,
		userUuid:   userUuid,
	}
}

// Execute executes the request
//
//	@return EndpointSIP
func (a *LinesAPIService) GetUserLineMainAssociatedEndpointsSipExecute(r LinesAPIGetUserLineMainAssociatedEndpointsSipRequest) (*EndpointSIP, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *EndpointSIP
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LinesAPIService.GetUserLineMainAssociatedEndpointsSip")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/{user_uuid}/lines/main/associated/endpoints/sip"
	localVarPath = strings.Replace(localVarPath, "{"+"user_uuid"+"}", url.PathEscape(parameterValueToString(r.userUuid, "userUuid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.view != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "view", r.view, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["accent_auth_token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Auth-Token"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type LinesAPIListLinesRequest struct {
	ctx          context.Context
	ApiService   LinesAPI
	accentTenant *string
	recurse      *bool
	order        *string
	direction    *string
	limit        *int32
	offset       *int32
	search       *string
}

// The tenant&#39;s UUID, defining the ownership of a given resource.
func (r LinesAPIListLinesRequest) AccentTenant(accentTenant string) LinesAPIListLinesRequest {
	r.accentTenant = &accentTenant
	return r
}

// Should the query include sub-tenants
func (r LinesAPIListLinesRequest) Recurse(recurse bool) LinesAPIListLinesRequest {
	r.recurse = &recurse
	return r
}

// Name of the field to use for sorting the list of items returned.
func (r LinesAPIListLinesRequest) Order(order string) LinesAPIListLinesRequest {
	r.order = &order
	return r
}

// Sort list of items in &#39;asc&#39; (ascending) or &#39;desc&#39; (descending) order
func (r LinesAPIListLinesRequest) Direction(direction string) LinesAPIListLinesRequest {
	r.direction = &direction
	return r
}

// Maximum number of items to return in the list
func (r LinesAPIListLinesRequest) Limit(limit int32) LinesAPIListLinesRequest {
	r.limit = &limit
	return r
}

// Number of items to skip over in the list. Useful for pagination.
func (r LinesAPIListLinesRequest) Offset(offset int32) LinesAPIListLinesRequest {
	r.offset = &offset
	return r
}

// Search term for filtering a list of items. Only items with a field containing the search term will be returned.
func (r LinesAPIListLinesRequest) Search(search string) LinesAPIListLinesRequest {
	r.search = &search
	return r
}

func (r LinesAPIListLinesRequest) Execute() (*LineItems, *http.Response, error) {
	return r.ApiService.ListLinesExecute(r)
}

/*
ListLines List lines

**Required ACL:** `confd.lines.read`

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return LinesAPIListLinesRequest
*/
func (a *LinesAPIService) ListLines(ctx context.Context) LinesAPIListLinesRequest {
	return LinesAPIListLinesRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return LineItems
func (a *LinesAPIService) ListLinesExecute(r LinesAPIListLinesRequest) (*LineItems, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *LineItems
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LinesAPIService.ListLines")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/lines"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.recurse != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "recurse", r.recurse, "")
	} else {
		var defaultValue bool = false
		r.recurse = &defaultValue
	}
	if r.order != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "order", r.order, "")
	}
	if r.direction != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "direction", r.direction, "")
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "")
	}
	if r.offset != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "offset", r.offset, "")
	}
	if r.search != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "search", r.search, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.accentTenant != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accent-Tenant", r.accentTenant, "")
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["accent_auth_token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Auth-Token"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type LinesAPIUpdateLineRequest struct {
	ctx          context.Context
	ApiService   LinesAPI
	body         *Line
	lineId       int32
	accentTenant *string
}

func (r LinesAPIUpdateLineRequest) Body(body Line) LinesAPIUpdateLineRequest {
	r.body = &body
	return r
}

// The tenant&#39;s UUID, defining the ownership of a given resource.
func (r LinesAPIUpdateLineRequest) AccentTenant(accentTenant string) LinesAPIUpdateLineRequest {
	r.accentTenant = &accentTenant
	return r
}

func (r LinesAPIUpdateLineRequest) Execute() (*http.Response, error) {
	return r.ApiService.UpdateLineExecute(r)
}

/*
UpdateLine Update line

**Required ACL:** `confd.lines.{line_id}.update`

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param lineId
	@return LinesAPIUpdateLineRequest
*/
func (a *LinesAPIService) UpdateLine(ctx context.Context, lineId int32) LinesAPIUpdateLineRequest {
	return LinesAPIUpdateLineRequest{
		ApiService: a,
		ctx:        ctx,
		lineId:     lineId,
	}
}

// Execute executes the request
func (a *LinesAPIService) UpdateLineExecute(r LinesAPIUpdateLineRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodPut
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LinesAPIService.UpdateLine")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/lines/{line_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"line_id"+"}", url.PathEscape(parameterValueToString(r.lineId, "lineId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return nil, reportError("body is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.accentTenant != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accent-Tenant", r.accentTenant, "")
	}
	// body params
	localVarPostBody = r.body
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["accent_auth_token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Auth-Token"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v []string
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v []string
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

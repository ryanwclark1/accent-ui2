/*
accent-confd

Confd exposes an API for managing core resources on a Accent server such as users, extensions, devices, voicemails, queues, etc. Resources can be associated together to provide additional functionality. For example: By associating a voicemail with a user, calls will automatically fallback on to the voicemail when the user cannot answer.  Implementation notes ====================  Errors ------  Responses containing errors will have a status code in the 400 or 500 class. A list of error messages will be returned in the body of the response as a JSON-encoded array:  ~~~ [     \"Input error - User not found\",     \"Resource error - User not associated to a line\" ] ~~~   Updating resources via PUT --------------------------  When updating a resource, all fields become optional. In other words, only values that have been changed need to be sent to the server. Please note that this behavior may change in future versions of the API.

API version: 1.1
Contact: help@accentvoice.io
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package confd

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
)

type AsteriskAPI interface {

	/*
		ListAsteriskConfbridgeAccentDefaultBridge List ConfBridge accent_default_bridge options

		**Required ACL:** `confd.asterisk.confbridge.accent_default_bridge.read`

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@return ApiListAsteriskConfbridgeAccentDefaultBridgeRequest
	*/
	ListAsteriskConfbridgeAccentDefaultBridge(ctx context.Context) ApiListAsteriskConfbridgeAccentDefaultBridgeRequest

	// ListAsteriskConfbridgeAccentDefaultBridgeExecute executes the request
	//  @return ConfBridgeConfiguration
	ListAsteriskConfbridgeAccentDefaultBridgeExecute(r ApiListAsteriskConfbridgeAccentDefaultBridgeRequest) (*ConfBridgeConfiguration, *http.Response, error)

	/*
		ListAsteriskConfbridgeAccentDefaultUser List ConfBridge accent_default_user options

		**Required ACL:** `confd.asterisk.confbridge.accent_default_user.read`

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@return ApiListAsteriskConfbridgeAccentDefaultUserRequest
	*/
	ListAsteriskConfbridgeAccentDefaultUser(ctx context.Context) ApiListAsteriskConfbridgeAccentDefaultUserRequest

	// ListAsteriskConfbridgeAccentDefaultUserExecute executes the request
	//  @return ConfBridgeConfiguration
	ListAsteriskConfbridgeAccentDefaultUserExecute(r ApiListAsteriskConfbridgeAccentDefaultUserRequest) (*ConfBridgeConfiguration, *http.Response, error)

	/*
		ListAsteriskFeaturesApplicationmap List Features applicationmap options

		**Required ACL:** `confd.asterisk.features.applicationmap.read`

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@return ApiListAsteriskFeaturesApplicationmapRequest
	*/
	ListAsteriskFeaturesApplicationmap(ctx context.Context) ApiListAsteriskFeaturesApplicationmapRequest

	// ListAsteriskFeaturesApplicationmapExecute executes the request
	//  @return FeaturesConfiguration
	ListAsteriskFeaturesApplicationmapExecute(r ApiListAsteriskFeaturesApplicationmapRequest) (*FeaturesConfiguration, *http.Response, error)

	/*
		ListAsteriskFeaturesFeaturemap List Features featuremap options

		**Required ACL:** `confd.asterisk.features.featuremap.read`

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@return ApiListAsteriskFeaturesFeaturemapRequest
	*/
	ListAsteriskFeaturesFeaturemap(ctx context.Context) ApiListAsteriskFeaturesFeaturemapRequest

	// ListAsteriskFeaturesFeaturemapExecute executes the request
	//  @return FeaturesConfiguration
	ListAsteriskFeaturesFeaturemapExecute(r ApiListAsteriskFeaturesFeaturemapRequest) (*FeaturesConfiguration, *http.Response, error)

	/*
		ListAsteriskFeaturesGeneral List Features general options

		**Required ACL:** `confd.asterisk.features.general.read`

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@return ApiListAsteriskFeaturesGeneralRequest
	*/
	ListAsteriskFeaturesGeneral(ctx context.Context) ApiListAsteriskFeaturesGeneralRequest

	// ListAsteriskFeaturesGeneralExecute executes the request
	//  @return FeaturesConfiguration
	ListAsteriskFeaturesGeneralExecute(r ApiListAsteriskFeaturesGeneralRequest) (*FeaturesConfiguration, *http.Response, error)

	/*
		ListAsteriskHepGeneral List HEP general options

		**Required ACL:** `confd.asterisk.hep.general.read`

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@return ApiListAsteriskHepGeneralRequest
	*/
	ListAsteriskHepGeneral(ctx context.Context) ApiListAsteriskHepGeneralRequest

	// ListAsteriskHepGeneralExecute executes the request
	//  @return HEPConfiguration
	ListAsteriskHepGeneralExecute(r ApiListAsteriskHepGeneralRequest) (*HEPConfiguration, *http.Response, error)

	/*
		ListAsteriskIaxCallnumberlimits List IAX callnumberlimits options

		**Required ACL:** `confd.asterisk.iax.callnumberlimits.read`

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@return ApiListAsteriskIaxCallnumberlimitsRequest
	*/
	ListAsteriskIaxCallnumberlimits(ctx context.Context) ApiListAsteriskIaxCallnumberlimitsRequest

	// ListAsteriskIaxCallnumberlimitsExecute executes the request
	//  @return IAXCallNumberLimitss
	ListAsteriskIaxCallnumberlimitsExecute(r ApiListAsteriskIaxCallnumberlimitsRequest) (*IAXCallNumberLimitss, *http.Response, error)

	/*
		ListAsteriskIaxGeneral List IAX general options

		**Required ACL:** `confd.asterisk.iax.general.read`

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@return ApiListAsteriskIaxGeneralRequest
	*/
	ListAsteriskIaxGeneral(ctx context.Context) ApiListAsteriskIaxGeneralRequest

	// ListAsteriskIaxGeneralExecute executes the request
	//  @return IAXGeneral
	ListAsteriskIaxGeneralExecute(r ApiListAsteriskIaxGeneralRequest) (*IAXGeneral, *http.Response, error)

	/*
		ListAsteriskPjsipGlobal List of PJSIP options for the `global` section

		**Required ACL:** `confd.asterisk.pjsip.global.read`

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@return ApiListAsteriskPjsipGlobalRequest
	*/
	ListAsteriskPjsipGlobal(ctx context.Context) ApiListAsteriskPjsipGlobalRequest

	// ListAsteriskPjsipGlobalExecute executes the request
	//  @return PJSIPGlobal
	ListAsteriskPjsipGlobalExecute(r ApiListAsteriskPjsipGlobalRequest) (*PJSIPGlobal, *http.Response, error)

	/*
		ListAsteriskPjsipSystem List of PJSIP options for the `system` section

		**Required ACL:** `confd.asterisk.pjsip.system.read`

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@return ApiListAsteriskPjsipSystemRequest
	*/
	ListAsteriskPjsipSystem(ctx context.Context) ApiListAsteriskPjsipSystemRequest

	// ListAsteriskPjsipSystemExecute executes the request
	//  @return PJSIPSystem
	ListAsteriskPjsipSystemExecute(r ApiListAsteriskPjsipSystemRequest) (*PJSIPSystem, *http.Response, error)

	/*
		ListAsteriskQueueGeneral List Queue general options

		**Required ACL:** `confd.asterisk.queue.general.read`

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@return ApiListAsteriskQueueGeneralRequest
	*/
	ListAsteriskQueueGeneral(ctx context.Context) ApiListAsteriskQueueGeneralRequest

	// ListAsteriskQueueGeneralExecute executes the request
	//  @return QueueGeneral
	ListAsteriskQueueGeneralExecute(r ApiListAsteriskQueueGeneralRequest) (*QueueGeneral, *http.Response, error)

	/*
		ListAsteriskRtpGeneral List RTP general options

		**Required ACL:** `confd.asterisk.rtp.general.read`

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@return ApiListAsteriskRtpGeneralRequest
	*/
	ListAsteriskRtpGeneral(ctx context.Context) ApiListAsteriskRtpGeneralRequest

	// ListAsteriskRtpGeneralExecute executes the request
	//  @return RTPConfiguration
	ListAsteriskRtpGeneralExecute(r ApiListAsteriskRtpGeneralRequest) (*RTPConfiguration, *http.Response, error)

	/*
		ListAsteriskRtpIceHostCandidates List RTP ice_host_candidates options

		**Required ACL:** `confd.asterisk.rtp.ice_host_candidates.read`

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@return ApiListAsteriskRtpIceHostCandidatesRequest
	*/
	ListAsteriskRtpIceHostCandidates(ctx context.Context) ApiListAsteriskRtpIceHostCandidatesRequest

	// ListAsteriskRtpIceHostCandidatesExecute executes the request
	//  @return RTPConfiguration
	ListAsteriskRtpIceHostCandidatesExecute(r ApiListAsteriskRtpIceHostCandidatesRequest) (*RTPConfiguration, *http.Response, error)

	/*
		ListAsteriskSccpGeneral List SCCP general options

		**Required ACL:** `confd.asterisk.sccp.general.read`

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@return ApiListAsteriskSccpGeneralRequest
	*/
	ListAsteriskSccpGeneral(ctx context.Context) ApiListAsteriskSccpGeneralRequest

	// ListAsteriskSccpGeneralExecute executes the request
	//  @return SCCPGeneral
	ListAsteriskSccpGeneralExecute(r ApiListAsteriskSccpGeneralRequest) (*SCCPGeneral, *http.Response, error)

	/*
		ListAsteriskVoicemailGeneral List Voicemail general options

		**Required ACL:** `confd.asterisk.voicemail.general.read`

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@return ApiListAsteriskVoicemailGeneralRequest
	*/
	ListAsteriskVoicemailGeneral(ctx context.Context) ApiListAsteriskVoicemailGeneralRequest

	// ListAsteriskVoicemailGeneralExecute executes the request
	//  @return VoicemailGeneral
	ListAsteriskVoicemailGeneralExecute(r ApiListAsteriskVoicemailGeneralRequest) (*VoicemailGeneral, *http.Response, error)

	/*
		ListAsteriskVoicemailZonemessages List Voicemail zonemessages options

		**Required ACL:** `confd.asterisk.voicemail.zonemessages.read`

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@return ApiListAsteriskVoicemailZonemessagesRequest
	*/
	ListAsteriskVoicemailZonemessages(ctx context.Context) ApiListAsteriskVoicemailZonemessagesRequest

	// ListAsteriskVoicemailZonemessagesExecute executes the request
	//  @return VoicemailZoneMessages
	ListAsteriskVoicemailZonemessagesExecute(r ApiListAsteriskVoicemailZonemessagesRequest) (*VoicemailZoneMessages, *http.Response, error)

	/*
		ShowPjsipDoc List all PJSIP configuration options

		**Required ACL:**: `confd.asterisk.pjsip.doc.read` List all available configuration options for PJSIP, those values are used to validate to content of POST and PUT requests.

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@return ApiShowPjsipDocRequest
	*/
	ShowPjsipDoc(ctx context.Context) ApiShowPjsipDocRequest

	// ShowPjsipDocExecute executes the request
	//  @return PJSIPConfigurationOptions
	ShowPjsipDocExecute(r ApiShowPjsipDocRequest) (*PJSIPConfigurationOptions, *http.Response, error)

	/*
		UpdateAsteriskConfbridgeAccentDefaultBridge Update ConfBridge accent_default_bridge option

		**Required ACL:** `confd.asterisk.confbridge.accent_default_bridge.update` **WARNING** This endpoint restore to default value or delete all fields that are not defined. All available configuration options are listed in the [sample](https://raw.githubusercontent.com/asterisk/asterisk/master/configs/samples/confbridge.conf.sample) Asterisk configuration file.

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@return ApiUpdateAsteriskConfbridgeAccentDefaultBridgeRequest
	*/
	UpdateAsteriskConfbridgeAccentDefaultBridge(ctx context.Context) ApiUpdateAsteriskConfbridgeAccentDefaultBridgeRequest

	// UpdateAsteriskConfbridgeAccentDefaultBridgeExecute executes the request
	UpdateAsteriskConfbridgeAccentDefaultBridgeExecute(r ApiUpdateAsteriskConfbridgeAccentDefaultBridgeRequest) (*http.Response, error)

	/*
		UpdateAsteriskConfbridgeAccentDefaultUser Update ConfBridge accent_default_user option

		**Required ACL:** `confd.asterisk.confbridge.accent_default_user.update` **WARNING** This endpoint restore to default value or delete all fields that are not defined. All available configuration options are listed in the [sample](https://raw.githubusercontent.com/asterisk/asterisk/master/configs/samples/confbridge.conf.sample) Asterisk configuration file.

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@return ApiUpdateAsteriskConfbridgeAccentDefaultUserRequest
	*/
	UpdateAsteriskConfbridgeAccentDefaultUser(ctx context.Context) ApiUpdateAsteriskConfbridgeAccentDefaultUserRequest

	// UpdateAsteriskConfbridgeAccentDefaultUserExecute executes the request
	UpdateAsteriskConfbridgeAccentDefaultUserExecute(r ApiUpdateAsteriskConfbridgeAccentDefaultUserRequest) (*http.Response, error)

	/*
		UpdateAsteriskFeaturesApplicationmap Update Features applicationmap option

		**Required ACL:** `confd.asterisk.features.applicationmap.update` **WARNING** This endpoint restore to default value or delete all fields that are not defined.

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@return ApiUpdateAsteriskFeaturesApplicationmapRequest
	*/
	UpdateAsteriskFeaturesApplicationmap(ctx context.Context) ApiUpdateAsteriskFeaturesApplicationmapRequest

	// UpdateAsteriskFeaturesApplicationmapExecute executes the request
	UpdateAsteriskFeaturesApplicationmapExecute(r ApiUpdateAsteriskFeaturesApplicationmapRequest) (*http.Response, error)

	/*
		UpdateAsteriskFeaturesFeaturemap Update Features featuremap option

		**Required ACL:** `confd.asterisk.features.featuremap.update` **WARNING** This endpoint restore to default value or delete all fields that are not defined.

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@return ApiUpdateAsteriskFeaturesFeaturemapRequest
	*/
	UpdateAsteriskFeaturesFeaturemap(ctx context.Context) ApiUpdateAsteriskFeaturesFeaturemapRequest

	// UpdateAsteriskFeaturesFeaturemapExecute executes the request
	UpdateAsteriskFeaturesFeaturemapExecute(r ApiUpdateAsteriskFeaturesFeaturemapRequest) (*http.Response, error)

	/*
		UpdateAsteriskFeaturesGeneral Update Features general option

		**Required ACL:** `confd.asterisk.features.general.update` **WARNING** This endpoint restore to default value or delete all fields that are not defined.

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@return ApiUpdateAsteriskFeaturesGeneralRequest
	*/
	UpdateAsteriskFeaturesGeneral(ctx context.Context) ApiUpdateAsteriskFeaturesGeneralRequest

	// UpdateAsteriskFeaturesGeneralExecute executes the request
	UpdateAsteriskFeaturesGeneralExecute(r ApiUpdateAsteriskFeaturesGeneralRequest) (*http.Response, error)

	/*
		UpdateAsteriskHepGeneral Update HEP general option

		**Required ACL:** `confd.asterisk.hep.general.update`

	**WARNING** This endpoint restore to default value or delete all fields that are not defined.

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@return ApiUpdateAsteriskHepGeneralRequest
	*/
	UpdateAsteriskHepGeneral(ctx context.Context) ApiUpdateAsteriskHepGeneralRequest

	// UpdateAsteriskHepGeneralExecute executes the request
	UpdateAsteriskHepGeneralExecute(r ApiUpdateAsteriskHepGeneralRequest) (*http.Response, error)

	/*
		UpdateAsteriskIaxCallnumberlimits Update IAX callnumberlimits option

		**Required ACL:** `confd.asterisk.iax.callnumberlimits.update` **WARNING** This endpoint restore to default value or delete all fields that are not defined.

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@return ApiUpdateAsteriskIaxCallnumberlimitsRequest
	*/
	UpdateAsteriskIaxCallnumberlimits(ctx context.Context) ApiUpdateAsteriskIaxCallnumberlimitsRequest

	// UpdateAsteriskIaxCallnumberlimitsExecute executes the request
	UpdateAsteriskIaxCallnumberlimitsExecute(r ApiUpdateAsteriskIaxCallnumberlimitsRequest) (*http.Response, error)

	/*
		UpdateAsteriskIaxGeneral Update IAX general option

		**Required ACL:** `confd.asterisk.iax.general.update` **WARNING** This endpoint restore to default value or delete all fields that are not defined.

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@return ApiUpdateAsteriskIaxGeneralRequest
	*/
	UpdateAsteriskIaxGeneral(ctx context.Context) ApiUpdateAsteriskIaxGeneralRequest

	// UpdateAsteriskIaxGeneralExecute executes the request
	UpdateAsteriskIaxGeneralExecute(r ApiUpdateAsteriskIaxGeneralRequest) (*http.Response, error)

	/*
		UpdateAsteriskPjsipGlobal Update PJSIP section options

		**Required ACL:** `confd.asterisk.pjsip.global.update` The PJSIP global configuration is shared among all tenants of an instance. **WARNING** This endpoint restore to default value or delete all fields that are not defined.

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@return ApiUpdateAsteriskPjsipGlobalRequest
	*/
	UpdateAsteriskPjsipGlobal(ctx context.Context) ApiUpdateAsteriskPjsipGlobalRequest

	// UpdateAsteriskPjsipGlobalExecute executes the request
	UpdateAsteriskPjsipGlobalExecute(r ApiUpdateAsteriskPjsipGlobalRequest) (*http.Response, error)

	/*
		UpdateAsteriskPjsipSystem Update PJSIP section options

		**Required ACL:** `confd.asterisk.pjsip.system.update` The PJSIP system configuration is shared among all tenants of an instance. **WARNING** This endpoint restore to default value or delete all fields that are not defined.

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@return ApiUpdateAsteriskPjsipSystemRequest
	*/
	UpdateAsteriskPjsipSystem(ctx context.Context) ApiUpdateAsteriskPjsipSystemRequest

	// UpdateAsteriskPjsipSystemExecute executes the request
	UpdateAsteriskPjsipSystemExecute(r ApiUpdateAsteriskPjsipSystemRequest) (*http.Response, error)

	/*
		UpdateAsteriskQueueGeneral Update Queue general option

		**Required ACL:** `confd.asterisk.queue.general.update` **WARNING** This endpoint restore to default value or delete all fields that are not defined.

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@return ApiUpdateAsteriskQueueGeneralRequest
	*/
	UpdateAsteriskQueueGeneral(ctx context.Context) ApiUpdateAsteriskQueueGeneralRequest

	// UpdateAsteriskQueueGeneralExecute executes the request
	UpdateAsteriskQueueGeneralExecute(r ApiUpdateAsteriskQueueGeneralRequest) (*http.Response, error)

	/*
		UpdateAsteriskRtpGeneral Update RTP general option

		**Required ACL:** `confd.asterisk.rtp.general.update` **WARNING** This endpoint restore to default value or delete all fields that are not defined.

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@return ApiUpdateAsteriskRtpGeneralRequest
	*/
	UpdateAsteriskRtpGeneral(ctx context.Context) ApiUpdateAsteriskRtpGeneralRequest

	// UpdateAsteriskRtpGeneralExecute executes the request
	UpdateAsteriskRtpGeneralExecute(r ApiUpdateAsteriskRtpGeneralRequest) (*http.Response, error)

	/*
		UpdateAsteriskRtpIceHostCandidates Update RTP ice_host_candidates option

		**Required ACL:** `confd.asterisk.rtp.ice_host_candidates.update` **WARNING** This endpoint restore to default value or delete all fields that are not defined.

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@return ApiUpdateAsteriskRtpIceHostCandidatesRequest
	*/
	UpdateAsteriskRtpIceHostCandidates(ctx context.Context) ApiUpdateAsteriskRtpIceHostCandidatesRequest

	// UpdateAsteriskRtpIceHostCandidatesExecute executes the request
	UpdateAsteriskRtpIceHostCandidatesExecute(r ApiUpdateAsteriskRtpIceHostCandidatesRequest) (*http.Response, error)

	/*
		UpdateAsteriskSccpGeneral Update SCCP general option

		**Required ACL:** `confd.asterisk.sccp.general.update` **WARNING** This endpoint restore to default value or delete all fields that are not defined.

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@return ApiUpdateAsteriskSccpGeneralRequest
	*/
	UpdateAsteriskSccpGeneral(ctx context.Context) ApiUpdateAsteriskSccpGeneralRequest

	// UpdateAsteriskSccpGeneralExecute executes the request
	UpdateAsteriskSccpGeneralExecute(r ApiUpdateAsteriskSccpGeneralRequest) (*http.Response, error)

	/*
		UpdateAsteriskVoicemailGeneral Update Voicemail general option

		**Required ACL:** `confd.asterisk.voicemail.general.update` **WARNING** This endpoint restore to default value or delete all fields that are not defined.

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@return ApiUpdateAsteriskVoicemailGeneralRequest
	*/
	UpdateAsteriskVoicemailGeneral(ctx context.Context) ApiUpdateAsteriskVoicemailGeneralRequest

	// UpdateAsteriskVoicemailGeneralExecute executes the request
	UpdateAsteriskVoicemailGeneralExecute(r ApiUpdateAsteriskVoicemailGeneralRequest) (*http.Response, error)

	/*
		UpdateAsteriskVoicemailZonemessages Update Voicemail zonemessages option

		**Required ACL:** `confd.asterisk.voicemail.zonemessages.update` **WARNING** This endpoint restore to default value or delete all fields that are not defined.

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@return ApiUpdateAsteriskVoicemailZonemessagesRequest
	*/
	UpdateAsteriskVoicemailZonemessages(ctx context.Context) ApiUpdateAsteriskVoicemailZonemessagesRequest

	// UpdateAsteriskVoicemailZonemessagesExecute executes the request
	UpdateAsteriskVoicemailZonemessagesExecute(r ApiUpdateAsteriskVoicemailZonemessagesRequest) (*http.Response, error)
}

// AsteriskAPIService AsteriskAPI service
type AsteriskAPIService service

type ApiListAsteriskConfbridgeAccentDefaultBridgeRequest struct {
	ctx        context.Context
	ApiService AsteriskAPI
}

func (r ApiListAsteriskConfbridgeAccentDefaultBridgeRequest) Execute() (*ConfBridgeConfiguration, *http.Response, error) {
	return r.ApiService.ListAsteriskConfbridgeAccentDefaultBridgeExecute(r)
}

/*
ListAsteriskConfbridgeAccentDefaultBridge List ConfBridge accent_default_bridge options

**Required ACL:** `confd.asterisk.confbridge.accent_default_bridge.read`

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiListAsteriskConfbridgeAccentDefaultBridgeRequest
*/
func (a *AsteriskAPIService) ListAsteriskConfbridgeAccentDefaultBridge(ctx context.Context) ApiListAsteriskConfbridgeAccentDefaultBridgeRequest {
	return ApiListAsteriskConfbridgeAccentDefaultBridgeRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return ConfBridgeConfiguration
func (a *AsteriskAPIService) ListAsteriskConfbridgeAccentDefaultBridgeExecute(r ApiListAsteriskConfbridgeAccentDefaultBridgeRequest) (*ConfBridgeConfiguration, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *ConfBridgeConfiguration
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AsteriskAPIService.ListAsteriskConfbridgeAccentDefaultBridge")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/asterisk/confbridge/accent_default_bridge"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["accent_auth_token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Auth-Token"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiListAsteriskConfbridgeAccentDefaultUserRequest struct {
	ctx        context.Context
	ApiService AsteriskAPI
}

func (r ApiListAsteriskConfbridgeAccentDefaultUserRequest) Execute() (*ConfBridgeConfiguration, *http.Response, error) {
	return r.ApiService.ListAsteriskConfbridgeAccentDefaultUserExecute(r)
}

/*
ListAsteriskConfbridgeAccentDefaultUser List ConfBridge accent_default_user options

**Required ACL:** `confd.asterisk.confbridge.accent_default_user.read`

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiListAsteriskConfbridgeAccentDefaultUserRequest
*/
func (a *AsteriskAPIService) ListAsteriskConfbridgeAccentDefaultUser(ctx context.Context) ApiListAsteriskConfbridgeAccentDefaultUserRequest {
	return ApiListAsteriskConfbridgeAccentDefaultUserRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return ConfBridgeConfiguration
func (a *AsteriskAPIService) ListAsteriskConfbridgeAccentDefaultUserExecute(r ApiListAsteriskConfbridgeAccentDefaultUserRequest) (*ConfBridgeConfiguration, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *ConfBridgeConfiguration
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AsteriskAPIService.ListAsteriskConfbridgeAccentDefaultUser")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/asterisk/confbridge/accent_default_user"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["accent_auth_token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Auth-Token"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiListAsteriskFeaturesApplicationmapRequest struct {
	ctx        context.Context
	ApiService AsteriskAPI
}

func (r ApiListAsteriskFeaturesApplicationmapRequest) Execute() (*FeaturesConfiguration, *http.Response, error) {
	return r.ApiService.ListAsteriskFeaturesApplicationmapExecute(r)
}

/*
ListAsteriskFeaturesApplicationmap List Features applicationmap options

**Required ACL:** `confd.asterisk.features.applicationmap.read`

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiListAsteriskFeaturesApplicationmapRequest
*/
func (a *AsteriskAPIService) ListAsteriskFeaturesApplicationmap(ctx context.Context) ApiListAsteriskFeaturesApplicationmapRequest {
	return ApiListAsteriskFeaturesApplicationmapRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return FeaturesConfiguration
func (a *AsteriskAPIService) ListAsteriskFeaturesApplicationmapExecute(r ApiListAsteriskFeaturesApplicationmapRequest) (*FeaturesConfiguration, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *FeaturesConfiguration
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AsteriskAPIService.ListAsteriskFeaturesApplicationmap")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/asterisk/features/applicationmap"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["accent_auth_token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Auth-Token"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiListAsteriskFeaturesFeaturemapRequest struct {
	ctx        context.Context
	ApiService AsteriskAPI
}

func (r ApiListAsteriskFeaturesFeaturemapRequest) Execute() (*FeaturesConfiguration, *http.Response, error) {
	return r.ApiService.ListAsteriskFeaturesFeaturemapExecute(r)
}

/*
ListAsteriskFeaturesFeaturemap List Features featuremap options

**Required ACL:** `confd.asterisk.features.featuremap.read`

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiListAsteriskFeaturesFeaturemapRequest
*/
func (a *AsteriskAPIService) ListAsteriskFeaturesFeaturemap(ctx context.Context) ApiListAsteriskFeaturesFeaturemapRequest {
	return ApiListAsteriskFeaturesFeaturemapRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return FeaturesConfiguration
func (a *AsteriskAPIService) ListAsteriskFeaturesFeaturemapExecute(r ApiListAsteriskFeaturesFeaturemapRequest) (*FeaturesConfiguration, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *FeaturesConfiguration
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AsteriskAPIService.ListAsteriskFeaturesFeaturemap")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/asterisk/features/featuremap"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["accent_auth_token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Auth-Token"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiListAsteriskFeaturesGeneralRequest struct {
	ctx        context.Context
	ApiService AsteriskAPI
}

func (r ApiListAsteriskFeaturesGeneralRequest) Execute() (*FeaturesConfiguration, *http.Response, error) {
	return r.ApiService.ListAsteriskFeaturesGeneralExecute(r)
}

/*
ListAsteriskFeaturesGeneral List Features general options

**Required ACL:** `confd.asterisk.features.general.read`

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiListAsteriskFeaturesGeneralRequest
*/
func (a *AsteriskAPIService) ListAsteriskFeaturesGeneral(ctx context.Context) ApiListAsteriskFeaturesGeneralRequest {
	return ApiListAsteriskFeaturesGeneralRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return FeaturesConfiguration
func (a *AsteriskAPIService) ListAsteriskFeaturesGeneralExecute(r ApiListAsteriskFeaturesGeneralRequest) (*FeaturesConfiguration, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *FeaturesConfiguration
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AsteriskAPIService.ListAsteriskFeaturesGeneral")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/asterisk/features/general"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["accent_auth_token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Auth-Token"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiListAsteriskHepGeneralRequest struct {
	ctx        context.Context
	ApiService AsteriskAPI
}

func (r ApiListAsteriskHepGeneralRequest) Execute() (*HEPConfiguration, *http.Response, error) {
	return r.ApiService.ListAsteriskHepGeneralExecute(r)
}

/*
ListAsteriskHepGeneral List HEP general options

**Required ACL:** `confd.asterisk.hep.general.read`

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiListAsteriskHepGeneralRequest
*/
func (a *AsteriskAPIService) ListAsteriskHepGeneral(ctx context.Context) ApiListAsteriskHepGeneralRequest {
	return ApiListAsteriskHepGeneralRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return HEPConfiguration
func (a *AsteriskAPIService) ListAsteriskHepGeneralExecute(r ApiListAsteriskHepGeneralRequest) (*HEPConfiguration, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *HEPConfiguration
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AsteriskAPIService.ListAsteriskHepGeneral")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/asterisk/hep/general"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["accent_auth_token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Auth-Token"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiListAsteriskIaxCallnumberlimitsRequest struct {
	ctx        context.Context
	ApiService AsteriskAPI
}

func (r ApiListAsteriskIaxCallnumberlimitsRequest) Execute() (*IAXCallNumberLimitss, *http.Response, error) {
	return r.ApiService.ListAsteriskIaxCallnumberlimitsExecute(r)
}

/*
ListAsteriskIaxCallnumberlimits List IAX callnumberlimits options

**Required ACL:** `confd.asterisk.iax.callnumberlimits.read`

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiListAsteriskIaxCallnumberlimitsRequest
*/
func (a *AsteriskAPIService) ListAsteriskIaxCallnumberlimits(ctx context.Context) ApiListAsteriskIaxCallnumberlimitsRequest {
	return ApiListAsteriskIaxCallnumberlimitsRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return IAXCallNumberLimitss
func (a *AsteriskAPIService) ListAsteriskIaxCallnumberlimitsExecute(r ApiListAsteriskIaxCallnumberlimitsRequest) (*IAXCallNumberLimitss, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *IAXCallNumberLimitss
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AsteriskAPIService.ListAsteriskIaxCallnumberlimits")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/asterisk/iax/callnumberlimits"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["accent_auth_token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Auth-Token"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiListAsteriskIaxGeneralRequest struct {
	ctx        context.Context
	ApiService AsteriskAPI
}

func (r ApiListAsteriskIaxGeneralRequest) Execute() (*IAXGeneral, *http.Response, error) {
	return r.ApiService.ListAsteriskIaxGeneralExecute(r)
}

/*
ListAsteriskIaxGeneral List IAX general options

**Required ACL:** `confd.asterisk.iax.general.read`

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiListAsteriskIaxGeneralRequest
*/
func (a *AsteriskAPIService) ListAsteriskIaxGeneral(ctx context.Context) ApiListAsteriskIaxGeneralRequest {
	return ApiListAsteriskIaxGeneralRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return IAXGeneral
func (a *AsteriskAPIService) ListAsteriskIaxGeneralExecute(r ApiListAsteriskIaxGeneralRequest) (*IAXGeneral, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *IAXGeneral
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AsteriskAPIService.ListAsteriskIaxGeneral")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/asterisk/iax/general"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["accent_auth_token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Auth-Token"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiListAsteriskPjsipGlobalRequest struct {
	ctx        context.Context
	ApiService AsteriskAPI
}

func (r ApiListAsteriskPjsipGlobalRequest) Execute() (*PJSIPGlobal, *http.Response, error) {
	return r.ApiService.ListAsteriskPjsipGlobalExecute(r)
}

/*
ListAsteriskPjsipGlobal List of PJSIP options for the `global` section

**Required ACL:** `confd.asterisk.pjsip.global.read`

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiListAsteriskPjsipGlobalRequest
*/
func (a *AsteriskAPIService) ListAsteriskPjsipGlobal(ctx context.Context) ApiListAsteriskPjsipGlobalRequest {
	return ApiListAsteriskPjsipGlobalRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return PJSIPGlobal
func (a *AsteriskAPIService) ListAsteriskPjsipGlobalExecute(r ApiListAsteriskPjsipGlobalRequest) (*PJSIPGlobal, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *PJSIPGlobal
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AsteriskAPIService.ListAsteriskPjsipGlobal")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/asterisk/pjsip/global"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["accent_auth_token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Auth-Token"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiListAsteriskPjsipSystemRequest struct {
	ctx        context.Context
	ApiService AsteriskAPI
}

func (r ApiListAsteriskPjsipSystemRequest) Execute() (*PJSIPSystem, *http.Response, error) {
	return r.ApiService.ListAsteriskPjsipSystemExecute(r)
}

/*
ListAsteriskPjsipSystem List of PJSIP options for the `system` section

**Required ACL:** `confd.asterisk.pjsip.system.read`

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiListAsteriskPjsipSystemRequest
*/
func (a *AsteriskAPIService) ListAsteriskPjsipSystem(ctx context.Context) ApiListAsteriskPjsipSystemRequest {
	return ApiListAsteriskPjsipSystemRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return PJSIPSystem
func (a *AsteriskAPIService) ListAsteriskPjsipSystemExecute(r ApiListAsteriskPjsipSystemRequest) (*PJSIPSystem, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *PJSIPSystem
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AsteriskAPIService.ListAsteriskPjsipSystem")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/asterisk/pjsip/system"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["accent_auth_token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Auth-Token"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiListAsteriskQueueGeneralRequest struct {
	ctx        context.Context
	ApiService AsteriskAPI
}

func (r ApiListAsteriskQueueGeneralRequest) Execute() (*QueueGeneral, *http.Response, error) {
	return r.ApiService.ListAsteriskQueueGeneralExecute(r)
}

/*
ListAsteriskQueueGeneral List Queue general options

**Required ACL:** `confd.asterisk.queue.general.read`

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiListAsteriskQueueGeneralRequest
*/
func (a *AsteriskAPIService) ListAsteriskQueueGeneral(ctx context.Context) ApiListAsteriskQueueGeneralRequest {
	return ApiListAsteriskQueueGeneralRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return QueueGeneral
func (a *AsteriskAPIService) ListAsteriskQueueGeneralExecute(r ApiListAsteriskQueueGeneralRequest) (*QueueGeneral, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *QueueGeneral
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AsteriskAPIService.ListAsteriskQueueGeneral")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/asterisk/queues/general"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["accent_auth_token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Auth-Token"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiListAsteriskRtpGeneralRequest struct {
	ctx        context.Context
	ApiService AsteriskAPI
}

func (r ApiListAsteriskRtpGeneralRequest) Execute() (*RTPConfiguration, *http.Response, error) {
	return r.ApiService.ListAsteriskRtpGeneralExecute(r)
}

/*
ListAsteriskRtpGeneral List RTP general options

**Required ACL:** `confd.asterisk.rtp.general.read`

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiListAsteriskRtpGeneralRequest
*/
func (a *AsteriskAPIService) ListAsteriskRtpGeneral(ctx context.Context) ApiListAsteriskRtpGeneralRequest {
	return ApiListAsteriskRtpGeneralRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return RTPConfiguration
func (a *AsteriskAPIService) ListAsteriskRtpGeneralExecute(r ApiListAsteriskRtpGeneralRequest) (*RTPConfiguration, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *RTPConfiguration
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AsteriskAPIService.ListAsteriskRtpGeneral")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/asterisk/rtp/general"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["accent_auth_token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Auth-Token"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiListAsteriskRtpIceHostCandidatesRequest struct {
	ctx        context.Context
	ApiService AsteriskAPI
}

func (r ApiListAsteriskRtpIceHostCandidatesRequest) Execute() (*RTPConfiguration, *http.Response, error) {
	return r.ApiService.ListAsteriskRtpIceHostCandidatesExecute(r)
}

/*
ListAsteriskRtpIceHostCandidates List RTP ice_host_candidates options

**Required ACL:** `confd.asterisk.rtp.ice_host_candidates.read`

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiListAsteriskRtpIceHostCandidatesRequest
*/
func (a *AsteriskAPIService) ListAsteriskRtpIceHostCandidates(ctx context.Context) ApiListAsteriskRtpIceHostCandidatesRequest {
	return ApiListAsteriskRtpIceHostCandidatesRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return RTPConfiguration
func (a *AsteriskAPIService) ListAsteriskRtpIceHostCandidatesExecute(r ApiListAsteriskRtpIceHostCandidatesRequest) (*RTPConfiguration, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *RTPConfiguration
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AsteriskAPIService.ListAsteriskRtpIceHostCandidates")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/asterisk/rtp/ice_host_candidates"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["accent_auth_token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Auth-Token"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiListAsteriskSccpGeneralRequest struct {
	ctx        context.Context
	ApiService AsteriskAPI
}

func (r ApiListAsteriskSccpGeneralRequest) Execute() (*SCCPGeneral, *http.Response, error) {
	return r.ApiService.ListAsteriskSccpGeneralExecute(r)
}

/*
ListAsteriskSccpGeneral List SCCP general options

**Required ACL:** `confd.asterisk.sccp.general.read`

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiListAsteriskSccpGeneralRequest
*/
func (a *AsteriskAPIService) ListAsteriskSccpGeneral(ctx context.Context) ApiListAsteriskSccpGeneralRequest {
	return ApiListAsteriskSccpGeneralRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return SCCPGeneral
func (a *AsteriskAPIService) ListAsteriskSccpGeneralExecute(r ApiListAsteriskSccpGeneralRequest) (*SCCPGeneral, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *SCCPGeneral
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AsteriskAPIService.ListAsteriskSccpGeneral")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/asterisk/sccp/general"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["accent_auth_token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Auth-Token"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiListAsteriskVoicemailGeneralRequest struct {
	ctx        context.Context
	ApiService AsteriskAPI
}

func (r ApiListAsteriskVoicemailGeneralRequest) Execute() (*VoicemailGeneral, *http.Response, error) {
	return r.ApiService.ListAsteriskVoicemailGeneralExecute(r)
}

/*
ListAsteriskVoicemailGeneral List Voicemail general options

**Required ACL:** `confd.asterisk.voicemail.general.read`

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiListAsteriskVoicemailGeneralRequest
*/
func (a *AsteriskAPIService) ListAsteriskVoicemailGeneral(ctx context.Context) ApiListAsteriskVoicemailGeneralRequest {
	return ApiListAsteriskVoicemailGeneralRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return VoicemailGeneral
func (a *AsteriskAPIService) ListAsteriskVoicemailGeneralExecute(r ApiListAsteriskVoicemailGeneralRequest) (*VoicemailGeneral, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *VoicemailGeneral
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AsteriskAPIService.ListAsteriskVoicemailGeneral")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/asterisk/voicemail/general"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["accent_auth_token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Auth-Token"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiListAsteriskVoicemailZonemessagesRequest struct {
	ctx        context.Context
	ApiService AsteriskAPI
}

func (r ApiListAsteriskVoicemailZonemessagesRequest) Execute() (*VoicemailZoneMessages, *http.Response, error) {
	return r.ApiService.ListAsteriskVoicemailZonemessagesExecute(r)
}

/*
ListAsteriskVoicemailZonemessages List Voicemail zonemessages options

**Required ACL:** `confd.asterisk.voicemail.zonemessages.read`

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiListAsteriskVoicemailZonemessagesRequest
*/
func (a *AsteriskAPIService) ListAsteriskVoicemailZonemessages(ctx context.Context) ApiListAsteriskVoicemailZonemessagesRequest {
	return ApiListAsteriskVoicemailZonemessagesRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return VoicemailZoneMessages
func (a *AsteriskAPIService) ListAsteriskVoicemailZonemessagesExecute(r ApiListAsteriskVoicemailZonemessagesRequest) (*VoicemailZoneMessages, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *VoicemailZoneMessages
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AsteriskAPIService.ListAsteriskVoicemailZonemessages")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/asterisk/voicemail/zonemessages"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["accent_auth_token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Auth-Token"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiShowPjsipDocRequest struct {
	ctx        context.Context
	ApiService AsteriskAPI
}

func (r ApiShowPjsipDocRequest) Execute() (*PJSIPConfigurationOptions, *http.Response, error) {
	return r.ApiService.ShowPjsipDocExecute(r)
}

/*
ShowPjsipDoc List all PJSIP configuration options

**Required ACL:**: `confd.asterisk.pjsip.doc.read` List all available configuration options for PJSIP, those values are used to validate to content of POST and PUT requests.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiShowPjsipDocRequest
*/
func (a *AsteriskAPIService) ShowPjsipDoc(ctx context.Context) ApiShowPjsipDocRequest {
	return ApiShowPjsipDocRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return PJSIPConfigurationOptions
func (a *AsteriskAPIService) ShowPjsipDocExecute(r ApiShowPjsipDocRequest) (*PJSIPConfigurationOptions, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *PJSIPConfigurationOptions
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AsteriskAPIService.ShowPjsipDoc")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/asterisk/pjsip/doc"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["accent_auth_token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Auth-Token"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v []string
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUpdateAsteriskConfbridgeAccentDefaultBridgeRequest struct {
	ctx        context.Context
	ApiService AsteriskAPI
	body       *ConfBridgeConfiguration
}

func (r ApiUpdateAsteriskConfbridgeAccentDefaultBridgeRequest) Body(body ConfBridgeConfiguration) ApiUpdateAsteriskConfbridgeAccentDefaultBridgeRequest {
	r.body = &body
	return r
}

func (r ApiUpdateAsteriskConfbridgeAccentDefaultBridgeRequest) Execute() (*http.Response, error) {
	return r.ApiService.UpdateAsteriskConfbridgeAccentDefaultBridgeExecute(r)
}

/*
UpdateAsteriskConfbridgeAccentDefaultBridge Update ConfBridge accent_default_bridge option

**Required ACL:** `confd.asterisk.confbridge.accent_default_bridge.update` **WARNING** This endpoint restore to default value or delete all fields that are not defined. All available configuration options are listed in the [sample](https://raw.githubusercontent.com/asterisk/asterisk/master/configs/samples/confbridge.conf.sample) Asterisk configuration file.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiUpdateAsteriskConfbridgeAccentDefaultBridgeRequest
*/
func (a *AsteriskAPIService) UpdateAsteriskConfbridgeAccentDefaultBridge(ctx context.Context) ApiUpdateAsteriskConfbridgeAccentDefaultBridgeRequest {
	return ApiUpdateAsteriskConfbridgeAccentDefaultBridgeRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
func (a *AsteriskAPIService) UpdateAsteriskConfbridgeAccentDefaultBridgeExecute(r ApiUpdateAsteriskConfbridgeAccentDefaultBridgeRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodPut
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AsteriskAPIService.UpdateAsteriskConfbridgeAccentDefaultBridge")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/asterisk/confbridge/accent_default_bridge"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return nil, reportError("body is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["accent_auth_token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Auth-Token"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v []string
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v []string
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiUpdateAsteriskConfbridgeAccentDefaultUserRequest struct {
	ctx        context.Context
	ApiService AsteriskAPI
	body       *ConfBridgeConfiguration
}

func (r ApiUpdateAsteriskConfbridgeAccentDefaultUserRequest) Body(body ConfBridgeConfiguration) ApiUpdateAsteriskConfbridgeAccentDefaultUserRequest {
	r.body = &body
	return r
}

func (r ApiUpdateAsteriskConfbridgeAccentDefaultUserRequest) Execute() (*http.Response, error) {
	return r.ApiService.UpdateAsteriskConfbridgeAccentDefaultUserExecute(r)
}

/*
UpdateAsteriskConfbridgeAccentDefaultUser Update ConfBridge accent_default_user option

**Required ACL:** `confd.asterisk.confbridge.accent_default_user.update` **WARNING** This endpoint restore to default value or delete all fields that are not defined. All available configuration options are listed in the [sample](https://raw.githubusercontent.com/asterisk/asterisk/master/configs/samples/confbridge.conf.sample) Asterisk configuration file.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiUpdateAsteriskConfbridgeAccentDefaultUserRequest
*/
func (a *AsteriskAPIService) UpdateAsteriskConfbridgeAccentDefaultUser(ctx context.Context) ApiUpdateAsteriskConfbridgeAccentDefaultUserRequest {
	return ApiUpdateAsteriskConfbridgeAccentDefaultUserRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
func (a *AsteriskAPIService) UpdateAsteriskConfbridgeAccentDefaultUserExecute(r ApiUpdateAsteriskConfbridgeAccentDefaultUserRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodPut
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AsteriskAPIService.UpdateAsteriskConfbridgeAccentDefaultUser")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/asterisk/confbridge/accent_default_user"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return nil, reportError("body is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["accent_auth_token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Auth-Token"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v []string
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v []string
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiUpdateAsteriskFeaturesApplicationmapRequest struct {
	ctx        context.Context
	ApiService AsteriskAPI
	body       *FeaturesConfiguration
}

func (r ApiUpdateAsteriskFeaturesApplicationmapRequest) Body(body FeaturesConfiguration) ApiUpdateAsteriskFeaturesApplicationmapRequest {
	r.body = &body
	return r
}

func (r ApiUpdateAsteriskFeaturesApplicationmapRequest) Execute() (*http.Response, error) {
	return r.ApiService.UpdateAsteriskFeaturesApplicationmapExecute(r)
}

/*
UpdateAsteriskFeaturesApplicationmap Update Features applicationmap option

**Required ACL:** `confd.asterisk.features.applicationmap.update` **WARNING** This endpoint restore to default value or delete all fields that are not defined.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiUpdateAsteriskFeaturesApplicationmapRequest
*/
func (a *AsteriskAPIService) UpdateAsteriskFeaturesApplicationmap(ctx context.Context) ApiUpdateAsteriskFeaturesApplicationmapRequest {
	return ApiUpdateAsteriskFeaturesApplicationmapRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
func (a *AsteriskAPIService) UpdateAsteriskFeaturesApplicationmapExecute(r ApiUpdateAsteriskFeaturesApplicationmapRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodPut
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AsteriskAPIService.UpdateAsteriskFeaturesApplicationmap")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/asterisk/features/applicationmap"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return nil, reportError("body is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["accent_auth_token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Auth-Token"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v []string
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v []string
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiUpdateAsteriskFeaturesFeaturemapRequest struct {
	ctx        context.Context
	ApiService AsteriskAPI
	body       *FeaturesConfiguration
}

func (r ApiUpdateAsteriskFeaturesFeaturemapRequest) Body(body FeaturesConfiguration) ApiUpdateAsteriskFeaturesFeaturemapRequest {
	r.body = &body
	return r
}

func (r ApiUpdateAsteriskFeaturesFeaturemapRequest) Execute() (*http.Response, error) {
	return r.ApiService.UpdateAsteriskFeaturesFeaturemapExecute(r)
}

/*
UpdateAsteriskFeaturesFeaturemap Update Features featuremap option

**Required ACL:** `confd.asterisk.features.featuremap.update` **WARNING** This endpoint restore to default value or delete all fields that are not defined.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiUpdateAsteriskFeaturesFeaturemapRequest
*/
func (a *AsteriskAPIService) UpdateAsteriskFeaturesFeaturemap(ctx context.Context) ApiUpdateAsteriskFeaturesFeaturemapRequest {
	return ApiUpdateAsteriskFeaturesFeaturemapRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
func (a *AsteriskAPIService) UpdateAsteriskFeaturesFeaturemapExecute(r ApiUpdateAsteriskFeaturesFeaturemapRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodPut
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AsteriskAPIService.UpdateAsteriskFeaturesFeaturemap")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/asterisk/features/featuremap"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return nil, reportError("body is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["accent_auth_token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Auth-Token"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v []string
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v []string
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiUpdateAsteriskFeaturesGeneralRequest struct {
	ctx        context.Context
	ApiService AsteriskAPI
	body       *FeaturesConfiguration
}

func (r ApiUpdateAsteriskFeaturesGeneralRequest) Body(body FeaturesConfiguration) ApiUpdateAsteriskFeaturesGeneralRequest {
	r.body = &body
	return r
}

func (r ApiUpdateAsteriskFeaturesGeneralRequest) Execute() (*http.Response, error) {
	return r.ApiService.UpdateAsteriskFeaturesGeneralExecute(r)
}

/*
UpdateAsteriskFeaturesGeneral Update Features general option

**Required ACL:** `confd.asterisk.features.general.update` **WARNING** This endpoint restore to default value or delete all fields that are not defined.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiUpdateAsteriskFeaturesGeneralRequest
*/
func (a *AsteriskAPIService) UpdateAsteriskFeaturesGeneral(ctx context.Context) ApiUpdateAsteriskFeaturesGeneralRequest {
	return ApiUpdateAsteriskFeaturesGeneralRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
func (a *AsteriskAPIService) UpdateAsteriskFeaturesGeneralExecute(r ApiUpdateAsteriskFeaturesGeneralRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodPut
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AsteriskAPIService.UpdateAsteriskFeaturesGeneral")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/asterisk/features/general"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return nil, reportError("body is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["accent_auth_token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Auth-Token"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v []string
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v []string
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiUpdateAsteriskHepGeneralRequest struct {
	ctx        context.Context
	ApiService AsteriskAPI
	body       *HEPConfiguration
}

func (r ApiUpdateAsteriskHepGeneralRequest) Body(body HEPConfiguration) ApiUpdateAsteriskHepGeneralRequest {
	r.body = &body
	return r
}

func (r ApiUpdateAsteriskHepGeneralRequest) Execute() (*http.Response, error) {
	return r.ApiService.UpdateAsteriskHepGeneralExecute(r)
}

/*
UpdateAsteriskHepGeneral Update HEP general option

**Required ACL:** `confd.asterisk.hep.general.update`

**WARNING** This endpoint restore to default value or delete all fields that are not defined.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiUpdateAsteriskHepGeneralRequest
*/
func (a *AsteriskAPIService) UpdateAsteriskHepGeneral(ctx context.Context) ApiUpdateAsteriskHepGeneralRequest {
	return ApiUpdateAsteriskHepGeneralRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
func (a *AsteriskAPIService) UpdateAsteriskHepGeneralExecute(r ApiUpdateAsteriskHepGeneralRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodPut
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AsteriskAPIService.UpdateAsteriskHepGeneral")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/asterisk/hep/general"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return nil, reportError("body is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["accent_auth_token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Auth-Token"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v []string
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiUpdateAsteriskIaxCallnumberlimitsRequest struct {
	ctx        context.Context
	ApiService AsteriskAPI
	body       *IAXCallNumberLimitss
}

func (r ApiUpdateAsteriskIaxCallnumberlimitsRequest) Body(body IAXCallNumberLimitss) ApiUpdateAsteriskIaxCallnumberlimitsRequest {
	r.body = &body
	return r
}

func (r ApiUpdateAsteriskIaxCallnumberlimitsRequest) Execute() (*http.Response, error) {
	return r.ApiService.UpdateAsteriskIaxCallnumberlimitsExecute(r)
}

/*
UpdateAsteriskIaxCallnumberlimits Update IAX callnumberlimits option

**Required ACL:** `confd.asterisk.iax.callnumberlimits.update` **WARNING** This endpoint restore to default value or delete all fields that are not defined.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiUpdateAsteriskIaxCallnumberlimitsRequest
*/
func (a *AsteriskAPIService) UpdateAsteriskIaxCallnumberlimits(ctx context.Context) ApiUpdateAsteriskIaxCallnumberlimitsRequest {
	return ApiUpdateAsteriskIaxCallnumberlimitsRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
func (a *AsteriskAPIService) UpdateAsteriskIaxCallnumberlimitsExecute(r ApiUpdateAsteriskIaxCallnumberlimitsRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodPut
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AsteriskAPIService.UpdateAsteriskIaxCallnumberlimits")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/asterisk/iax/callnumberlimits"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return nil, reportError("body is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["accent_auth_token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Auth-Token"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v []string
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v []string
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiUpdateAsteriskIaxGeneralRequest struct {
	ctx        context.Context
	ApiService AsteriskAPI
	body       *IAXGeneral
}

func (r ApiUpdateAsteriskIaxGeneralRequest) Body(body IAXGeneral) ApiUpdateAsteriskIaxGeneralRequest {
	r.body = &body
	return r
}

func (r ApiUpdateAsteriskIaxGeneralRequest) Execute() (*http.Response, error) {
	return r.ApiService.UpdateAsteriskIaxGeneralExecute(r)
}

/*
UpdateAsteriskIaxGeneral Update IAX general option

**Required ACL:** `confd.asterisk.iax.general.update` **WARNING** This endpoint restore to default value or delete all fields that are not defined.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiUpdateAsteriskIaxGeneralRequest
*/
func (a *AsteriskAPIService) UpdateAsteriskIaxGeneral(ctx context.Context) ApiUpdateAsteriskIaxGeneralRequest {
	return ApiUpdateAsteriskIaxGeneralRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
func (a *AsteriskAPIService) UpdateAsteriskIaxGeneralExecute(r ApiUpdateAsteriskIaxGeneralRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodPut
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AsteriskAPIService.UpdateAsteriskIaxGeneral")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/asterisk/iax/general"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return nil, reportError("body is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["accent_auth_token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Auth-Token"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v []string
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v []string
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiUpdateAsteriskPjsipGlobalRequest struct {
	ctx        context.Context
	ApiService AsteriskAPI
	body       *PJSIPGlobal
}

func (r ApiUpdateAsteriskPjsipGlobalRequest) Body(body PJSIPGlobal) ApiUpdateAsteriskPjsipGlobalRequest {
	r.body = &body
	return r
}

func (r ApiUpdateAsteriskPjsipGlobalRequest) Execute() (*http.Response, error) {
	return r.ApiService.UpdateAsteriskPjsipGlobalExecute(r)
}

/*
UpdateAsteriskPjsipGlobal Update PJSIP section options

**Required ACL:** `confd.asterisk.pjsip.global.update` The PJSIP global configuration is shared among all tenants of an instance. **WARNING** This endpoint restore to default value or delete all fields that are not defined.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiUpdateAsteriskPjsipGlobalRequest
*/
func (a *AsteriskAPIService) UpdateAsteriskPjsipGlobal(ctx context.Context) ApiUpdateAsteriskPjsipGlobalRequest {
	return ApiUpdateAsteriskPjsipGlobalRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
func (a *AsteriskAPIService) UpdateAsteriskPjsipGlobalExecute(r ApiUpdateAsteriskPjsipGlobalRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodPut
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AsteriskAPIService.UpdateAsteriskPjsipGlobal")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/asterisk/pjsip/global"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return nil, reportError("body is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["accent_auth_token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Auth-Token"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v []string
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v []string
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiUpdateAsteriskPjsipSystemRequest struct {
	ctx        context.Context
	ApiService AsteriskAPI
	body       *PJSIPSystem
}

func (r ApiUpdateAsteriskPjsipSystemRequest) Body(body PJSIPSystem) ApiUpdateAsteriskPjsipSystemRequest {
	r.body = &body
	return r
}

func (r ApiUpdateAsteriskPjsipSystemRequest) Execute() (*http.Response, error) {
	return r.ApiService.UpdateAsteriskPjsipSystemExecute(r)
}

/*
UpdateAsteriskPjsipSystem Update PJSIP section options

**Required ACL:** `confd.asterisk.pjsip.system.update` The PJSIP system configuration is shared among all tenants of an instance. **WARNING** This endpoint restore to default value or delete all fields that are not defined.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiUpdateAsteriskPjsipSystemRequest
*/
func (a *AsteriskAPIService) UpdateAsteriskPjsipSystem(ctx context.Context) ApiUpdateAsteriskPjsipSystemRequest {
	return ApiUpdateAsteriskPjsipSystemRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
func (a *AsteriskAPIService) UpdateAsteriskPjsipSystemExecute(r ApiUpdateAsteriskPjsipSystemRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodPut
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AsteriskAPIService.UpdateAsteriskPjsipSystem")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/asterisk/pjsip/system"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return nil, reportError("body is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["accent_auth_token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Auth-Token"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v []string
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v []string
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiUpdateAsteriskQueueGeneralRequest struct {
	ctx        context.Context
	ApiService AsteriskAPI
	body       *QueueGeneral
}

func (r ApiUpdateAsteriskQueueGeneralRequest) Body(body QueueGeneral) ApiUpdateAsteriskQueueGeneralRequest {
	r.body = &body
	return r
}

func (r ApiUpdateAsteriskQueueGeneralRequest) Execute() (*http.Response, error) {
	return r.ApiService.UpdateAsteriskQueueGeneralExecute(r)
}

/*
UpdateAsteriskQueueGeneral Update Queue general option

**Required ACL:** `confd.asterisk.queue.general.update` **WARNING** This endpoint restore to default value or delete all fields that are not defined.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiUpdateAsteriskQueueGeneralRequest
*/
func (a *AsteriskAPIService) UpdateAsteriskQueueGeneral(ctx context.Context) ApiUpdateAsteriskQueueGeneralRequest {
	return ApiUpdateAsteriskQueueGeneralRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
func (a *AsteriskAPIService) UpdateAsteriskQueueGeneralExecute(r ApiUpdateAsteriskQueueGeneralRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodPut
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AsteriskAPIService.UpdateAsteriskQueueGeneral")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/asterisk/queues/general"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return nil, reportError("body is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["accent_auth_token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Auth-Token"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v []string
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v []string
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiUpdateAsteriskRtpGeneralRequest struct {
	ctx        context.Context
	ApiService AsteriskAPI
	body       *RTPConfiguration
}

func (r ApiUpdateAsteriskRtpGeneralRequest) Body(body RTPConfiguration) ApiUpdateAsteriskRtpGeneralRequest {
	r.body = &body
	return r
}

func (r ApiUpdateAsteriskRtpGeneralRequest) Execute() (*http.Response, error) {
	return r.ApiService.UpdateAsteriskRtpGeneralExecute(r)
}

/*
UpdateAsteriskRtpGeneral Update RTP general option

**Required ACL:** `confd.asterisk.rtp.general.update` **WARNING** This endpoint restore to default value or delete all fields that are not defined.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiUpdateAsteriskRtpGeneralRequest
*/
func (a *AsteriskAPIService) UpdateAsteriskRtpGeneral(ctx context.Context) ApiUpdateAsteriskRtpGeneralRequest {
	return ApiUpdateAsteriskRtpGeneralRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
func (a *AsteriskAPIService) UpdateAsteriskRtpGeneralExecute(r ApiUpdateAsteriskRtpGeneralRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodPut
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AsteriskAPIService.UpdateAsteriskRtpGeneral")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/asterisk/rtp/general"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return nil, reportError("body is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["accent_auth_token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Auth-Token"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v []string
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v []string
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiUpdateAsteriskRtpIceHostCandidatesRequest struct {
	ctx        context.Context
	ApiService AsteriskAPI
	body       *RTPConfiguration
}

func (r ApiUpdateAsteriskRtpIceHostCandidatesRequest) Body(body RTPConfiguration) ApiUpdateAsteriskRtpIceHostCandidatesRequest {
	r.body = &body
	return r
}

func (r ApiUpdateAsteriskRtpIceHostCandidatesRequest) Execute() (*http.Response, error) {
	return r.ApiService.UpdateAsteriskRtpIceHostCandidatesExecute(r)
}

/*
UpdateAsteriskRtpIceHostCandidates Update RTP ice_host_candidates option

**Required ACL:** `confd.asterisk.rtp.ice_host_candidates.update` **WARNING** This endpoint restore to default value or delete all fields that are not defined.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiUpdateAsteriskRtpIceHostCandidatesRequest
*/
func (a *AsteriskAPIService) UpdateAsteriskRtpIceHostCandidates(ctx context.Context) ApiUpdateAsteriskRtpIceHostCandidatesRequest {
	return ApiUpdateAsteriskRtpIceHostCandidatesRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
func (a *AsteriskAPIService) UpdateAsteriskRtpIceHostCandidatesExecute(r ApiUpdateAsteriskRtpIceHostCandidatesRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodPut
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AsteriskAPIService.UpdateAsteriskRtpIceHostCandidates")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/asterisk/rtp/ice_host_candidates"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return nil, reportError("body is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["accent_auth_token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Auth-Token"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v []string
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v []string
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiUpdateAsteriskSccpGeneralRequest struct {
	ctx        context.Context
	ApiService AsteriskAPI
	body       *SCCPGeneral
}

func (r ApiUpdateAsteriskSccpGeneralRequest) Body(body SCCPGeneral) ApiUpdateAsteriskSccpGeneralRequest {
	r.body = &body
	return r
}

func (r ApiUpdateAsteriskSccpGeneralRequest) Execute() (*http.Response, error) {
	return r.ApiService.UpdateAsteriskSccpGeneralExecute(r)
}

/*
UpdateAsteriskSccpGeneral Update SCCP general option

**Required ACL:** `confd.asterisk.sccp.general.update` **WARNING** This endpoint restore to default value or delete all fields that are not defined.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiUpdateAsteriskSccpGeneralRequest
*/
func (a *AsteriskAPIService) UpdateAsteriskSccpGeneral(ctx context.Context) ApiUpdateAsteriskSccpGeneralRequest {
	return ApiUpdateAsteriskSccpGeneralRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
func (a *AsteriskAPIService) UpdateAsteriskSccpGeneralExecute(r ApiUpdateAsteriskSccpGeneralRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodPut
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AsteriskAPIService.UpdateAsteriskSccpGeneral")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/asterisk/sccp/general"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return nil, reportError("body is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["accent_auth_token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Auth-Token"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v []string
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v []string
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiUpdateAsteriskVoicemailGeneralRequest struct {
	ctx        context.Context
	ApiService AsteriskAPI
	body       *VoicemailGeneral
}

func (r ApiUpdateAsteriskVoicemailGeneralRequest) Body(body VoicemailGeneral) ApiUpdateAsteriskVoicemailGeneralRequest {
	r.body = &body
	return r
}

func (r ApiUpdateAsteriskVoicemailGeneralRequest) Execute() (*http.Response, error) {
	return r.ApiService.UpdateAsteriskVoicemailGeneralExecute(r)
}

/*
UpdateAsteriskVoicemailGeneral Update Voicemail general option

**Required ACL:** `confd.asterisk.voicemail.general.update` **WARNING** This endpoint restore to default value or delete all fields that are not defined.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiUpdateAsteriskVoicemailGeneralRequest
*/
func (a *AsteriskAPIService) UpdateAsteriskVoicemailGeneral(ctx context.Context) ApiUpdateAsteriskVoicemailGeneralRequest {
	return ApiUpdateAsteriskVoicemailGeneralRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
func (a *AsteriskAPIService) UpdateAsteriskVoicemailGeneralExecute(r ApiUpdateAsteriskVoicemailGeneralRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodPut
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AsteriskAPIService.UpdateAsteriskVoicemailGeneral")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/asterisk/voicemail/general"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return nil, reportError("body is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["accent_auth_token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Auth-Token"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v []string
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v []string
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiUpdateAsteriskVoicemailZonemessagesRequest struct {
	ctx        context.Context
	ApiService AsteriskAPI
	body       *VoicemailZoneMessages
}

func (r ApiUpdateAsteriskVoicemailZonemessagesRequest) Body(body VoicemailZoneMessages) ApiUpdateAsteriskVoicemailZonemessagesRequest {
	r.body = &body
	return r
}

func (r ApiUpdateAsteriskVoicemailZonemessagesRequest) Execute() (*http.Response, error) {
	return r.ApiService.UpdateAsteriskVoicemailZonemessagesExecute(r)
}

/*
UpdateAsteriskVoicemailZonemessages Update Voicemail zonemessages option

**Required ACL:** `confd.asterisk.voicemail.zonemessages.update` **WARNING** This endpoint restore to default value or delete all fields that are not defined.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiUpdateAsteriskVoicemailZonemessagesRequest
*/
func (a *AsteriskAPIService) UpdateAsteriskVoicemailZonemessages(ctx context.Context) ApiUpdateAsteriskVoicemailZonemessagesRequest {
	return ApiUpdateAsteriskVoicemailZonemessagesRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
func (a *AsteriskAPIService) UpdateAsteriskVoicemailZonemessagesExecute(r ApiUpdateAsteriskVoicemailZonemessagesRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodPut
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AsteriskAPIService.UpdateAsteriskVoicemailZonemessages")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/asterisk/voicemail/zonemessages"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return nil, reportError("body is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["accent_auth_token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Auth-Token"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v []string
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v []string
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

/*
accent-confd

Confd exposes an API for managing core resources on a Accent server such as users, extensions, devices, voicemails, queues, etc. Resources can be associated together to provide additional functionality. For example: By associating a voicemail with a user, calls will automatically fallback on to the voicemail when the user cannot answer.  Implementation notes ====================  Errors ------  Responses containing errors will have a status code in the 400 or 500 class. A list of error messages will be returned in the body of the response as a JSON-encoded array:  ~~~ [     \"Input error - User not found\",     \"Resource error - User not associated to a line\" ] ~~~   Updating resources via PUT --------------------------  When updating a resource, all fields become optional. In other words, only values that have been changed need to be sent to the server. Please note that this behavior may change in future versions of the API.

API version: 1.1
Contact: help@accentvoice.io
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package confd

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"strings"
)

type ExtensionsAPI interface {

	/*
		AssociateConferenceExtension Associate conference and extension

		**Required ACL:** `confd.conferences.{conference_id}.extensions.{extension_id}.update`

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param conferenceId Conference's ID
		@param extensionId
		@return ExtensionsAPIAssociateConferenceExtensionRequest
	*/
	AssociateConferenceExtension(ctx context.Context, conferenceId int32, extensionId int32) ExtensionsAPIAssociateConferenceExtensionRequest

	// AssociateConferenceExtensionExecute executes the request
	AssociateConferenceExtensionExecute(r ExtensionsAPIAssociateConferenceExtensionRequest) (*http.Response, error)

	/*
		AssociateGroupExtension Associate group and extension

		**Required ACL:** `confd.groups.{group_uuid}.extensions.{extension_id}.update`

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param groupUuid the group's UUID
		@param extensionId
		@return ExtensionsAPIAssociateGroupExtensionRequest
	*/
	AssociateGroupExtension(ctx context.Context, groupUuid string, extensionId int32) ExtensionsAPIAssociateGroupExtensionRequest

	// AssociateGroupExtensionExecute executes the request
	AssociateGroupExtensionExecute(r ExtensionsAPIAssociateGroupExtensionRequest) (*http.Response, error)

	/*
		AssociateIncallExtension Associate incall and extension

		**Required ACL:** `confd.incalls.{incall_id}.extensions.{extension_id}.update`

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param incallId Incoming call's ID
		@param extensionId
		@return ExtensionsAPIAssociateIncallExtensionRequest
	*/
	AssociateIncallExtension(ctx context.Context, incallId int32, extensionId int32) ExtensionsAPIAssociateIncallExtensionRequest

	// AssociateIncallExtensionExecute executes the request
	AssociateIncallExtensionExecute(r ExtensionsAPIAssociateIncallExtensionRequest) (*http.Response, error)

	/*
		AssociateLineExtension Associate line and extension

		**Required ACL:** `confd.lines.{line_id}.extensions.{extension_id}.update`

	Because of technical limitations, a line can only have a single ‘internal’ extension associated (i.e. an extension with a context of type ‘internal’)

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param lineId
		@param extensionId
		@return ExtensionsAPIAssociateLineExtensionRequest
	*/
	AssociateLineExtension(ctx context.Context, lineId int32, extensionId int32) ExtensionsAPIAssociateLineExtensionRequest

	// AssociateLineExtensionExecute executes the request
	AssociateLineExtensionExecute(r ExtensionsAPIAssociateLineExtensionRequest) (*http.Response, error)

	/*
		AssociateOutcallExtension Associate outcall and extension

		**Required ACL:** `confd.outcalls.{outcall_id}.extensions.{extension_id}.update`

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param outcallId Outgoing call's ID
		@param extensionId
		@return ExtensionsAPIAssociateOutcallExtensionRequest
	*/
	AssociateOutcallExtension(ctx context.Context, outcallId int32, extensionId int32) ExtensionsAPIAssociateOutcallExtensionRequest

	// AssociateOutcallExtensionExecute executes the request
	AssociateOutcallExtensionExecute(r ExtensionsAPIAssociateOutcallExtensionRequest) (*http.Response, error)

	/*
		AssociateParkingLotExtension Associate parking_lot and extension

		**Required ACL:** `confd.parkinglots.{parking_lot_id}.extensions.{extension_id}.update`

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param parkingLotId Parking Lot's ID
		@param extensionId
		@return ExtensionsAPIAssociateParkingLotExtensionRequest
	*/
	AssociateParkingLotExtension(ctx context.Context, parkingLotId int32, extensionId int32) ExtensionsAPIAssociateParkingLotExtensionRequest

	// AssociateParkingLotExtensionExecute executes the request
	AssociateParkingLotExtensionExecute(r ExtensionsAPIAssociateParkingLotExtensionRequest) (*http.Response, error)

	/*
		AssociateQueueExtension Associate queue and extension

		**Required ACL:** `confd.queues.{queue_id}.extensions.{extension_id}.update`

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param queueId queue's ID
		@param extensionId
		@return ExtensionsAPIAssociateQueueExtensionRequest
	*/
	AssociateQueueExtension(ctx context.Context, queueId int32, extensionId int32) ExtensionsAPIAssociateQueueExtensionRequest

	// AssociateQueueExtensionExecute executes the request
	AssociateQueueExtensionExecute(r ExtensionsAPIAssociateQueueExtensionRequest) (*http.Response, error)

	/*
		CreateExtension Create extension

		**Required ACL:** `confd.extensions.create`

	The extension number must be included in one of the extension ranges for the given context.

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@return ExtensionsAPICreateExtensionRequest
	*/
	CreateExtension(ctx context.Context) ExtensionsAPICreateExtensionRequest

	// CreateExtensionExecute executes the request
	//  @return Extension
	CreateExtensionExecute(r ExtensionsAPICreateExtensionRequest) (*Extension, *http.Response, error)

	/*
		CreateLineExtension Create extension

		**Required ACL:** `confd.lines.{line_id}.extensions.create`
	The extension number must be included in one of the extension ranges for the given context.

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param lineId
		@return ExtensionsAPICreateLineExtensionRequest
	*/
	CreateLineExtension(ctx context.Context, lineId int32) ExtensionsAPICreateLineExtensionRequest

	// CreateLineExtensionExecute executes the request
	//  @return Extension
	CreateLineExtensionExecute(r ExtensionsAPICreateLineExtensionRequest) (*Extension, *http.Response, error)

	/*
		DeleteExtension Delete extension

		**Required ACL:** `confd.extensions.{extension_id}.delete`

	An extension can not be deleted if it is associated to a line. You must delete the association first.

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param extensionId
		@return ExtensionsAPIDeleteExtensionRequest
	*/
	DeleteExtension(ctx context.Context, extensionId int32) ExtensionsAPIDeleteExtensionRequest

	// DeleteExtensionExecute executes the request
	DeleteExtensionExecute(r ExtensionsAPIDeleteExtensionRequest) (*http.Response, error)

	/*
		DissociateConferenceExtension Dissociate conference and extension

		**Required ACL:** `confd.conferences.{conference_id}.extensions.{extension_id}.delete`

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param conferenceId Conference's ID
		@param extensionId
		@return ExtensionsAPIDissociateConferenceExtensionRequest
	*/
	DissociateConferenceExtension(ctx context.Context, conferenceId int32, extensionId int32) ExtensionsAPIDissociateConferenceExtensionRequest

	// DissociateConferenceExtensionExecute executes the request
	DissociateConferenceExtensionExecute(r ExtensionsAPIDissociateConferenceExtensionRequest) (*http.Response, error)

	/*
		DissociateGroupExtension Dissociate group and extension

		**Required ACL:** `confd.groups.{group_uuid}.extensions.{extension_id}.delete`

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param groupUuid the group's UUID
		@param extensionId
		@return ExtensionsAPIDissociateGroupExtensionRequest
	*/
	DissociateGroupExtension(ctx context.Context, groupUuid string, extensionId int32) ExtensionsAPIDissociateGroupExtensionRequest

	// DissociateGroupExtensionExecute executes the request
	DissociateGroupExtensionExecute(r ExtensionsAPIDissociateGroupExtensionRequest) (*http.Response, error)

	/*
		DissociateIncallExtension Dissociate incall and extension

		**Required ACL:** `confd.incalls.{incall_id}.extensions.{extension_id}.delete`

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param incallId Incoming call's ID
		@param extensionId
		@return ExtensionsAPIDissociateIncallExtensionRequest
	*/
	DissociateIncallExtension(ctx context.Context, incallId int32, extensionId int32) ExtensionsAPIDissociateIncallExtensionRequest

	// DissociateIncallExtensionExecute executes the request
	DissociateIncallExtensionExecute(r ExtensionsAPIDissociateIncallExtensionRequest) (*http.Response, error)

	/*
		DissociateLineExtension Dissociate line and extension

		**Required ACL:** `confd.lines.{line_id}.extensions.{extension_id}.delete`

	Any devices that are attached to a line must be removed before dissociating an extension from its line. A device can be dissociated by resetting it to autoprov mode.

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param lineId
		@param extensionId
		@return ExtensionsAPIDissociateLineExtensionRequest
	*/
	DissociateLineExtension(ctx context.Context, lineId int32, extensionId int32) ExtensionsAPIDissociateLineExtensionRequest

	// DissociateLineExtensionExecute executes the request
	DissociateLineExtensionExecute(r ExtensionsAPIDissociateLineExtensionRequest) (*http.Response, error)

	/*
		DissociateOutcallExtension Dissociate outcall and extension

		**Required ACL:** `confd.outcalls.{outcall_id}.extensions.{extension_id}.delete`

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param outcallId Outgoing call's ID
		@param extensionId
		@return ExtensionsAPIDissociateOutcallExtensionRequest
	*/
	DissociateOutcallExtension(ctx context.Context, outcallId int32, extensionId int32) ExtensionsAPIDissociateOutcallExtensionRequest

	// DissociateOutcallExtensionExecute executes the request
	DissociateOutcallExtensionExecute(r ExtensionsAPIDissociateOutcallExtensionRequest) (*http.Response, error)

	/*
		DissociateParkingLotExtension Dissociate parking lot and extension

		**Required ACL:** `confd.parkinglots.{parking_lot_id}.extensions.{extension_id}.delete`

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param parkingLotId Parking Lot's ID
		@param extensionId
		@return ExtensionsAPIDissociateParkingLotExtensionRequest
	*/
	DissociateParkingLotExtension(ctx context.Context, parkingLotId int32, extensionId int32) ExtensionsAPIDissociateParkingLotExtensionRequest

	// DissociateParkingLotExtensionExecute executes the request
	DissociateParkingLotExtensionExecute(r ExtensionsAPIDissociateParkingLotExtensionRequest) (*http.Response, error)

	/*
		DissociateQueueExtension Dissociate queue and extension

		**Required ACL:** `confd.queues.{queue_id}.extensions.{extension_id}.delete`

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param queueId queue's ID
		@param extensionId
		@return ExtensionsAPIDissociateQueueExtensionRequest
	*/
	DissociateQueueExtension(ctx context.Context, queueId int32, extensionId int32) ExtensionsAPIDissociateQueueExtensionRequest

	// DissociateQueueExtensionExecute executes the request
	DissociateQueueExtensionExecute(r ExtensionsAPIDissociateQueueExtensionRequest) (*http.Response, error)

	/*
		GetExtension Get extension

		**Required ACL:** `confd.extensions.{extension_id}.read`

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param extensionId
		@return ExtensionsAPIGetExtensionRequest
	*/
	GetExtension(ctx context.Context, extensionId int32) ExtensionsAPIGetExtensionRequest

	// GetExtensionExecute executes the request
	//  @return Extension
	GetExtensionExecute(r ExtensionsAPIGetExtensionRequest) (*Extension, *http.Response, error)

	/*
		GetExtensionFeature Get extension feature

		**Required ACL:** `confd.extensions.features.{extension_uuid}.read`

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param extensionUuid
		@return ExtensionsAPIGetExtensionFeatureRequest
	*/
	GetExtensionFeature(ctx context.Context, extensionUuid string) ExtensionsAPIGetExtensionFeatureRequest

	// GetExtensionFeatureExecute executes the request
	//  @return ExtensionFeature
	GetExtensionFeatureExecute(r ExtensionsAPIGetExtensionFeatureRequest) (*ExtensionFeature, *http.Response, error)

	/*
		ListExtensions List extensions

		**Required ACL:** `confd.extensions.read`

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@return ExtensionsAPIListExtensionsRequest
	*/
	ListExtensions(ctx context.Context) ExtensionsAPIListExtensionsRequest

	// ListExtensionsExecute executes the request
	//  @return ExtensionItems
	ListExtensionsExecute(r ExtensionsAPIListExtensionsRequest) (*ExtensionItems, *http.Response, error)

	/*
		ListExtensionsFeatures List extensions features

		**Required ACL:** `confd.extensions.features.read`

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@return ExtensionsAPIListExtensionsFeaturesRequest
	*/
	ListExtensionsFeatures(ctx context.Context) ExtensionsAPIListExtensionsFeaturesRequest

	// ListExtensionsFeaturesExecute executes the request
	//  @return ExtensionFeatureItems
	ListExtensionsFeaturesExecute(r ExtensionsAPIListExtensionsFeaturesRequest) (*ExtensionFeatureItems, *http.Response, error)

	/*
		UpdateExtension Update extension

		**Required ACL:** `confd.extensions.{extension_id}.update`

	The new extension number must be included in one of the extension ranges for the new context.

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param extensionId
		@return ExtensionsAPIUpdateExtensionRequest
	*/
	UpdateExtension(ctx context.Context, extensionId int32) ExtensionsAPIUpdateExtensionRequest

	// UpdateExtensionExecute executes the request
	UpdateExtensionExecute(r ExtensionsAPIUpdateExtensionRequest) (*http.Response, error)

	/*
		UpdateExtensionFeature Update extension

		**Required ACL:** `confd.extensions.features.{extension_uuid}.update`

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param extensionUuid
		@return ExtensionsAPIUpdateExtensionFeatureRequest
	*/
	UpdateExtensionFeature(ctx context.Context, extensionUuid string) ExtensionsAPIUpdateExtensionFeatureRequest

	// UpdateExtensionFeatureExecute executes the request
	UpdateExtensionFeatureExecute(r ExtensionsAPIUpdateExtensionFeatureRequest) (*http.Response, error)
}

// ExtensionsAPIService ExtensionsAPI service
type ExtensionsAPIService service

type ExtensionsAPIAssociateConferenceExtensionRequest struct {
	ctx          context.Context
	ApiService   ExtensionsAPI
	conferenceId int32
	extensionId  int32
}

func (r ExtensionsAPIAssociateConferenceExtensionRequest) Execute() (*http.Response, error) {
	return r.ApiService.AssociateConferenceExtensionExecute(r)
}

/*
AssociateConferenceExtension Associate conference and extension

**Required ACL:** `confd.conferences.{conference_id}.extensions.{extension_id}.update`

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param conferenceId Conference's ID
	@param extensionId
	@return ExtensionsAPIAssociateConferenceExtensionRequest
*/
func (a *ExtensionsAPIService) AssociateConferenceExtension(ctx context.Context, conferenceId int32, extensionId int32) ExtensionsAPIAssociateConferenceExtensionRequest {
	return ExtensionsAPIAssociateConferenceExtensionRequest{
		ApiService:   a,
		ctx:          ctx,
		conferenceId: conferenceId,
		extensionId:  extensionId,
	}
}

// Execute executes the request
func (a *ExtensionsAPIService) AssociateConferenceExtensionExecute(r ExtensionsAPIAssociateConferenceExtensionRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodPut
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ExtensionsAPIService.AssociateConferenceExtension")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/conferences/{conference_id}/extensions/{extension_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"conference_id"+"}", url.PathEscape(parameterValueToString(r.conferenceId, "conferenceId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"extension_id"+"}", url.PathEscape(parameterValueToString(r.extensionId, "extensionId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["accent_auth_token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Auth-Token"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v []string
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v []string
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ExtensionsAPIAssociateGroupExtensionRequest struct {
	ctx         context.Context
	ApiService  ExtensionsAPI
	groupUuid   string
	extensionId int32
}

func (r ExtensionsAPIAssociateGroupExtensionRequest) Execute() (*http.Response, error) {
	return r.ApiService.AssociateGroupExtensionExecute(r)
}

/*
AssociateGroupExtension Associate group and extension

**Required ACL:** `confd.groups.{group_uuid}.extensions.{extension_id}.update`

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param groupUuid the group's UUID
	@param extensionId
	@return ExtensionsAPIAssociateGroupExtensionRequest
*/
func (a *ExtensionsAPIService) AssociateGroupExtension(ctx context.Context, groupUuid string, extensionId int32) ExtensionsAPIAssociateGroupExtensionRequest {
	return ExtensionsAPIAssociateGroupExtensionRequest{
		ApiService:  a,
		ctx:         ctx,
		groupUuid:   groupUuid,
		extensionId: extensionId,
	}
}

// Execute executes the request
func (a *ExtensionsAPIService) AssociateGroupExtensionExecute(r ExtensionsAPIAssociateGroupExtensionRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodPut
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ExtensionsAPIService.AssociateGroupExtension")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/groups/{group_uuid}/extensions/{extension_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"group_uuid"+"}", url.PathEscape(parameterValueToString(r.groupUuid, "groupUuid")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"extension_id"+"}", url.PathEscape(parameterValueToString(r.extensionId, "extensionId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["accent_auth_token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Auth-Token"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v []string
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v []string
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ExtensionsAPIAssociateIncallExtensionRequest struct {
	ctx         context.Context
	ApiService  ExtensionsAPI
	incallId    int32
	extensionId int32
}

func (r ExtensionsAPIAssociateIncallExtensionRequest) Execute() (*http.Response, error) {
	return r.ApiService.AssociateIncallExtensionExecute(r)
}

/*
AssociateIncallExtension Associate incall and extension

**Required ACL:** `confd.incalls.{incall_id}.extensions.{extension_id}.update`

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param incallId Incoming call's ID
	@param extensionId
	@return ExtensionsAPIAssociateIncallExtensionRequest
*/
func (a *ExtensionsAPIService) AssociateIncallExtension(ctx context.Context, incallId int32, extensionId int32) ExtensionsAPIAssociateIncallExtensionRequest {
	return ExtensionsAPIAssociateIncallExtensionRequest{
		ApiService:  a,
		ctx:         ctx,
		incallId:    incallId,
		extensionId: extensionId,
	}
}

// Execute executes the request
func (a *ExtensionsAPIService) AssociateIncallExtensionExecute(r ExtensionsAPIAssociateIncallExtensionRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodPut
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ExtensionsAPIService.AssociateIncallExtension")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/incalls/{incall_id}/extensions/{extension_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"incall_id"+"}", url.PathEscape(parameterValueToString(r.incallId, "incallId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"extension_id"+"}", url.PathEscape(parameterValueToString(r.extensionId, "extensionId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["accent_auth_token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Auth-Token"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v []string
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v []string
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ExtensionsAPIAssociateLineExtensionRequest struct {
	ctx         context.Context
	ApiService  ExtensionsAPI
	lineId      int32
	extensionId int32
}

func (r ExtensionsAPIAssociateLineExtensionRequest) Execute() (*http.Response, error) {
	return r.ApiService.AssociateLineExtensionExecute(r)
}

/*
AssociateLineExtension Associate line and extension

**Required ACL:** `confd.lines.{line_id}.extensions.{extension_id}.update`

Because of technical limitations, a line can only have a single ‘internal’ extension associated (i.e. an extension with a context of type ‘internal’)

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param lineId
	@param extensionId
	@return ExtensionsAPIAssociateLineExtensionRequest
*/
func (a *ExtensionsAPIService) AssociateLineExtension(ctx context.Context, lineId int32, extensionId int32) ExtensionsAPIAssociateLineExtensionRequest {
	return ExtensionsAPIAssociateLineExtensionRequest{
		ApiService:  a,
		ctx:         ctx,
		lineId:      lineId,
		extensionId: extensionId,
	}
}

// Execute executes the request
func (a *ExtensionsAPIService) AssociateLineExtensionExecute(r ExtensionsAPIAssociateLineExtensionRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodPut
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ExtensionsAPIService.AssociateLineExtension")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/lines/{line_id}/extensions/{extension_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"line_id"+"}", url.PathEscape(parameterValueToString(r.lineId, "lineId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"extension_id"+"}", url.PathEscape(parameterValueToString(r.extensionId, "extensionId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["accent_auth_token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Auth-Token"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v []string
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v []string
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ExtensionsAPIAssociateOutcallExtensionRequest struct {
	ctx         context.Context
	ApiService  ExtensionsAPI
	outcallId   int32
	extensionId int32
	body        *OutcallExtension
}

// Outgoing Extension
func (r ExtensionsAPIAssociateOutcallExtensionRequest) Body(body OutcallExtension) ExtensionsAPIAssociateOutcallExtensionRequest {
	r.body = &body
	return r
}

func (r ExtensionsAPIAssociateOutcallExtensionRequest) Execute() (*http.Response, error) {
	return r.ApiService.AssociateOutcallExtensionExecute(r)
}

/*
AssociateOutcallExtension Associate outcall and extension

**Required ACL:** `confd.outcalls.{outcall_id}.extensions.{extension_id}.update`

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param outcallId Outgoing call's ID
	@param extensionId
	@return ExtensionsAPIAssociateOutcallExtensionRequest
*/
func (a *ExtensionsAPIService) AssociateOutcallExtension(ctx context.Context, outcallId int32, extensionId int32) ExtensionsAPIAssociateOutcallExtensionRequest {
	return ExtensionsAPIAssociateOutcallExtensionRequest{
		ApiService:  a,
		ctx:         ctx,
		outcallId:   outcallId,
		extensionId: extensionId,
	}
}

// Execute executes the request
func (a *ExtensionsAPIService) AssociateOutcallExtensionExecute(r ExtensionsAPIAssociateOutcallExtensionRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodPut
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ExtensionsAPIService.AssociateOutcallExtension")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/outcalls/{outcall_id}/extensions/{extension_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"outcall_id"+"}", url.PathEscape(parameterValueToString(r.outcallId, "outcallId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"extension_id"+"}", url.PathEscape(parameterValueToString(r.extensionId, "extensionId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["accent_auth_token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Auth-Token"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v []string
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v []string
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ExtensionsAPIAssociateParkingLotExtensionRequest struct {
	ctx          context.Context
	ApiService   ExtensionsAPI
	parkingLotId int32
	extensionId  int32
}

func (r ExtensionsAPIAssociateParkingLotExtensionRequest) Execute() (*http.Response, error) {
	return r.ApiService.AssociateParkingLotExtensionExecute(r)
}

/*
AssociateParkingLotExtension Associate parking_lot and extension

**Required ACL:** `confd.parkinglots.{parking_lot_id}.extensions.{extension_id}.update`

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param parkingLotId Parking Lot's ID
	@param extensionId
	@return ExtensionsAPIAssociateParkingLotExtensionRequest
*/
func (a *ExtensionsAPIService) AssociateParkingLotExtension(ctx context.Context, parkingLotId int32, extensionId int32) ExtensionsAPIAssociateParkingLotExtensionRequest {
	return ExtensionsAPIAssociateParkingLotExtensionRequest{
		ApiService:   a,
		ctx:          ctx,
		parkingLotId: parkingLotId,
		extensionId:  extensionId,
	}
}

// Execute executes the request
func (a *ExtensionsAPIService) AssociateParkingLotExtensionExecute(r ExtensionsAPIAssociateParkingLotExtensionRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodPut
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ExtensionsAPIService.AssociateParkingLotExtension")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/parkinglots/{parking_lot_id}/extensions/{extension_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"parking_lot_id"+"}", url.PathEscape(parameterValueToString(r.parkingLotId, "parkingLotId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"extension_id"+"}", url.PathEscape(parameterValueToString(r.extensionId, "extensionId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["accent_auth_token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Auth-Token"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v []string
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v []string
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ExtensionsAPIAssociateQueueExtensionRequest struct {
	ctx          context.Context
	ApiService   ExtensionsAPI
	queueId      int32
	extensionId  int32
	accentTenant *string
}

// The tenant&#39;s UUID, defining the ownership of a given resource.
func (r ExtensionsAPIAssociateQueueExtensionRequest) AccentTenant(accentTenant string) ExtensionsAPIAssociateQueueExtensionRequest {
	r.accentTenant = &accentTenant
	return r
}

func (r ExtensionsAPIAssociateQueueExtensionRequest) Execute() (*http.Response, error) {
	return r.ApiService.AssociateQueueExtensionExecute(r)
}

/*
AssociateQueueExtension Associate queue and extension

**Required ACL:** `confd.queues.{queue_id}.extensions.{extension_id}.update`

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param queueId queue's ID
	@param extensionId
	@return ExtensionsAPIAssociateQueueExtensionRequest
*/
func (a *ExtensionsAPIService) AssociateQueueExtension(ctx context.Context, queueId int32, extensionId int32) ExtensionsAPIAssociateQueueExtensionRequest {
	return ExtensionsAPIAssociateQueueExtensionRequest{
		ApiService:  a,
		ctx:         ctx,
		queueId:     queueId,
		extensionId: extensionId,
	}
}

// Execute executes the request
func (a *ExtensionsAPIService) AssociateQueueExtensionExecute(r ExtensionsAPIAssociateQueueExtensionRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodPut
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ExtensionsAPIService.AssociateQueueExtension")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/queues/{queue_id}/extensions/{extension_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"queue_id"+"}", url.PathEscape(parameterValueToString(r.queueId, "queueId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"extension_id"+"}", url.PathEscape(parameterValueToString(r.extensionId, "extensionId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.accentTenant != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accent-Tenant", r.accentTenant, "")
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["accent_auth_token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Auth-Token"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v []string
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v []string
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ExtensionsAPICreateExtensionRequest struct {
	ctx          context.Context
	ApiService   ExtensionsAPI
	body         *Extension
	accentTenant *string
}

// Extension to create
func (r ExtensionsAPICreateExtensionRequest) Body(body Extension) ExtensionsAPICreateExtensionRequest {
	r.body = &body
	return r
}

// The tenant&#39;s UUID, defining the ownership of a given resource.
func (r ExtensionsAPICreateExtensionRequest) AccentTenant(accentTenant string) ExtensionsAPICreateExtensionRequest {
	r.accentTenant = &accentTenant
	return r
}

func (r ExtensionsAPICreateExtensionRequest) Execute() (*Extension, *http.Response, error) {
	return r.ApiService.CreateExtensionExecute(r)
}

/*
CreateExtension Create extension

**Required ACL:** `confd.extensions.create`

The extension number must be included in one of the extension ranges for the given context.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ExtensionsAPICreateExtensionRequest
*/
func (a *ExtensionsAPIService) CreateExtension(ctx context.Context) ExtensionsAPICreateExtensionRequest {
	return ExtensionsAPICreateExtensionRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return Extension
func (a *ExtensionsAPIService) CreateExtensionExecute(r ExtensionsAPICreateExtensionRequest) (*Extension, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *Extension
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ExtensionsAPIService.CreateExtension")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/extensions"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("body is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.accentTenant != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accent-Tenant", r.accentTenant, "")
	}
	// body params
	localVarPostBody = r.body
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["accent_auth_token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Auth-Token"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v []string
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ExtensionsAPICreateLineExtensionRequest struct {
	ctx          context.Context
	ApiService   ExtensionsAPI
	body         *Extension
	lineId       int32
	accentTenant *string
}

// Extension to create
func (r ExtensionsAPICreateLineExtensionRequest) Body(body Extension) ExtensionsAPICreateLineExtensionRequest {
	r.body = &body
	return r
}

// The tenant&#39;s UUID, defining the ownership of a given resource.
func (r ExtensionsAPICreateLineExtensionRequest) AccentTenant(accentTenant string) ExtensionsAPICreateLineExtensionRequest {
	r.accentTenant = &accentTenant
	return r
}

func (r ExtensionsAPICreateLineExtensionRequest) Execute() (*Extension, *http.Response, error) {
	return r.ApiService.CreateLineExtensionExecute(r)
}

/*
CreateLineExtension Create extension

**Required ACL:** `confd.lines.{line_id}.extensions.create`
The extension number must be included in one of the extension ranges for the given context.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param lineId
	@return ExtensionsAPICreateLineExtensionRequest
*/
func (a *ExtensionsAPIService) CreateLineExtension(ctx context.Context, lineId int32) ExtensionsAPICreateLineExtensionRequest {
	return ExtensionsAPICreateLineExtensionRequest{
		ApiService: a,
		ctx:        ctx,
		lineId:     lineId,
	}
}

// Execute executes the request
//
//	@return Extension
func (a *ExtensionsAPIService) CreateLineExtensionExecute(r ExtensionsAPICreateLineExtensionRequest) (*Extension, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *Extension
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ExtensionsAPIService.CreateLineExtension")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/lines/{line_id}/extensions"
	localVarPath = strings.Replace(localVarPath, "{"+"line_id"+"}", url.PathEscape(parameterValueToString(r.lineId, "lineId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("body is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.accentTenant != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accent-Tenant", r.accentTenant, "")
	}
	// body params
	localVarPostBody = r.body
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["accent_auth_token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Auth-Token"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v []string
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v Object
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ExtensionsAPIDeleteExtensionRequest struct {
	ctx         context.Context
	ApiService  ExtensionsAPI
	extensionId int32
}

func (r ExtensionsAPIDeleteExtensionRequest) Execute() (*http.Response, error) {
	return r.ApiService.DeleteExtensionExecute(r)
}

/*
DeleteExtension Delete extension

**Required ACL:** `confd.extensions.{extension_id}.delete`

An extension can not be deleted if it is associated to a line. You must delete the association first.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param extensionId
	@return ExtensionsAPIDeleteExtensionRequest
*/
func (a *ExtensionsAPIService) DeleteExtension(ctx context.Context, extensionId int32) ExtensionsAPIDeleteExtensionRequest {
	return ExtensionsAPIDeleteExtensionRequest{
		ApiService:  a,
		ctx:         ctx,
		extensionId: extensionId,
	}
}

// Execute executes the request
func (a *ExtensionsAPIService) DeleteExtensionExecute(r ExtensionsAPIDeleteExtensionRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodDelete
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ExtensionsAPIService.DeleteExtension")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/extensions/{extension_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"extension_id"+"}", url.PathEscape(parameterValueToString(r.extensionId, "extensionId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["accent_auth_token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Auth-Token"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v []string
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ExtensionsAPIDissociateConferenceExtensionRequest struct {
	ctx          context.Context
	ApiService   ExtensionsAPI
	conferenceId int32
	extensionId  int32
}

func (r ExtensionsAPIDissociateConferenceExtensionRequest) Execute() (*http.Response, error) {
	return r.ApiService.DissociateConferenceExtensionExecute(r)
}

/*
DissociateConferenceExtension Dissociate conference and extension

**Required ACL:** `confd.conferences.{conference_id}.extensions.{extension_id}.delete`

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param conferenceId Conference's ID
	@param extensionId
	@return ExtensionsAPIDissociateConferenceExtensionRequest
*/
func (a *ExtensionsAPIService) DissociateConferenceExtension(ctx context.Context, conferenceId int32, extensionId int32) ExtensionsAPIDissociateConferenceExtensionRequest {
	return ExtensionsAPIDissociateConferenceExtensionRequest{
		ApiService:   a,
		ctx:          ctx,
		conferenceId: conferenceId,
		extensionId:  extensionId,
	}
}

// Execute executes the request
func (a *ExtensionsAPIService) DissociateConferenceExtensionExecute(r ExtensionsAPIDissociateConferenceExtensionRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodDelete
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ExtensionsAPIService.DissociateConferenceExtension")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/conferences/{conference_id}/extensions/{extension_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"conference_id"+"}", url.PathEscape(parameterValueToString(r.conferenceId, "conferenceId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"extension_id"+"}", url.PathEscape(parameterValueToString(r.extensionId, "extensionId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["accent_auth_token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Auth-Token"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v []string
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v []string
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ExtensionsAPIDissociateGroupExtensionRequest struct {
	ctx         context.Context
	ApiService  ExtensionsAPI
	groupUuid   string
	extensionId int32
}

func (r ExtensionsAPIDissociateGroupExtensionRequest) Execute() (*http.Response, error) {
	return r.ApiService.DissociateGroupExtensionExecute(r)
}

/*
DissociateGroupExtension Dissociate group and extension

**Required ACL:** `confd.groups.{group_uuid}.extensions.{extension_id}.delete`

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param groupUuid the group's UUID
	@param extensionId
	@return ExtensionsAPIDissociateGroupExtensionRequest
*/
func (a *ExtensionsAPIService) DissociateGroupExtension(ctx context.Context, groupUuid string, extensionId int32) ExtensionsAPIDissociateGroupExtensionRequest {
	return ExtensionsAPIDissociateGroupExtensionRequest{
		ApiService:  a,
		ctx:         ctx,
		groupUuid:   groupUuid,
		extensionId: extensionId,
	}
}

// Execute executes the request
func (a *ExtensionsAPIService) DissociateGroupExtensionExecute(r ExtensionsAPIDissociateGroupExtensionRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodDelete
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ExtensionsAPIService.DissociateGroupExtension")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/groups/{group_uuid}/extensions/{extension_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"group_uuid"+"}", url.PathEscape(parameterValueToString(r.groupUuid, "groupUuid")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"extension_id"+"}", url.PathEscape(parameterValueToString(r.extensionId, "extensionId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["accent_auth_token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Auth-Token"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v []string
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v []string
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ExtensionsAPIDissociateIncallExtensionRequest struct {
	ctx         context.Context
	ApiService  ExtensionsAPI
	incallId    int32
	extensionId int32
}

func (r ExtensionsAPIDissociateIncallExtensionRequest) Execute() (*http.Response, error) {
	return r.ApiService.DissociateIncallExtensionExecute(r)
}

/*
DissociateIncallExtension Dissociate incall and extension

**Required ACL:** `confd.incalls.{incall_id}.extensions.{extension_id}.delete`

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param incallId Incoming call's ID
	@param extensionId
	@return ExtensionsAPIDissociateIncallExtensionRequest
*/
func (a *ExtensionsAPIService) DissociateIncallExtension(ctx context.Context, incallId int32, extensionId int32) ExtensionsAPIDissociateIncallExtensionRequest {
	return ExtensionsAPIDissociateIncallExtensionRequest{
		ApiService:  a,
		ctx:         ctx,
		incallId:    incallId,
		extensionId: extensionId,
	}
}

// Execute executes the request
func (a *ExtensionsAPIService) DissociateIncallExtensionExecute(r ExtensionsAPIDissociateIncallExtensionRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodDelete
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ExtensionsAPIService.DissociateIncallExtension")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/incalls/{incall_id}/extensions/{extension_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"incall_id"+"}", url.PathEscape(parameterValueToString(r.incallId, "incallId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"extension_id"+"}", url.PathEscape(parameterValueToString(r.extensionId, "extensionId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["accent_auth_token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Auth-Token"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v []string
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v []string
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ExtensionsAPIDissociateLineExtensionRequest struct {
	ctx         context.Context
	ApiService  ExtensionsAPI
	lineId      int32
	extensionId int32
}

func (r ExtensionsAPIDissociateLineExtensionRequest) Execute() (*http.Response, error) {
	return r.ApiService.DissociateLineExtensionExecute(r)
}

/*
DissociateLineExtension Dissociate line and extension

**Required ACL:** `confd.lines.{line_id}.extensions.{extension_id}.delete`

Any devices that are attached to a line must be removed before dissociating an extension from its line. A device can be dissociated by resetting it to autoprov mode.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param lineId
	@param extensionId
	@return ExtensionsAPIDissociateLineExtensionRequest
*/
func (a *ExtensionsAPIService) DissociateLineExtension(ctx context.Context, lineId int32, extensionId int32) ExtensionsAPIDissociateLineExtensionRequest {
	return ExtensionsAPIDissociateLineExtensionRequest{
		ApiService:  a,
		ctx:         ctx,
		lineId:      lineId,
		extensionId: extensionId,
	}
}

// Execute executes the request
func (a *ExtensionsAPIService) DissociateLineExtensionExecute(r ExtensionsAPIDissociateLineExtensionRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodDelete
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ExtensionsAPIService.DissociateLineExtension")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/lines/{line_id}/extensions/{extension_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"line_id"+"}", url.PathEscape(parameterValueToString(r.lineId, "lineId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"extension_id"+"}", url.PathEscape(parameterValueToString(r.extensionId, "extensionId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["accent_auth_token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Auth-Token"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v []string
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v []string
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ExtensionsAPIDissociateOutcallExtensionRequest struct {
	ctx         context.Context
	ApiService  ExtensionsAPI
	outcallId   int32
	extensionId int32
}

func (r ExtensionsAPIDissociateOutcallExtensionRequest) Execute() (*http.Response, error) {
	return r.ApiService.DissociateOutcallExtensionExecute(r)
}

/*
DissociateOutcallExtension Dissociate outcall and extension

**Required ACL:** `confd.outcalls.{outcall_id}.extensions.{extension_id}.delete`

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param outcallId Outgoing call's ID
	@param extensionId
	@return ExtensionsAPIDissociateOutcallExtensionRequest
*/
func (a *ExtensionsAPIService) DissociateOutcallExtension(ctx context.Context, outcallId int32, extensionId int32) ExtensionsAPIDissociateOutcallExtensionRequest {
	return ExtensionsAPIDissociateOutcallExtensionRequest{
		ApiService:  a,
		ctx:         ctx,
		outcallId:   outcallId,
		extensionId: extensionId,
	}
}

// Execute executes the request
func (a *ExtensionsAPIService) DissociateOutcallExtensionExecute(r ExtensionsAPIDissociateOutcallExtensionRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodDelete
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ExtensionsAPIService.DissociateOutcallExtension")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/outcalls/{outcall_id}/extensions/{extension_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"outcall_id"+"}", url.PathEscape(parameterValueToString(r.outcallId, "outcallId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"extension_id"+"}", url.PathEscape(parameterValueToString(r.extensionId, "extensionId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["accent_auth_token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Auth-Token"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v []string
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v []string
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ExtensionsAPIDissociateParkingLotExtensionRequest struct {
	ctx          context.Context
	ApiService   ExtensionsAPI
	parkingLotId int32
	extensionId  int32
}

func (r ExtensionsAPIDissociateParkingLotExtensionRequest) Execute() (*http.Response, error) {
	return r.ApiService.DissociateParkingLotExtensionExecute(r)
}

/*
DissociateParkingLotExtension Dissociate parking lot and extension

**Required ACL:** `confd.parkinglots.{parking_lot_id}.extensions.{extension_id}.delete`

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param parkingLotId Parking Lot's ID
	@param extensionId
	@return ExtensionsAPIDissociateParkingLotExtensionRequest
*/
func (a *ExtensionsAPIService) DissociateParkingLotExtension(ctx context.Context, parkingLotId int32, extensionId int32) ExtensionsAPIDissociateParkingLotExtensionRequest {
	return ExtensionsAPIDissociateParkingLotExtensionRequest{
		ApiService:   a,
		ctx:          ctx,
		parkingLotId: parkingLotId,
		extensionId:  extensionId,
	}
}

// Execute executes the request
func (a *ExtensionsAPIService) DissociateParkingLotExtensionExecute(r ExtensionsAPIDissociateParkingLotExtensionRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodDelete
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ExtensionsAPIService.DissociateParkingLotExtension")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/parkinglots/{parking_lot_id}/extensions/{extension_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"parking_lot_id"+"}", url.PathEscape(parameterValueToString(r.parkingLotId, "parkingLotId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"extension_id"+"}", url.PathEscape(parameterValueToString(r.extensionId, "extensionId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["accent_auth_token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Auth-Token"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v []string
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v []string
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ExtensionsAPIDissociateQueueExtensionRequest struct {
	ctx          context.Context
	ApiService   ExtensionsAPI
	queueId      int32
	extensionId  int32
	accentTenant *string
}

// The tenant&#39;s UUID, defining the ownership of a given resource.
func (r ExtensionsAPIDissociateQueueExtensionRequest) AccentTenant(accentTenant string) ExtensionsAPIDissociateQueueExtensionRequest {
	r.accentTenant = &accentTenant
	return r
}

func (r ExtensionsAPIDissociateQueueExtensionRequest) Execute() (*http.Response, error) {
	return r.ApiService.DissociateQueueExtensionExecute(r)
}

/*
DissociateQueueExtension Dissociate queue and extension

**Required ACL:** `confd.queues.{queue_id}.extensions.{extension_id}.delete`

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param queueId queue's ID
	@param extensionId
	@return ExtensionsAPIDissociateQueueExtensionRequest
*/
func (a *ExtensionsAPIService) DissociateQueueExtension(ctx context.Context, queueId int32, extensionId int32) ExtensionsAPIDissociateQueueExtensionRequest {
	return ExtensionsAPIDissociateQueueExtensionRequest{
		ApiService:  a,
		ctx:         ctx,
		queueId:     queueId,
		extensionId: extensionId,
	}
}

// Execute executes the request
func (a *ExtensionsAPIService) DissociateQueueExtensionExecute(r ExtensionsAPIDissociateQueueExtensionRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodDelete
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ExtensionsAPIService.DissociateQueueExtension")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/queues/{queue_id}/extensions/{extension_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"queue_id"+"}", url.PathEscape(parameterValueToString(r.queueId, "queueId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"extension_id"+"}", url.PathEscape(parameterValueToString(r.extensionId, "extensionId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.accentTenant != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accent-Tenant", r.accentTenant, "")
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["accent_auth_token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Auth-Token"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v []string
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v []string
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ExtensionsAPIGetExtensionRequest struct {
	ctx         context.Context
	ApiService  ExtensionsAPI
	extensionId int32
}

func (r ExtensionsAPIGetExtensionRequest) Execute() (*Extension, *http.Response, error) {
	return r.ApiService.GetExtensionExecute(r)
}

/*
GetExtension Get extension

**Required ACL:** `confd.extensions.{extension_id}.read`

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param extensionId
	@return ExtensionsAPIGetExtensionRequest
*/
func (a *ExtensionsAPIService) GetExtension(ctx context.Context, extensionId int32) ExtensionsAPIGetExtensionRequest {
	return ExtensionsAPIGetExtensionRequest{
		ApiService:  a,
		ctx:         ctx,
		extensionId: extensionId,
	}
}

// Execute executes the request
//
//	@return Extension
func (a *ExtensionsAPIService) GetExtensionExecute(r ExtensionsAPIGetExtensionRequest) (*Extension, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *Extension
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ExtensionsAPIService.GetExtension")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/extensions/{extension_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"extension_id"+"}", url.PathEscape(parameterValueToString(r.extensionId, "extensionId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["accent_auth_token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Auth-Token"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v []string
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ExtensionsAPIGetExtensionFeatureRequest struct {
	ctx           context.Context
	ApiService    ExtensionsAPI
	extensionUuid string
}

func (r ExtensionsAPIGetExtensionFeatureRequest) Execute() (*ExtensionFeature, *http.Response, error) {
	return r.ApiService.GetExtensionFeatureExecute(r)
}

/*
GetExtensionFeature Get extension feature

**Required ACL:** `confd.extensions.features.{extension_uuid}.read`

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param extensionUuid
	@return ExtensionsAPIGetExtensionFeatureRequest
*/
func (a *ExtensionsAPIService) GetExtensionFeature(ctx context.Context, extensionUuid string) ExtensionsAPIGetExtensionFeatureRequest {
	return ExtensionsAPIGetExtensionFeatureRequest{
		ApiService:    a,
		ctx:           ctx,
		extensionUuid: extensionUuid,
	}
}

// Execute executes the request
//
//	@return ExtensionFeature
func (a *ExtensionsAPIService) GetExtensionFeatureExecute(r ExtensionsAPIGetExtensionFeatureRequest) (*ExtensionFeature, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *ExtensionFeature
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ExtensionsAPIService.GetExtensionFeature")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/extensions/features/{extension_uuid}"
	localVarPath = strings.Replace(localVarPath, "{"+"extension_uuid"+"}", url.PathEscape(parameterValueToString(r.extensionUuid, "extensionUuid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["accent_auth_token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Auth-Token"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v []string
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ExtensionsAPIListExtensionsRequest struct {
	ctx          context.Context
	ApiService   ExtensionsAPI
	accentTenant *string
	recurse      *bool
	order        *string
	direction    *string
	limit        *int32
	offset       *int32
	search       *string
	type_        *string
	exten        *string
	context      *string
}

// The tenant&#39;s UUID, defining the ownership of a given resource.
func (r ExtensionsAPIListExtensionsRequest) AccentTenant(accentTenant string) ExtensionsAPIListExtensionsRequest {
	r.accentTenant = &accentTenant
	return r
}

// Should the query include sub-tenants
func (r ExtensionsAPIListExtensionsRequest) Recurse(recurse bool) ExtensionsAPIListExtensionsRequest {
	r.recurse = &recurse
	return r
}

// Name of the field to use for sorting the list of items returned.
func (r ExtensionsAPIListExtensionsRequest) Order(order string) ExtensionsAPIListExtensionsRequest {
	r.order = &order
	return r
}

// Sort list of items in &#39;asc&#39; (ascending) or &#39;desc&#39; (descending) order
func (r ExtensionsAPIListExtensionsRequest) Direction(direction string) ExtensionsAPIListExtensionsRequest {
	r.direction = &direction
	return r
}

// Maximum number of items to return in the list
func (r ExtensionsAPIListExtensionsRequest) Limit(limit int32) ExtensionsAPIListExtensionsRequest {
	r.limit = &limit
	return r
}

// Number of items to skip over in the list. Useful for pagination.
func (r ExtensionsAPIListExtensionsRequest) Offset(offset int32) ExtensionsAPIListExtensionsRequest {
	r.offset = &offset
	return r
}

// Search term for filtering a list of items. Only items with a field containing the search term will be returned.
func (r ExtensionsAPIListExtensionsRequest) Search(search string) ExtensionsAPIListExtensionsRequest {
	r.search = &search
	return r
}

// Filter extensions of a certain type. Internal: Used for calling a line with an internal number (e.g. “1000@default”). Incall: Used for calling a line from the outside (e.g. “from-extern” with a DID)
func (r ExtensionsAPIListExtensionsRequest) Type_(type_ string) ExtensionsAPIListExtensionsRequest {
	r.type_ = &type_
	return r
}

// Filter extensions by exten number
func (r ExtensionsAPIListExtensionsRequest) Exten(exten string) ExtensionsAPIListExtensionsRequest {
	r.exten = &exten
	return r
}

// Filter extensions by context name
func (r ExtensionsAPIListExtensionsRequest) Context(context string) ExtensionsAPIListExtensionsRequest {
	r.context = &context
	return r
}

func (r ExtensionsAPIListExtensionsRequest) Execute() (*ExtensionItems, *http.Response, error) {
	return r.ApiService.ListExtensionsExecute(r)
}

/*
ListExtensions List extensions

**Required ACL:** `confd.extensions.read`

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ExtensionsAPIListExtensionsRequest
*/
func (a *ExtensionsAPIService) ListExtensions(ctx context.Context) ExtensionsAPIListExtensionsRequest {
	return ExtensionsAPIListExtensionsRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return ExtensionItems
func (a *ExtensionsAPIService) ListExtensionsExecute(r ExtensionsAPIListExtensionsRequest) (*ExtensionItems, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *ExtensionItems
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ExtensionsAPIService.ListExtensions")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/extensions"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.recurse != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "recurse", r.recurse, "")
	} else {
		var defaultValue bool = false
		r.recurse = &defaultValue
	}
	if r.order != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "order", r.order, "")
	}
	if r.direction != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "direction", r.direction, "")
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "")
	}
	if r.offset != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "offset", r.offset, "")
	}
	if r.search != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "search", r.search, "")
	}
	if r.type_ != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "type", r.type_, "")
	}
	if r.exten != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "exten", r.exten, "")
	}
	if r.context != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "context", r.context, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.accentTenant != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accent-Tenant", r.accentTenant, "")
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["accent_auth_token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Auth-Token"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ExtensionsAPIListExtensionsFeaturesRequest struct {
	ctx        context.Context
	ApiService ExtensionsAPI
	order      *string
	direction  *string
	limit      *int32
	offset     *int32
	search     *string
}

// Name of the field to use for sorting the list of items returned.
func (r ExtensionsAPIListExtensionsFeaturesRequest) Order(order string) ExtensionsAPIListExtensionsFeaturesRequest {
	r.order = &order
	return r
}

// Sort list of items in &#39;asc&#39; (ascending) or &#39;desc&#39; (descending) order
func (r ExtensionsAPIListExtensionsFeaturesRequest) Direction(direction string) ExtensionsAPIListExtensionsFeaturesRequest {
	r.direction = &direction
	return r
}

// Maximum number of items to return in the list
func (r ExtensionsAPIListExtensionsFeaturesRequest) Limit(limit int32) ExtensionsAPIListExtensionsFeaturesRequest {
	r.limit = &limit
	return r
}

// Number of items to skip over in the list. Useful for pagination.
func (r ExtensionsAPIListExtensionsFeaturesRequest) Offset(offset int32) ExtensionsAPIListExtensionsFeaturesRequest {
	r.offset = &offset
	return r
}

// Search term for filtering a list of items. Only items with a field containing the search term will be returned.
func (r ExtensionsAPIListExtensionsFeaturesRequest) Search(search string) ExtensionsAPIListExtensionsFeaturesRequest {
	r.search = &search
	return r
}

func (r ExtensionsAPIListExtensionsFeaturesRequest) Execute() (*ExtensionFeatureItems, *http.Response, error) {
	return r.ApiService.ListExtensionsFeaturesExecute(r)
}

/*
ListExtensionsFeatures List extensions features

**Required ACL:** `confd.extensions.features.read`

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ExtensionsAPIListExtensionsFeaturesRequest
*/
func (a *ExtensionsAPIService) ListExtensionsFeatures(ctx context.Context) ExtensionsAPIListExtensionsFeaturesRequest {
	return ExtensionsAPIListExtensionsFeaturesRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return ExtensionFeatureItems
func (a *ExtensionsAPIService) ListExtensionsFeaturesExecute(r ExtensionsAPIListExtensionsFeaturesRequest) (*ExtensionFeatureItems, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *ExtensionFeatureItems
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ExtensionsAPIService.ListExtensionsFeatures")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/extensions/features"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.order != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "order", r.order, "")
	}
	if r.direction != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "direction", r.direction, "")
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "")
	}
	if r.offset != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "offset", r.offset, "")
	}
	if r.search != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "search", r.search, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["accent_auth_token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Auth-Token"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ExtensionsAPIUpdateExtensionRequest struct {
	ctx         context.Context
	ApiService  ExtensionsAPI
	body        *Extension
	extensionId int32
}

func (r ExtensionsAPIUpdateExtensionRequest) Body(body Extension) ExtensionsAPIUpdateExtensionRequest {
	r.body = &body
	return r
}

func (r ExtensionsAPIUpdateExtensionRequest) Execute() (*http.Response, error) {
	return r.ApiService.UpdateExtensionExecute(r)
}

/*
UpdateExtension Update extension

**Required ACL:** `confd.extensions.{extension_id}.update`

The new extension number must be included in one of the extension ranges for the new context.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param extensionId
	@return ExtensionsAPIUpdateExtensionRequest
*/
func (a *ExtensionsAPIService) UpdateExtension(ctx context.Context, extensionId int32) ExtensionsAPIUpdateExtensionRequest {
	return ExtensionsAPIUpdateExtensionRequest{
		ApiService:  a,
		ctx:         ctx,
		extensionId: extensionId,
	}
}

// Execute executes the request
func (a *ExtensionsAPIService) UpdateExtensionExecute(r ExtensionsAPIUpdateExtensionRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodPut
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ExtensionsAPIService.UpdateExtension")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/extensions/{extension_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"extension_id"+"}", url.PathEscape(parameterValueToString(r.extensionId, "extensionId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return nil, reportError("body is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["accent_auth_token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Auth-Token"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v []string
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v []string
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ExtensionsAPIUpdateExtensionFeatureRequest struct {
	ctx           context.Context
	ApiService    ExtensionsAPI
	body          *ExtensionFeature
	extensionUuid string
}

func (r ExtensionsAPIUpdateExtensionFeatureRequest) Body(body ExtensionFeature) ExtensionsAPIUpdateExtensionFeatureRequest {
	r.body = &body
	return r
}

func (r ExtensionsAPIUpdateExtensionFeatureRequest) Execute() (*http.Response, error) {
	return r.ApiService.UpdateExtensionFeatureExecute(r)
}

/*
UpdateExtensionFeature Update extension

**Required ACL:** `confd.extensions.features.{extension_uuid}.update`

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param extensionUuid
	@return ExtensionsAPIUpdateExtensionFeatureRequest
*/
func (a *ExtensionsAPIService) UpdateExtensionFeature(ctx context.Context, extensionUuid string) ExtensionsAPIUpdateExtensionFeatureRequest {
	return ExtensionsAPIUpdateExtensionFeatureRequest{
		ApiService:    a,
		ctx:           ctx,
		extensionUuid: extensionUuid,
	}
}

// Execute executes the request
func (a *ExtensionsAPIService) UpdateExtensionFeatureExecute(r ExtensionsAPIUpdateExtensionFeatureRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodPut
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ExtensionsAPIService.UpdateExtensionFeature")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/extensions/features/{extension_uuid}"
	localVarPath = strings.Replace(localVarPath, "{"+"extension_uuid"+"}", url.PathEscape(parameterValueToString(r.extensionUuid, "extensionUuid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return nil, reportError("body is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["accent_auth_token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Auth-Token"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v []string
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v []string
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

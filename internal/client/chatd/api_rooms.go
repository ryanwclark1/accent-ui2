/*
accent-chatd

Control your message and presence from a REST API

API version: 1.0.0
Contact: help@accentvoice.io
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package chatd

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"strings"
	"time"
)

type RoomsAPI interface {

	/*
		CreateRoom Create room

		**Required ACL:** `chatd.users.me.rooms.create` **Warning**: **>=22.16**: If a room with the same participants exists, it will be returned instead of creating new one. In this case, no other parameter will be taken into account and the return code will be 201. This behaviour will disappear in the future and a 409 error will be raised.


		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@return RoomsAPICreateRoomRequest
	*/
	CreateRoom(ctx context.Context) RoomsAPICreateRoomRequest

	// CreateRoomExecute executes the request
	//  @return Room
	CreateRoomExecute(r RoomsAPICreateRoomRequest) (*Room, *http.Response, error)

	/*
		CreateRoomMessage Create room messages

		**Required ACL:** `chatd.users.me.rooms.{room_uuid}.messages.create`

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param roomUuid The UUID of the room
		@return RoomsAPICreateRoomMessageRequest
	*/
	CreateRoomMessage(ctx context.Context, roomUuid string) RoomsAPICreateRoomMessageRequest

	// CreateRoomMessageExecute executes the request
	//  @return Message
	CreateRoomMessageExecute(r RoomsAPICreateRoomMessageRequest) (*Message, *http.Response, error)

	/*
		GetRoom Get room

		**Required ACL:** `chatd.users.me.rooms.read`

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@return RoomsAPIGetRoomRequest
	*/
	GetRoom(ctx context.Context) RoomsAPIGetRoomRequest

	// GetRoomExecute executes the request
	//  @return Rooms
	GetRoomExecute(r RoomsAPIGetRoomRequest) (*Rooms, *http.Response, error)

	/*
		ListRoomMessage List room messages

		**Required ACL:** `chatd.users.me.rooms.{room_uuid}.messages.read`

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param roomUuid The UUID of the room
		@return RoomsAPIListRoomMessageRequest
	*/
	ListRoomMessage(ctx context.Context, roomUuid string) RoomsAPIListRoomMessageRequest

	// ListRoomMessageExecute executes the request
	//  @return Messages
	ListRoomMessageExecute(r RoomsAPIListRoomMessageRequest) (*Messages, *http.Response, error)

	/*
		ListRoomsMessages List rooms messages

		**Required ACL:** `chatd.users.me.rooms.messages.read`

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@return RoomsAPIListRoomsMessagesRequest
	*/
	ListRoomsMessages(ctx context.Context) RoomsAPIListRoomsMessagesRequest

	// ListRoomsMessagesExecute executes the request
	//  @return Messages
	ListRoomsMessagesExecute(r RoomsAPIListRoomsMessagesRequest) (*Messages, *http.Response, error)
}

// RoomsAPIService RoomsAPI service
type RoomsAPIService service

type RoomsAPICreateRoomRequest struct {
	ctx        context.Context
	ApiService RoomsAPI
	body       *Room
}

// room to create
func (r RoomsAPICreateRoomRequest) Body(body Room) RoomsAPICreateRoomRequest {
	r.body = &body
	return r
}

func (r RoomsAPICreateRoomRequest) Execute() (*Room, *http.Response, error) {
	return r.ApiService.CreateRoomExecute(r)
}

/*
CreateRoom Create room

**Required ACL:** `chatd.users.me.rooms.create` **Warning**: **>=22.16**: If a room with the same participants exists, it will be returned instead of creating new one. In this case, no other parameter will be taken into account and the return code will be 201. This behaviour will disappear in the future and a 409 error will be raised.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return RoomsAPICreateRoomRequest
*/
func (a *RoomsAPIService) CreateRoom(ctx context.Context) RoomsAPICreateRoomRequest {
	return RoomsAPICreateRoomRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return Room
func (a *RoomsAPIService) CreateRoomExecute(r RoomsAPICreateRoomRequest) (*Room, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *Room
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RoomsAPIService.CreateRoom")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/me/rooms"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("body is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["accent_auth_token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Auth-Token"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type RoomsAPICreateRoomMessageRequest struct {
	ctx        context.Context
	ApiService RoomsAPI
	body       *UserMessagePOST
	roomUuid   string
}

// message to create
func (r RoomsAPICreateRoomMessageRequest) Body(body UserMessagePOST) RoomsAPICreateRoomMessageRequest {
	r.body = &body
	return r
}

func (r RoomsAPICreateRoomMessageRequest) Execute() (*Message, *http.Response, error) {
	return r.ApiService.CreateRoomMessageExecute(r)
}

/*
CreateRoomMessage Create room messages

**Required ACL:** `chatd.users.me.rooms.{room_uuid}.messages.create`

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param roomUuid The UUID of the room
	@return RoomsAPICreateRoomMessageRequest
*/
func (a *RoomsAPIService) CreateRoomMessage(ctx context.Context, roomUuid string) RoomsAPICreateRoomMessageRequest {
	return RoomsAPICreateRoomMessageRequest{
		ApiService: a,
		ctx:        ctx,
		roomUuid:   roomUuid,
	}
}

// Execute executes the request
//
//	@return Message
func (a *RoomsAPIService) CreateRoomMessageExecute(r RoomsAPICreateRoomMessageRequest) (*Message, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *Message
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RoomsAPIService.CreateRoomMessage")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/me/rooms/{room_uuid}/messages"
	localVarPath = strings.Replace(localVarPath, "{"+"room_uuid"+"}", url.PathEscape(parameterValueToString(r.roomUuid, "roomUuid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("body is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["accent_auth_token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Auth-Token"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type RoomsAPIGetRoomRequest struct {
	ctx        context.Context
	ApiService RoomsAPI
	userUuid   *[]string
}

// Filter by user_uuid. Many uuid can be specified. A logical AND is used for filtering. Each uuid MUST be separated by a comma (,).
func (r RoomsAPIGetRoomRequest) UserUuid(userUuid []string) RoomsAPIGetRoomRequest {
	r.userUuid = &userUuid
	return r
}

func (r RoomsAPIGetRoomRequest) Execute() (*Rooms, *http.Response, error) {
	return r.ApiService.GetRoomExecute(r)
}

/*
GetRoom Get room

**Required ACL:** `chatd.users.me.rooms.read`

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return RoomsAPIGetRoomRequest
*/
func (a *RoomsAPIService) GetRoom(ctx context.Context) RoomsAPIGetRoomRequest {
	return RoomsAPIGetRoomRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return Rooms
func (a *RoomsAPIService) GetRoomExecute(r RoomsAPIGetRoomRequest) (*Rooms, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *Rooms
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RoomsAPIService.GetRoom")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/me/rooms"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.userUuid != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "user_uuid", r.userUuid, "csv")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["accent_auth_token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Auth-Token"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type RoomsAPIListRoomMessageRequest struct {
	ctx        context.Context
	ApiService RoomsAPI
	roomUuid   string
	fromDate   *time.Time
	direction  *string
	limit      *int32
	order      *string
	offset     *int32
	search     *string
}

// The date and time from which to retrieve messages. Example: 2019-06-12T10:00:00.000+00:00
func (r RoomsAPIListRoomMessageRequest) FromDate(fromDate time.Time) RoomsAPIListRoomMessageRequest {
	r.fromDate = &fromDate
	return r
}

// Sort list of items in &#39;asc&#39; (ascending) or &#39;desc&#39; (descending) order
func (r RoomsAPIListRoomMessageRequest) Direction(direction string) RoomsAPIListRoomMessageRequest {
	r.direction = &direction
	return r
}

// Maximum number of items to return in the list
func (r RoomsAPIListRoomMessageRequest) Limit(limit int32) RoomsAPIListRoomMessageRequest {
	r.limit = &limit
	return r
}

// Name of the field to use for sorting the list of items returned.
func (r RoomsAPIListRoomMessageRequest) Order(order string) RoomsAPIListRoomMessageRequest {
	r.order = &order
	return r
}

// Number of items to skip over in the list. Useful for pagination.
func (r RoomsAPIListRoomMessageRequest) Offset(offset int32) RoomsAPIListRoomMessageRequest {
	r.offset = &offset
	return r
}

// Search term for filtering a list of items. Only items with a field containing the search term will be returned. Required if &#x60;distinct&#x60; is not specified.
func (r RoomsAPIListRoomMessageRequest) Search(search string) RoomsAPIListRoomMessageRequest {
	r.search = &search
	return r
}

func (r RoomsAPIListRoomMessageRequest) Execute() (*Messages, *http.Response, error) {
	return r.ApiService.ListRoomMessageExecute(r)
}

/*
ListRoomMessage List room messages

**Required ACL:** `chatd.users.me.rooms.{room_uuid}.messages.read`

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param roomUuid The UUID of the room
	@return RoomsAPIListRoomMessageRequest
*/
func (a *RoomsAPIService) ListRoomMessage(ctx context.Context, roomUuid string) RoomsAPIListRoomMessageRequest {
	return RoomsAPIListRoomMessageRequest{
		ApiService: a,
		ctx:        ctx,
		roomUuid:   roomUuid,
	}
}

// Execute executes the request
//
//	@return Messages
func (a *RoomsAPIService) ListRoomMessageExecute(r RoomsAPIListRoomMessageRequest) (*Messages, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *Messages
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RoomsAPIService.ListRoomMessage")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/me/rooms/{room_uuid}/messages"
	localVarPath = strings.Replace(localVarPath, "{"+"room_uuid"+"}", url.PathEscape(parameterValueToString(r.roomUuid, "roomUuid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.fromDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "from_date", r.fromDate, "")
	}
	if r.direction != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "direction", r.direction, "")
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "")
	}
	if r.order != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "order", r.order, "")
	}
	if r.offset != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "offset", r.offset, "")
	}
	if r.search != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "search", r.search, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["accent_auth_token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Auth-Token"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type RoomsAPIListRoomsMessagesRequest struct {
	ctx        context.Context
	ApiService RoomsAPI
	direction  *string
	limit      *int32
	order      *string
	offset     *int32
	search     *string
	distinct   *string
}

// Sort list of items in &#39;asc&#39; (ascending) or &#39;desc&#39; (descending) order
func (r RoomsAPIListRoomsMessagesRequest) Direction(direction string) RoomsAPIListRoomsMessagesRequest {
	r.direction = &direction
	return r
}

// Maximum number of items to return in the list
func (r RoomsAPIListRoomsMessagesRequest) Limit(limit int32) RoomsAPIListRoomsMessagesRequest {
	r.limit = &limit
	return r
}

// Name of the field to use for sorting the list of items returned.
func (r RoomsAPIListRoomsMessagesRequest) Order(order string) RoomsAPIListRoomsMessagesRequest {
	r.order = &order
	return r
}

// Number of items to skip over in the list. Useful for pagination.
func (r RoomsAPIListRoomsMessagesRequest) Offset(offset int32) RoomsAPIListRoomsMessagesRequest {
	r.offset = &offset
	return r
}

// Search term for filtering a list of items. Only items with a field containing the search term will be returned.
func (r RoomsAPIListRoomsMessagesRequest) Search(search string) RoomsAPIListRoomsMessagesRequest {
	r.search = &search
	return r
}

// Distinct list results by field. Always picks the latest entry. Required if &#x60;search&#x60; is not specified.
func (r RoomsAPIListRoomsMessagesRequest) Distinct(distinct string) RoomsAPIListRoomsMessagesRequest {
	r.distinct = &distinct
	return r
}

func (r RoomsAPIListRoomsMessagesRequest) Execute() (*Messages, *http.Response, error) {
	return r.ApiService.ListRoomsMessagesExecute(r)
}

/*
ListRoomsMessages List rooms messages

**Required ACL:** `chatd.users.me.rooms.messages.read`

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return RoomsAPIListRoomsMessagesRequest
*/
func (a *RoomsAPIService) ListRoomsMessages(ctx context.Context) RoomsAPIListRoomsMessagesRequest {
	return RoomsAPIListRoomsMessagesRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return Messages
func (a *RoomsAPIService) ListRoomsMessagesExecute(r RoomsAPIListRoomsMessagesRequest) (*Messages, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *Messages
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RoomsAPIService.ListRoomsMessages")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/me/rooms/messages"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.direction != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "direction", r.direction, "")
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "")
	}
	if r.order != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "order", r.order, "")
	}
	if r.offset != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "offset", r.offset, "")
	}
	if r.search != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "search", r.search, "")
	}
	if r.distinct != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "distinct", r.distinct, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["accent_auth_token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Auth-Token"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

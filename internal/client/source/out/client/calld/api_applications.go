/*
accent-calld

Control your calls from a REST API

API version: 1.0.0
Contact: help@accentvoice.io
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package calld

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"strings"
)

type ApplicationsAPI interface {

	/*
		AnswerApplicationCall Answer a call

		**Required ACL:** `calld.applications.{application_uuid}.calls.{call_id}.answer.update`

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param applicationUuid UUID of the application
		@param callId ID of the call
		@return ApiAnswerApplicationCallRequest
	*/
	AnswerApplicationCall(ctx context.Context, applicationUuid string, callId string) ApiAnswerApplicationCallRequest

	// AnswerApplicationCallExecute executes the request
	AnswerApplicationCallExecute(r ApiAnswerApplicationCallRequest) (*http.Response, error)

	/*
		CreateApplicationCallToNode Make a new call to the node

		**Required ACL:** `calld.applications.{application_uuid}.nodes.{node_uuid}.calls.create`

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param applicationUuid UUID of the application
		@param nodeUuid UUID of the node
		@return ApiCreateApplicationCallToNodeRequest
	*/
	CreateApplicationCallToNode(ctx context.Context, applicationUuid string, nodeUuid string) ApiCreateApplicationCallToNodeRequest

	// CreateApplicationCallToNodeExecute executes the request
	//  @return ApplicationCall
	CreateApplicationCallToNodeExecute(r ApiCreateApplicationCallToNodeRequest) (*ApplicationCall, *http.Response, error)

	/*
		CreateApplicationCallToUser Initiate a call to a user and insert it in the node

		**Required ACL:** `calld.applications.{application_uuid}.nodes.{node_uuid}.calls.user.create`

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param applicationUuid UUID of the application
		@param nodeUuid UUID of the node
		@return ApiCreateApplicationCallToUserRequest
	*/
	CreateApplicationCallToUser(ctx context.Context, applicationUuid string, nodeUuid string) ApiCreateApplicationCallToUserRequest

	// CreateApplicationCallToUserExecute executes the request
	//  @return ApplicationCall
	CreateApplicationCallToUserExecute(r ApiCreateApplicationCallToUserRequest) (*ApplicationCall, *http.Response, error)

	/*
		CreateApplicationCalls Make a new call to the application

		**Required ACL:** `calld.applications.{application_uuid}.calls.create`

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param applicationUuid UUID of the application
		@return ApiCreateApplicationCallsRequest
	*/
	CreateApplicationCalls(ctx context.Context, applicationUuid string) ApiCreateApplicationCallsRequest

	// CreateApplicationCallsExecute executes the request
	//  @return ApplicationCall
	CreateApplicationCallsExecute(r ApiCreateApplicationCallsRequest) (*ApplicationCall, *http.Response, error)

	/*
		CreateApplicationNode Make a new node and add calls

		**Required ACL:** `calld.applications.{application_uuid}.nodes.create`

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param applicationUuid UUID of the application
		@return ApiCreateApplicationNodeRequest
	*/
	CreateApplicationNode(ctx context.Context, applicationUuid string) ApiCreateApplicationNodeRequest

	// CreateApplicationNodeExecute executes the request
	//  @return ApplicationNode
	CreateApplicationNodeExecute(r ApiCreateApplicationNodeRequest) (*ApplicationNode, *http.Response, error)

	/*
		DeleteApplicationCall Hangup a call from the application

		**Required ACL:** `calld.applications.{application_uuid}.calls.{call_id}.delete`

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param applicationUuid UUID of the application
		@param callId ID of the call
		@return ApiDeleteApplicationCallRequest
	*/
	DeleteApplicationCall(ctx context.Context, applicationUuid string, callId string) ApiDeleteApplicationCallRequest

	// DeleteApplicationCallExecute executes the request
	DeleteApplicationCallExecute(r ApiDeleteApplicationCallRequest) (*http.Response, error)

	/*
		DeleteApplicationCallFromNode Remove call from the node

		**Required ACL:** `calld.applications.{application_uuid}.nodes.{node_uuid}.calls.{call_id}.delete`

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param applicationUuid UUID of the application
		@param nodeUuid UUID of the node
		@param callId ID of the call
		@return ApiDeleteApplicationCallFromNodeRequest
	*/
	DeleteApplicationCallFromNode(ctx context.Context, applicationUuid string, nodeUuid string, callId string) ApiDeleteApplicationCallFromNodeRequest

	// DeleteApplicationCallFromNodeExecute executes the request
	DeleteApplicationCallFromNodeExecute(r ApiDeleteApplicationCallFromNodeRequest) (*http.Response, error)

	/*
		DeleteApplicationNode Delete node and hangup all calls

		**Required ACL:** `calld.applications.{application_uuid}.nodes.{node_uuid}.delete` **Not implemented**

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param applicationUuid UUID of the application
		@param nodeUuid UUID of the node
		@return ApiDeleteApplicationNodeRequest
	*/
	DeleteApplicationNode(ctx context.Context, applicationUuid string, nodeUuid string) ApiDeleteApplicationNodeRequest

	// DeleteApplicationNodeExecute executes the request
	DeleteApplicationNodeExecute(r ApiDeleteApplicationNodeRequest) (*http.Response, error)

	/*
		DeletePlayback Stop and remove playback

		**Required ACL:** `calld.applications.{application_uuid}.playbacks.{playback_uuid}.delete`

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param applicationUuid UUID of the application
		@param playbackUuid ID of the playback
		@return ApiDeletePlaybackRequest
	*/
	DeletePlayback(ctx context.Context, applicationUuid string, playbackUuid string) ApiDeletePlaybackRequest

	// DeletePlaybackExecute executes the request
	DeletePlaybackExecute(r ApiDeletePlaybackRequest) (*http.Response, error)

	/*
		GetApplication Show an application

		**Required ACL:** `calld.applications.{application_uuid}.read`

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param applicationUuid UUID of the application
		@return ApiGetApplicationRequest
	*/
	GetApplication(ctx context.Context, applicationUuid string) ApiGetApplicationRequest

	// GetApplicationExecute executes the request
	//  @return Application
	GetApplicationExecute(r ApiGetApplicationRequest) (*Application, *http.Response, error)

	/*
		GetApplicationCalls List calls from the application

		**Required ACL:** `calld.applications.{application_uuid}.calls.read`

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param applicationUuid UUID of the application
		@return ApiGetApplicationCallsRequest
	*/
	GetApplicationCalls(ctx context.Context, applicationUuid string) ApiGetApplicationCallsRequest

	// GetApplicationCallsExecute executes the request
	//  @return ApplicationCalls
	GetApplicationCallsExecute(r ApiGetApplicationCallsRequest) (*ApplicationCalls, *http.Response, error)

	/*
		GetApplicationNodes List nodes from the application

		**Required ACL:** `calld.applications.{application_uuid}.nodes.read`

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param applicationUuid UUID of the application
		@return ApiGetApplicationNodesRequest
	*/
	GetApplicationNodes(ctx context.Context, applicationUuid string) ApiGetApplicationNodesRequest

	// GetApplicationNodesExecute executes the request
	//  @return ApplicationNodes
	GetApplicationNodesExecute(r ApiGetApplicationNodesRequest) (*ApplicationNodes, *http.Response, error)

	/*
		GetNode Show a node

		**Required ACL:** `calld.applications.{application_uuid}.nodes.{node_uuid}.read`

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param applicationUuid UUID of the application
		@param nodeUuid UUID of the node
		@return ApiGetNodeRequest
	*/
	GetNode(ctx context.Context, applicationUuid string, nodeUuid string) ApiGetNodeRequest

	// GetNodeExecute executes the request
	//  @return ApplicationNode
	GetNodeExecute(r ApiGetNodeRequest) (*ApplicationNode, *http.Response, error)

	/*
		GetSnoop View snooping parameters

		**Required ACL:** `calld.applications.{application_uuid}.snoops.{snoop_uuid}.read`

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param applicationUuid UUID of the application
		@param snoopUuid UUID of the snoop
		@return ApiGetSnoopRequest
	*/
	GetSnoop(ctx context.Context, applicationUuid string, snoopUuid string) ApiGetSnoopRequest

	// GetSnoopExecute executes the request
	//  @return ApplicationSnoop
	GetSnoopExecute(r ApiGetSnoopRequest) (*ApplicationSnoop, *http.Response, error)

	/*
		HoldApplicationCall Place a call on hold

		**Required ACL:** `calld.applications.{application_uuid}.calls.{call_id}.hold.start.update`

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param applicationUuid UUID of the application
		@param callId ID of the call
		@return ApiHoldApplicationCallRequest
	*/
	HoldApplicationCall(ctx context.Context, applicationUuid string, callId string) ApiHoldApplicationCallRequest

	// HoldApplicationCallExecute executes the request
	HoldApplicationCallExecute(r ApiHoldApplicationCallRequest) (*http.Response, error)

	/*
		InsertApplicationCallToNode Insert call to the node

		**Required ACL:** `calld.applications.{application_uuid}.nodes.{node_uuid}.calls.{call_id}.update`

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param applicationUuid UUID of the application
		@param nodeUuid UUID of the node
		@param callId ID of the call
		@return ApiInsertApplicationCallToNodeRequest
	*/
	InsertApplicationCallToNode(ctx context.Context, applicationUuid string, nodeUuid string, callId string) ApiInsertApplicationCallToNodeRequest

	// InsertApplicationCallToNodeExecute executes the request
	InsertApplicationCallToNodeExecute(r ApiInsertApplicationCallToNodeRequest) (*http.Response, error)

	/*
		ListApplicationSnoops List active snoops

		**Required ACL:** `calld.applications.{application_uuid}.snoops.read`

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param applicationUuid UUID of the application
		@return ApiListApplicationSnoopsRequest
	*/
	ListApplicationSnoops(ctx context.Context, applicationUuid string) ApiListApplicationSnoopsRequest

	// ListApplicationSnoopsExecute executes the request
	//  @return ApplicationSnoops
	ListApplicationSnoopsExecute(r ApiListApplicationSnoopsRequest) (*ApplicationSnoops, *http.Response, error)

	/*
		MuteApplicationCall Mute a call

		**Required ACL:** `calld.applications.{application_uuid}.calls.{call_id}.mute.start.update`

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param applicationUuid UUID of the application
		@param callId ID of the call
		@return ApiMuteApplicationCallRequest
	*/
	MuteApplicationCall(ctx context.Context, applicationUuid string, callId string) ApiMuteApplicationCallRequest

	// MuteApplicationCallExecute executes the request
	MuteApplicationCallExecute(r ApiMuteApplicationCallRequest) (*http.Response, error)

	/*
		PlayApplicationCall Play file to the call

		**Required ACL:** `calld.applications.{application_uuid}.calls.{call_id}.playbacks.create`
	URI examples: * sound:tt-weasels * digits:4188001234 * number:321 * characters:abc * tone:ring * recording:my-recording

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param applicationUuid UUID of the application
		@param callId ID of the call
		@return ApiPlayApplicationCallRequest
	*/
	PlayApplicationCall(ctx context.Context, applicationUuid string, callId string) ApiPlayApplicationCallRequest

	// PlayApplicationCallExecute executes the request
	//  @return ApplicationPlayback
	PlayApplicationCallExecute(r ApiPlayApplicationCallRequest) (*ApplicationPlayback, *http.Response, error)

	/*
		ResumeApplicationCall Resume a call that has been placed on hold

		**Required ACL:** `calld.applications.{application_uuid}.calls.{call_id}.hold.stop.update

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param applicationUuid UUID of the application
		@param callId ID of the call
		@return ApiResumeApplicationCallRequest
	*/
	ResumeApplicationCall(ctx context.Context, applicationUuid string, callId string) ApiResumeApplicationCallRequest

	// ResumeApplicationCallExecute executes the request
	ResumeApplicationCallExecute(r ApiResumeApplicationCallRequest) (*http.Response, error)

	/*
		SendApplicationCallDTMF Simulate a user pressing DTMF keys

		**Required ACL:** `calld.applications.{application_uuid}.calls.{call_id}.dtmf.update

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param applicationUuid UUID of the application
		@param callId ID of the call
		@return ApiSendApplicationCallDTMFRequest
	*/
	SendApplicationCallDTMF(ctx context.Context, applicationUuid string, callId string) ApiSendApplicationCallDTMFRequest

	// SendApplicationCallDTMFExecute executes the request
	SendApplicationCallDTMFExecute(r ApiSendApplicationCallDTMFRequest) (*http.Response, error)

	/*
		SnoopApplicationCall Start snooping on a call

		**Required ACL:** `calld.applications.{application_uuid}.calls.{call_id}.snoops.create`
	The whisper mode indicate which part of the snooped channel can hear the snooper. Given Alice calls Bob and Charles snoops on Bob * none: No one can hear the snooper * both: Alice and Bob can hear Charles * in: Alice can hear Charles * out: Bob can hear Charles

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param applicationUuid UUID of the application
		@param callId ID of the call
		@return ApiSnoopApplicationCallRequest
	*/
	SnoopApplicationCall(ctx context.Context, applicationUuid string, callId string) ApiSnoopApplicationCallRequest

	// SnoopApplicationCallExecute executes the request
	//  @return ApplicationSnoop
	SnoopApplicationCallExecute(r ApiSnoopApplicationCallRequest) (*ApplicationSnoop, *http.Response, error)

	/*
		StartApplicationCallMOH Starts playing a music on hold

		**Required ACL:** `calld.applications.{application_uuid}.calls.{call_id}.moh.{moh_uuid}.start.update`
	Starts playing a music on hold on a call. If the music on hold is interrupted for a playback or another
	action, the music on hold will not restart automatically after the interruption.

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param applicationUuid UUID of the application
		@param callId ID of the call
		@param mohUuid UUID of the music on hold
		@return ApiStartApplicationCallMOHRequest
	*/
	StartApplicationCallMOH(ctx context.Context, applicationUuid string, callId string, mohUuid string) ApiStartApplicationCallMOHRequest

	// StartApplicationCallMOHExecute executes the request
	StartApplicationCallMOHExecute(r ApiStartApplicationCallMOHRequest) (*http.Response, error)

	/*
		StartApplicationCallProgress Play the progress ringing tone

		**Required ACL:** `calld.applications.{application_uuid}.calls.{call_id}.progress.start.update` The progress ringing tone is the sound heard by a caller while the other party is ringing.

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param applicationUuid UUID of the application
		@param callId ID of the call
		@return ApiStartApplicationCallProgressRequest
	*/
	StartApplicationCallProgress(ctx context.Context, applicationUuid string, callId string) ApiStartApplicationCallProgressRequest

	// StartApplicationCallProgressExecute executes the request
	StartApplicationCallProgressExecute(r ApiStartApplicationCallProgressRequest) (*http.Response, error)

	/*
		StopApplicationCallMOH Stops playing a music on hold

		**Required ACL:** `calld.applications.{application_uuid}.calls.{call_id}.moh.{moh_uuid}.stop.update

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param applicationUuid UUID of the application
		@param callId ID of the call
		@return ApiStopApplicationCallMOHRequest
	*/
	StopApplicationCallMOH(ctx context.Context, applicationUuid string, callId string) ApiStopApplicationCallMOHRequest

	// StopApplicationCallMOHExecute executes the request
	StopApplicationCallMOHExecute(r ApiStopApplicationCallMOHRequest) (*http.Response, error)

	/*
		StopApplicationCallProgress Stop playing the progress ringing tone.

		**Required ACL:** `calld.applications.{application_uuid}.calls.{call_id}.progress.stop.update` The progress ringing tone is the sound heard by a caller while the other party is ringing. Limitation: this only works when the ringing tone is played by Accent through audio media (e.g. when using `/progress` after `/answer`). If the phone is emitting the ringing tone directly to the user, then it cannot be stopped, and the response code will still be 204.

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param applicationUuid UUID of the application
		@param callId ID of the call
		@return ApiStopApplicationCallProgressRequest
	*/
	StopApplicationCallProgress(ctx context.Context, applicationUuid string, callId string) ApiStopApplicationCallProgressRequest

	// StopApplicationCallProgressExecute executes the request
	StopApplicationCallProgressExecute(r ApiStopApplicationCallProgressRequest) (*http.Response, error)

	/*
		StopSnoop Stop snooping

		**Required ACL:** `calld.applications.{application_uuid}.snoops.{snoop_uuid}.delete`

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param applicationUuid UUID of the application
		@param snoopUuid UUID of the snoop
		@return ApiStopSnoopRequest
	*/
	StopSnoop(ctx context.Context, applicationUuid string, snoopUuid string) ApiStopSnoopRequest

	// StopSnoopExecute executes the request
	StopSnoopExecute(r ApiStopSnoopRequest) (*http.Response, error)

	/*
		UnmuteApplicationCall Unmute a call

		**Required ACL:** `calld.applications.{application_uuid}.calls.{call_id}.mute.stop.update`

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param applicationUuid UUID of the application
		@param callId ID of the call
		@return ApiUnmuteApplicationCallRequest
	*/
	UnmuteApplicationCall(ctx context.Context, applicationUuid string, callId string) ApiUnmuteApplicationCallRequest

	// UnmuteApplicationCallExecute executes the request
	UnmuteApplicationCallExecute(r ApiUnmuteApplicationCallRequest) (*http.Response, error)

	/*
		UpdateSnoop Change snooping parameters

		**Required ACL:** `calld.applications.{application_uuid}.snoops.{snoop_uuid}.update`

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param applicationUuid UUID of the application
		@param snoopUuid UUID of the snoop
		@return ApiUpdateSnoopRequest
	*/
	UpdateSnoop(ctx context.Context, applicationUuid string, snoopUuid string) ApiUpdateSnoopRequest

	// UpdateSnoopExecute executes the request
	UpdateSnoopExecute(r ApiUpdateSnoopRequest) (*http.Response, error)
}

// ApplicationsAPIService ApplicationsAPI service
type ApplicationsAPIService service

type ApiAnswerApplicationCallRequest struct {
	ctx             context.Context
	ApiService      ApplicationsAPI
	applicationUuid string
	callId          string
}

func (r ApiAnswerApplicationCallRequest) Execute() (*http.Response, error) {
	return r.ApiService.AnswerApplicationCallExecute(r)
}

/*
AnswerApplicationCall Answer a call

**Required ACL:** `calld.applications.{application_uuid}.calls.{call_id}.answer.update`

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param applicationUuid UUID of the application
	@param callId ID of the call
	@return ApiAnswerApplicationCallRequest
*/
func (a *ApplicationsAPIService) AnswerApplicationCall(ctx context.Context, applicationUuid string, callId string) ApiAnswerApplicationCallRequest {
	return ApiAnswerApplicationCallRequest{
		ApiService:      a,
		ctx:             ctx,
		applicationUuid: applicationUuid,
		callId:          callId,
	}
}

// Execute executes the request
func (a *ApplicationsAPIService) AnswerApplicationCallExecute(r ApiAnswerApplicationCallRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodPut
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ApplicationsAPIService.AnswerApplicationCall")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/applications/{application_uuid}/calls/{call_id}/answer"
	localVarPath = strings.Replace(localVarPath, "{"+"application_uuid"+"}", url.PathEscape(parameterValueToString(r.applicationUuid, "applicationUuid")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"call_id"+"}", url.PathEscape(parameterValueToString(r.callId, "callId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["accent_auth_token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Auth-Token"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 503 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiCreateApplicationCallToNodeRequest struct {
	ctx             context.Context
	ApiService      ApplicationsAPI
	body            *ApplicationCallRequestToExten
	applicationUuid string
	nodeUuid        string
}

// Call parameters
func (r ApiCreateApplicationCallToNodeRequest) Body(body ApplicationCallRequestToExten) ApiCreateApplicationCallToNodeRequest {
	r.body = &body
	return r
}

func (r ApiCreateApplicationCallToNodeRequest) Execute() (*ApplicationCall, *http.Response, error) {
	return r.ApiService.CreateApplicationCallToNodeExecute(r)
}

/*
CreateApplicationCallToNode Make a new call to the node

**Required ACL:** `calld.applications.{application_uuid}.nodes.{node_uuid}.calls.create`

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param applicationUuid UUID of the application
	@param nodeUuid UUID of the node
	@return ApiCreateApplicationCallToNodeRequest
*/
func (a *ApplicationsAPIService) CreateApplicationCallToNode(ctx context.Context, applicationUuid string, nodeUuid string) ApiCreateApplicationCallToNodeRequest {
	return ApiCreateApplicationCallToNodeRequest{
		ApiService:      a,
		ctx:             ctx,
		applicationUuid: applicationUuid,
		nodeUuid:        nodeUuid,
	}
}

// Execute executes the request
//
//	@return ApplicationCall
func (a *ApplicationsAPIService) CreateApplicationCallToNodeExecute(r ApiCreateApplicationCallToNodeRequest) (*ApplicationCall, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *ApplicationCall
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ApplicationsAPIService.CreateApplicationCallToNode")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/applications/{application_uuid}/nodes/{node_uuid}/calls"
	localVarPath = strings.Replace(localVarPath, "{"+"application_uuid"+"}", url.PathEscape(parameterValueToString(r.applicationUuid, "applicationUuid")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"node_uuid"+"}", url.PathEscape(parameterValueToString(r.nodeUuid, "nodeUuid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("body is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["accent_auth_token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Auth-Token"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 503 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCreateApplicationCallToUserRequest struct {
	ctx             context.Context
	ApiService      ApplicationsAPI
	body            *ApplicationCallRequestToUser
	applicationUuid string
	nodeUuid        string
}

// Parameters for the new call
func (r ApiCreateApplicationCallToUserRequest) Body(body ApplicationCallRequestToUser) ApiCreateApplicationCallToUserRequest {
	r.body = &body
	return r
}

func (r ApiCreateApplicationCallToUserRequest) Execute() (*ApplicationCall, *http.Response, error) {
	return r.ApiService.CreateApplicationCallToUserExecute(r)
}

/*
CreateApplicationCallToUser Initiate a call to a user and insert it in the node

**Required ACL:** `calld.applications.{application_uuid}.nodes.{node_uuid}.calls.user.create`

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param applicationUuid UUID of the application
	@param nodeUuid UUID of the node
	@return ApiCreateApplicationCallToUserRequest
*/
func (a *ApplicationsAPIService) CreateApplicationCallToUser(ctx context.Context, applicationUuid string, nodeUuid string) ApiCreateApplicationCallToUserRequest {
	return ApiCreateApplicationCallToUserRequest{
		ApiService:      a,
		ctx:             ctx,
		applicationUuid: applicationUuid,
		nodeUuid:        nodeUuid,
	}
}

// Execute executes the request
//
//	@return ApplicationCall
func (a *ApplicationsAPIService) CreateApplicationCallToUserExecute(r ApiCreateApplicationCallToUserRequest) (*ApplicationCall, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *ApplicationCall
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ApplicationsAPIService.CreateApplicationCallToUser")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/applications/{application_uuid}/nodes/{node_uuid}/calls/user"
	localVarPath = strings.Replace(localVarPath, "{"+"application_uuid"+"}", url.PathEscape(parameterValueToString(r.applicationUuid, "applicationUuid")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"node_uuid"+"}", url.PathEscape(parameterValueToString(r.nodeUuid, "nodeUuid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("body is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["accent_auth_token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Auth-Token"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 503 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCreateApplicationCallsRequest struct {
	ctx             context.Context
	ApiService      ApplicationsAPI
	body            *ApplicationCallRequestToExten
	applicationUuid string
}

// node parameters
func (r ApiCreateApplicationCallsRequest) Body(body ApplicationCallRequestToExten) ApiCreateApplicationCallsRequest {
	r.body = &body
	return r
}

func (r ApiCreateApplicationCallsRequest) Execute() (*ApplicationCall, *http.Response, error) {
	return r.ApiService.CreateApplicationCallsExecute(r)
}

/*
CreateApplicationCalls Make a new call to the application

**Required ACL:** `calld.applications.{application_uuid}.calls.create`

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param applicationUuid UUID of the application
	@return ApiCreateApplicationCallsRequest
*/
func (a *ApplicationsAPIService) CreateApplicationCalls(ctx context.Context, applicationUuid string) ApiCreateApplicationCallsRequest {
	return ApiCreateApplicationCallsRequest{
		ApiService:      a,
		ctx:             ctx,
		applicationUuid: applicationUuid,
	}
}

// Execute executes the request
//
//	@return ApplicationCall
func (a *ApplicationsAPIService) CreateApplicationCallsExecute(r ApiCreateApplicationCallsRequest) (*ApplicationCall, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *ApplicationCall
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ApplicationsAPIService.CreateApplicationCalls")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/applications/{application_uuid}/calls"
	localVarPath = strings.Replace(localVarPath, "{"+"application_uuid"+"}", url.PathEscape(parameterValueToString(r.applicationUuid, "applicationUuid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("body is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["accent_auth_token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Auth-Token"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 503 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCreateApplicationNodeRequest struct {
	ctx             context.Context
	ApiService      ApplicationsAPI
	body            *ApplicationNodeRequest
	applicationUuid string
}

// node parameters
func (r ApiCreateApplicationNodeRequest) Body(body ApplicationNodeRequest) ApiCreateApplicationNodeRequest {
	r.body = &body
	return r
}

func (r ApiCreateApplicationNodeRequest) Execute() (*ApplicationNode, *http.Response, error) {
	return r.ApiService.CreateApplicationNodeExecute(r)
}

/*
CreateApplicationNode Make a new node and add calls

**Required ACL:** `calld.applications.{application_uuid}.nodes.create`

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param applicationUuid UUID of the application
	@return ApiCreateApplicationNodeRequest
*/
func (a *ApplicationsAPIService) CreateApplicationNode(ctx context.Context, applicationUuid string) ApiCreateApplicationNodeRequest {
	return ApiCreateApplicationNodeRequest{
		ApiService:      a,
		ctx:             ctx,
		applicationUuid: applicationUuid,
	}
}

// Execute executes the request
//
//	@return ApplicationNode
func (a *ApplicationsAPIService) CreateApplicationNodeExecute(r ApiCreateApplicationNodeRequest) (*ApplicationNode, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *ApplicationNode
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ApplicationsAPIService.CreateApplicationNode")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/applications/{application_uuid}/nodes"
	localVarPath = strings.Replace(localVarPath, "{"+"application_uuid"+"}", url.PathEscape(parameterValueToString(r.applicationUuid, "applicationUuid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("body is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["accent_auth_token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Auth-Token"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 503 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDeleteApplicationCallRequest struct {
	ctx             context.Context
	ApiService      ApplicationsAPI
	applicationUuid string
	callId          string
}

func (r ApiDeleteApplicationCallRequest) Execute() (*http.Response, error) {
	return r.ApiService.DeleteApplicationCallExecute(r)
}

/*
DeleteApplicationCall Hangup a call from the application

**Required ACL:** `calld.applications.{application_uuid}.calls.{call_id}.delete`

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param applicationUuid UUID of the application
	@param callId ID of the call
	@return ApiDeleteApplicationCallRequest
*/
func (a *ApplicationsAPIService) DeleteApplicationCall(ctx context.Context, applicationUuid string, callId string) ApiDeleteApplicationCallRequest {
	return ApiDeleteApplicationCallRequest{
		ApiService:      a,
		ctx:             ctx,
		applicationUuid: applicationUuid,
		callId:          callId,
	}
}

// Execute executes the request
func (a *ApplicationsAPIService) DeleteApplicationCallExecute(r ApiDeleteApplicationCallRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodDelete
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ApplicationsAPIService.DeleteApplicationCall")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/applications/{application_uuid}/calls/{call_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"application_uuid"+"}", url.PathEscape(parameterValueToString(r.applicationUuid, "applicationUuid")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"call_id"+"}", url.PathEscape(parameterValueToString(r.callId, "callId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["accent_auth_token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Auth-Token"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 503 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiDeleteApplicationCallFromNodeRequest struct {
	ctx             context.Context
	ApiService      ApplicationsAPI
	applicationUuid string
	nodeUuid        string
	callId          string
}

func (r ApiDeleteApplicationCallFromNodeRequest) Execute() (*http.Response, error) {
	return r.ApiService.DeleteApplicationCallFromNodeExecute(r)
}

/*
DeleteApplicationCallFromNode Remove call from the node

**Required ACL:** `calld.applications.{application_uuid}.nodes.{node_uuid}.calls.{call_id}.delete`

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param applicationUuid UUID of the application
	@param nodeUuid UUID of the node
	@param callId ID of the call
	@return ApiDeleteApplicationCallFromNodeRequest
*/
func (a *ApplicationsAPIService) DeleteApplicationCallFromNode(ctx context.Context, applicationUuid string, nodeUuid string, callId string) ApiDeleteApplicationCallFromNodeRequest {
	return ApiDeleteApplicationCallFromNodeRequest{
		ApiService:      a,
		ctx:             ctx,
		applicationUuid: applicationUuid,
		nodeUuid:        nodeUuid,
		callId:          callId,
	}
}

// Execute executes the request
func (a *ApplicationsAPIService) DeleteApplicationCallFromNodeExecute(r ApiDeleteApplicationCallFromNodeRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodDelete
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ApplicationsAPIService.DeleteApplicationCallFromNode")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/applications/{application_uuid}/nodes/{node_uuid}/calls/{call_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"application_uuid"+"}", url.PathEscape(parameterValueToString(r.applicationUuid, "applicationUuid")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"node_uuid"+"}", url.PathEscape(parameterValueToString(r.nodeUuid, "nodeUuid")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"call_id"+"}", url.PathEscape(parameterValueToString(r.callId, "callId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["accent_auth_token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Auth-Token"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 503 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiDeleteApplicationNodeRequest struct {
	ctx             context.Context
	ApiService      ApplicationsAPI
	applicationUuid string
	nodeUuid        string
}

func (r ApiDeleteApplicationNodeRequest) Execute() (*http.Response, error) {
	return r.ApiService.DeleteApplicationNodeExecute(r)
}

/*
DeleteApplicationNode Delete node and hangup all calls

**Required ACL:** `calld.applications.{application_uuid}.nodes.{node_uuid}.delete` **Not implemented**

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param applicationUuid UUID of the application
	@param nodeUuid UUID of the node
	@return ApiDeleteApplicationNodeRequest
*/
func (a *ApplicationsAPIService) DeleteApplicationNode(ctx context.Context, applicationUuid string, nodeUuid string) ApiDeleteApplicationNodeRequest {
	return ApiDeleteApplicationNodeRequest{
		ApiService:      a,
		ctx:             ctx,
		applicationUuid: applicationUuid,
		nodeUuid:        nodeUuid,
	}
}

// Execute executes the request
func (a *ApplicationsAPIService) DeleteApplicationNodeExecute(r ApiDeleteApplicationNodeRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodDelete
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ApplicationsAPIService.DeleteApplicationNode")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/applications/{application_uuid}/nodes/{node_uuid}"
	localVarPath = strings.Replace(localVarPath, "{"+"application_uuid"+"}", url.PathEscape(parameterValueToString(r.applicationUuid, "applicationUuid")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"node_uuid"+"}", url.PathEscape(parameterValueToString(r.nodeUuid, "nodeUuid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["accent_auth_token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Auth-Token"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 503 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiDeletePlaybackRequest struct {
	ctx             context.Context
	ApiService      ApplicationsAPI
	applicationUuid string
	playbackUuid    string
}

func (r ApiDeletePlaybackRequest) Execute() (*http.Response, error) {
	return r.ApiService.DeletePlaybackExecute(r)
}

/*
DeletePlayback Stop and remove playback

**Required ACL:** `calld.applications.{application_uuid}.playbacks.{playback_uuid}.delete`

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param applicationUuid UUID of the application
	@param playbackUuid ID of the playback
	@return ApiDeletePlaybackRequest
*/
func (a *ApplicationsAPIService) DeletePlayback(ctx context.Context, applicationUuid string, playbackUuid string) ApiDeletePlaybackRequest {
	return ApiDeletePlaybackRequest{
		ApiService:      a,
		ctx:             ctx,
		applicationUuid: applicationUuid,
		playbackUuid:    playbackUuid,
	}
}

// Execute executes the request
func (a *ApplicationsAPIService) DeletePlaybackExecute(r ApiDeletePlaybackRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodDelete
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ApplicationsAPIService.DeletePlayback")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/applications/{application_uuid}/playbacks/{playback_uuid}"
	localVarPath = strings.Replace(localVarPath, "{"+"application_uuid"+"}", url.PathEscape(parameterValueToString(r.applicationUuid, "applicationUuid")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"playback_uuid"+"}", url.PathEscape(parameterValueToString(r.playbackUuid, "playbackUuid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["accent_auth_token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Auth-Token"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 503 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiGetApplicationRequest struct {
	ctx             context.Context
	ApiService      ApplicationsAPI
	applicationUuid string
}

func (r ApiGetApplicationRequest) Execute() (*Application, *http.Response, error) {
	return r.ApiService.GetApplicationExecute(r)
}

/*
GetApplication Show an application

**Required ACL:** `calld.applications.{application_uuid}.read`

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param applicationUuid UUID of the application
	@return ApiGetApplicationRequest
*/
func (a *ApplicationsAPIService) GetApplication(ctx context.Context, applicationUuid string) ApiGetApplicationRequest {
	return ApiGetApplicationRequest{
		ApiService:      a,
		ctx:             ctx,
		applicationUuid: applicationUuid,
	}
}

// Execute executes the request
//
//	@return Application
func (a *ApplicationsAPIService) GetApplicationExecute(r ApiGetApplicationRequest) (*Application, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *Application
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ApplicationsAPIService.GetApplication")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/applications/{application_uuid}"
	localVarPath = strings.Replace(localVarPath, "{"+"application_uuid"+"}", url.PathEscape(parameterValueToString(r.applicationUuid, "applicationUuid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["accent_auth_token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Auth-Token"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 503 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetApplicationCallsRequest struct {
	ctx             context.Context
	ApiService      ApplicationsAPI
	applicationUuid string
}

func (r ApiGetApplicationCallsRequest) Execute() (*ApplicationCalls, *http.Response, error) {
	return r.ApiService.GetApplicationCallsExecute(r)
}

/*
GetApplicationCalls List calls from the application

**Required ACL:** `calld.applications.{application_uuid}.calls.read`

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param applicationUuid UUID of the application
	@return ApiGetApplicationCallsRequest
*/
func (a *ApplicationsAPIService) GetApplicationCalls(ctx context.Context, applicationUuid string) ApiGetApplicationCallsRequest {
	return ApiGetApplicationCallsRequest{
		ApiService:      a,
		ctx:             ctx,
		applicationUuid: applicationUuid,
	}
}

// Execute executes the request
//
//	@return ApplicationCalls
func (a *ApplicationsAPIService) GetApplicationCallsExecute(r ApiGetApplicationCallsRequest) (*ApplicationCalls, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *ApplicationCalls
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ApplicationsAPIService.GetApplicationCalls")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/applications/{application_uuid}/calls"
	localVarPath = strings.Replace(localVarPath, "{"+"application_uuid"+"}", url.PathEscape(parameterValueToString(r.applicationUuid, "applicationUuid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["accent_auth_token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Auth-Token"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 503 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetApplicationNodesRequest struct {
	ctx             context.Context
	ApiService      ApplicationsAPI
	applicationUuid string
}

func (r ApiGetApplicationNodesRequest) Execute() (*ApplicationNodes, *http.Response, error) {
	return r.ApiService.GetApplicationNodesExecute(r)
}

/*
GetApplicationNodes List nodes from the application

**Required ACL:** `calld.applications.{application_uuid}.nodes.read`

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param applicationUuid UUID of the application
	@return ApiGetApplicationNodesRequest
*/
func (a *ApplicationsAPIService) GetApplicationNodes(ctx context.Context, applicationUuid string) ApiGetApplicationNodesRequest {
	return ApiGetApplicationNodesRequest{
		ApiService:      a,
		ctx:             ctx,
		applicationUuid: applicationUuid,
	}
}

// Execute executes the request
//
//	@return ApplicationNodes
func (a *ApplicationsAPIService) GetApplicationNodesExecute(r ApiGetApplicationNodesRequest) (*ApplicationNodes, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *ApplicationNodes
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ApplicationsAPIService.GetApplicationNodes")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/applications/{application_uuid}/nodes"
	localVarPath = strings.Replace(localVarPath, "{"+"application_uuid"+"}", url.PathEscape(parameterValueToString(r.applicationUuid, "applicationUuid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["accent_auth_token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Auth-Token"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 503 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetNodeRequest struct {
	ctx             context.Context
	ApiService      ApplicationsAPI
	applicationUuid string
	nodeUuid        string
}

func (r ApiGetNodeRequest) Execute() (*ApplicationNode, *http.Response, error) {
	return r.ApiService.GetNodeExecute(r)
}

/*
GetNode Show a node

**Required ACL:** `calld.applications.{application_uuid}.nodes.{node_uuid}.read`

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param applicationUuid UUID of the application
	@param nodeUuid UUID of the node
	@return ApiGetNodeRequest
*/
func (a *ApplicationsAPIService) GetNode(ctx context.Context, applicationUuid string, nodeUuid string) ApiGetNodeRequest {
	return ApiGetNodeRequest{
		ApiService:      a,
		ctx:             ctx,
		applicationUuid: applicationUuid,
		nodeUuid:        nodeUuid,
	}
}

// Execute executes the request
//
//	@return ApplicationNode
func (a *ApplicationsAPIService) GetNodeExecute(r ApiGetNodeRequest) (*ApplicationNode, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *ApplicationNode
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ApplicationsAPIService.GetNode")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/applications/{application_uuid}/nodes/{node_uuid}"
	localVarPath = strings.Replace(localVarPath, "{"+"application_uuid"+"}", url.PathEscape(parameterValueToString(r.applicationUuid, "applicationUuid")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"node_uuid"+"}", url.PathEscape(parameterValueToString(r.nodeUuid, "nodeUuid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["accent_auth_token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Auth-Token"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 503 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetSnoopRequest struct {
	ctx             context.Context
	ApiService      ApplicationsAPI
	applicationUuid string
	snoopUuid       string
}

func (r ApiGetSnoopRequest) Execute() (*ApplicationSnoop, *http.Response, error) {
	return r.ApiService.GetSnoopExecute(r)
}

/*
GetSnoop View snooping parameters

**Required ACL:** `calld.applications.{application_uuid}.snoops.{snoop_uuid}.read`

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param applicationUuid UUID of the application
	@param snoopUuid UUID of the snoop
	@return ApiGetSnoopRequest
*/
func (a *ApplicationsAPIService) GetSnoop(ctx context.Context, applicationUuid string, snoopUuid string) ApiGetSnoopRequest {
	return ApiGetSnoopRequest{
		ApiService:      a,
		ctx:             ctx,
		applicationUuid: applicationUuid,
		snoopUuid:       snoopUuid,
	}
}

// Execute executes the request
//
//	@return ApplicationSnoop
func (a *ApplicationsAPIService) GetSnoopExecute(r ApiGetSnoopRequest) (*ApplicationSnoop, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *ApplicationSnoop
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ApplicationsAPIService.GetSnoop")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/applications/{application_uuid}/snoops/{snoop_uuid}"
	localVarPath = strings.Replace(localVarPath, "{"+"application_uuid"+"}", url.PathEscape(parameterValueToString(r.applicationUuid, "applicationUuid")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"snoop_uuid"+"}", url.PathEscape(parameterValueToString(r.snoopUuid, "snoopUuid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["accent_auth_token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Auth-Token"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 503 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiHoldApplicationCallRequest struct {
	ctx             context.Context
	ApiService      ApplicationsAPI
	applicationUuid string
	callId          string
}

func (r ApiHoldApplicationCallRequest) Execute() (*http.Response, error) {
	return r.ApiService.HoldApplicationCallExecute(r)
}

/*
HoldApplicationCall Place a call on hold

**Required ACL:** `calld.applications.{application_uuid}.calls.{call_id}.hold.start.update`

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param applicationUuid UUID of the application
	@param callId ID of the call
	@return ApiHoldApplicationCallRequest
*/
func (a *ApplicationsAPIService) HoldApplicationCall(ctx context.Context, applicationUuid string, callId string) ApiHoldApplicationCallRequest {
	return ApiHoldApplicationCallRequest{
		ApiService:      a,
		ctx:             ctx,
		applicationUuid: applicationUuid,
		callId:          callId,
	}
}

// Execute executes the request
func (a *ApplicationsAPIService) HoldApplicationCallExecute(r ApiHoldApplicationCallRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodPut
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ApplicationsAPIService.HoldApplicationCall")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/applications/{application_uuid}/calls/{call_id}/hold/start"
	localVarPath = strings.Replace(localVarPath, "{"+"application_uuid"+"}", url.PathEscape(parameterValueToString(r.applicationUuid, "applicationUuid")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"call_id"+"}", url.PathEscape(parameterValueToString(r.callId, "callId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["accent_auth_token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Auth-Token"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 503 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiInsertApplicationCallToNodeRequest struct {
	ctx             context.Context
	ApiService      ApplicationsAPI
	applicationUuid string
	nodeUuid        string
	callId          string
}

func (r ApiInsertApplicationCallToNodeRequest) Execute() (*http.Response, error) {
	return r.ApiService.InsertApplicationCallToNodeExecute(r)
}

/*
InsertApplicationCallToNode Insert call to the node

**Required ACL:** `calld.applications.{application_uuid}.nodes.{node_uuid}.calls.{call_id}.update`

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param applicationUuid UUID of the application
	@param nodeUuid UUID of the node
	@param callId ID of the call
	@return ApiInsertApplicationCallToNodeRequest
*/
func (a *ApplicationsAPIService) InsertApplicationCallToNode(ctx context.Context, applicationUuid string, nodeUuid string, callId string) ApiInsertApplicationCallToNodeRequest {
	return ApiInsertApplicationCallToNodeRequest{
		ApiService:      a,
		ctx:             ctx,
		applicationUuid: applicationUuid,
		nodeUuid:        nodeUuid,
		callId:          callId,
	}
}

// Execute executes the request
func (a *ApplicationsAPIService) InsertApplicationCallToNodeExecute(r ApiInsertApplicationCallToNodeRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodPut
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ApplicationsAPIService.InsertApplicationCallToNode")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/applications/{application_uuid}/nodes/{node_uuid}/calls/{call_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"application_uuid"+"}", url.PathEscape(parameterValueToString(r.applicationUuid, "applicationUuid")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"node_uuid"+"}", url.PathEscape(parameterValueToString(r.nodeUuid, "nodeUuid")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"call_id"+"}", url.PathEscape(parameterValueToString(r.callId, "callId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["accent_auth_token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Auth-Token"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 503 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiListApplicationSnoopsRequest struct {
	ctx             context.Context
	ApiService      ApplicationsAPI
	applicationUuid string
}

func (r ApiListApplicationSnoopsRequest) Execute() (*ApplicationSnoops, *http.Response, error) {
	return r.ApiService.ListApplicationSnoopsExecute(r)
}

/*
ListApplicationSnoops List active snoops

**Required ACL:** `calld.applications.{application_uuid}.snoops.read`

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param applicationUuid UUID of the application
	@return ApiListApplicationSnoopsRequest
*/
func (a *ApplicationsAPIService) ListApplicationSnoops(ctx context.Context, applicationUuid string) ApiListApplicationSnoopsRequest {
	return ApiListApplicationSnoopsRequest{
		ApiService:      a,
		ctx:             ctx,
		applicationUuid: applicationUuid,
	}
}

// Execute executes the request
//
//	@return ApplicationSnoops
func (a *ApplicationsAPIService) ListApplicationSnoopsExecute(r ApiListApplicationSnoopsRequest) (*ApplicationSnoops, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *ApplicationSnoops
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ApplicationsAPIService.ListApplicationSnoops")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/applications/{application_uuid}/snoops"
	localVarPath = strings.Replace(localVarPath, "{"+"application_uuid"+"}", url.PathEscape(parameterValueToString(r.applicationUuid, "applicationUuid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["accent_auth_token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Auth-Token"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 503 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiMuteApplicationCallRequest struct {
	ctx             context.Context
	ApiService      ApplicationsAPI
	applicationUuid string
	callId          string
}

func (r ApiMuteApplicationCallRequest) Execute() (*http.Response, error) {
	return r.ApiService.MuteApplicationCallExecute(r)
}

/*
MuteApplicationCall Mute a call

**Required ACL:** `calld.applications.{application_uuid}.calls.{call_id}.mute.start.update`

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param applicationUuid UUID of the application
	@param callId ID of the call
	@return ApiMuteApplicationCallRequest
*/
func (a *ApplicationsAPIService) MuteApplicationCall(ctx context.Context, applicationUuid string, callId string) ApiMuteApplicationCallRequest {
	return ApiMuteApplicationCallRequest{
		ApiService:      a,
		ctx:             ctx,
		applicationUuid: applicationUuid,
		callId:          callId,
	}
}

// Execute executes the request
func (a *ApplicationsAPIService) MuteApplicationCallExecute(r ApiMuteApplicationCallRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodPut
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ApplicationsAPIService.MuteApplicationCall")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/applications/{application_uuid}/calls/{call_id}/mute/start"
	localVarPath = strings.Replace(localVarPath, "{"+"application_uuid"+"}", url.PathEscape(parameterValueToString(r.applicationUuid, "applicationUuid")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"call_id"+"}", url.PathEscape(parameterValueToString(r.callId, "callId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["accent_auth_token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Auth-Token"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 503 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiPlayApplicationCallRequest struct {
	ctx             context.Context
	ApiService      ApplicationsAPI
	body            *ApplicationPlayback
	applicationUuid string
	callId          string
}

// playback parameters
func (r ApiPlayApplicationCallRequest) Body(body ApplicationPlayback) ApiPlayApplicationCallRequest {
	r.body = &body
	return r
}

func (r ApiPlayApplicationCallRequest) Execute() (*ApplicationPlayback, *http.Response, error) {
	return r.ApiService.PlayApplicationCallExecute(r)
}

/*
PlayApplicationCall Play file to the call

**Required ACL:** `calld.applications.{application_uuid}.calls.{call_id}.playbacks.create`
URI examples: * sound:tt-weasels * digits:4188001234 * number:321 * characters:abc * tone:ring * recording:my-recording

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param applicationUuid UUID of the application
	@param callId ID of the call
	@return ApiPlayApplicationCallRequest
*/
func (a *ApplicationsAPIService) PlayApplicationCall(ctx context.Context, applicationUuid string, callId string) ApiPlayApplicationCallRequest {
	return ApiPlayApplicationCallRequest{
		ApiService:      a,
		ctx:             ctx,
		applicationUuid: applicationUuid,
		callId:          callId,
	}
}

// Execute executes the request
//
//	@return ApplicationPlayback
func (a *ApplicationsAPIService) PlayApplicationCallExecute(r ApiPlayApplicationCallRequest) (*ApplicationPlayback, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *ApplicationPlayback
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ApplicationsAPIService.PlayApplicationCall")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/applications/{application_uuid}/calls/{call_id}/playbacks"
	localVarPath = strings.Replace(localVarPath, "{"+"application_uuid"+"}", url.PathEscape(parameterValueToString(r.applicationUuid, "applicationUuid")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"call_id"+"}", url.PathEscape(parameterValueToString(r.callId, "callId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("body is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["accent_auth_token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Auth-Token"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 503 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiResumeApplicationCallRequest struct {
	ctx             context.Context
	ApiService      ApplicationsAPI
	applicationUuid string
	callId          string
}

func (r ApiResumeApplicationCallRequest) Execute() (*http.Response, error) {
	return r.ApiService.ResumeApplicationCallExecute(r)
}

/*
ResumeApplicationCall Resume a call that has been placed on hold

**Required ACL:** `calld.applications.{application_uuid}.calls.{call_id}.hold.stop.update

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param applicationUuid UUID of the application
	@param callId ID of the call
	@return ApiResumeApplicationCallRequest
*/
func (a *ApplicationsAPIService) ResumeApplicationCall(ctx context.Context, applicationUuid string, callId string) ApiResumeApplicationCallRequest {
	return ApiResumeApplicationCallRequest{
		ApiService:      a,
		ctx:             ctx,
		applicationUuid: applicationUuid,
		callId:          callId,
	}
}

// Execute executes the request
func (a *ApplicationsAPIService) ResumeApplicationCallExecute(r ApiResumeApplicationCallRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodPut
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ApplicationsAPIService.ResumeApplicationCall")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/applications/{application_uuid}/calls/{call_id}/hold/stop"
	localVarPath = strings.Replace(localVarPath, "{"+"application_uuid"+"}", url.PathEscape(parameterValueToString(r.applicationUuid, "applicationUuid")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"call_id"+"}", url.PathEscape(parameterValueToString(r.callId, "callId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["accent_auth_token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Auth-Token"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 503 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiSendApplicationCallDTMFRequest struct {
	ctx             context.Context
	ApiService      ApplicationsAPI
	applicationUuid string
	callId          string
	digits          *string
}

// Digits to send via DTMF. Must contain only &#x60;0-9*#&#x60;.
func (r ApiSendApplicationCallDTMFRequest) Digits(digits string) ApiSendApplicationCallDTMFRequest {
	r.digits = &digits
	return r
}

func (r ApiSendApplicationCallDTMFRequest) Execute() (*http.Response, error) {
	return r.ApiService.SendApplicationCallDTMFExecute(r)
}

/*
SendApplicationCallDTMF Simulate a user pressing DTMF keys

**Required ACL:** `calld.applications.{application_uuid}.calls.{call_id}.dtmf.update

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param applicationUuid UUID of the application
	@param callId ID of the call
	@return ApiSendApplicationCallDTMFRequest
*/
func (a *ApplicationsAPIService) SendApplicationCallDTMF(ctx context.Context, applicationUuid string, callId string) ApiSendApplicationCallDTMFRequest {
	return ApiSendApplicationCallDTMFRequest{
		ApiService:      a,
		ctx:             ctx,
		applicationUuid: applicationUuid,
		callId:          callId,
	}
}

// Execute executes the request
func (a *ApplicationsAPIService) SendApplicationCallDTMFExecute(r ApiSendApplicationCallDTMFRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodPut
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ApplicationsAPIService.SendApplicationCallDTMF")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/applications/{application_uuid}/calls/{call_id}/dtmf"
	localVarPath = strings.Replace(localVarPath, "{"+"application_uuid"+"}", url.PathEscape(parameterValueToString(r.applicationUuid, "applicationUuid")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"call_id"+"}", url.PathEscape(parameterValueToString(r.callId, "callId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.digits == nil {
		return nil, reportError("digits is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "digits", r.digits, "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["accent_auth_token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Auth-Token"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 503 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiSnoopApplicationCallRequest struct {
	ctx             context.Context
	ApiService      ApplicationsAPI
	body            *ApplicationSnoop
	applicationUuid string
	callId          string
}

// snoop parameters
func (r ApiSnoopApplicationCallRequest) Body(body ApplicationSnoop) ApiSnoopApplicationCallRequest {
	r.body = &body
	return r
}

func (r ApiSnoopApplicationCallRequest) Execute() (*ApplicationSnoop, *http.Response, error) {
	return r.ApiService.SnoopApplicationCallExecute(r)
}

/*
SnoopApplicationCall Start snooping on a call

**Required ACL:** `calld.applications.{application_uuid}.calls.{call_id}.snoops.create`
The whisper mode indicate which part of the snooped channel can hear the snooper. Given Alice calls Bob and Charles snoops on Bob * none: No one can hear the snooper * both: Alice and Bob can hear Charles * in: Alice can hear Charles * out: Bob can hear Charles

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param applicationUuid UUID of the application
	@param callId ID of the call
	@return ApiSnoopApplicationCallRequest
*/
func (a *ApplicationsAPIService) SnoopApplicationCall(ctx context.Context, applicationUuid string, callId string) ApiSnoopApplicationCallRequest {
	return ApiSnoopApplicationCallRequest{
		ApiService:      a,
		ctx:             ctx,
		applicationUuid: applicationUuid,
		callId:          callId,
	}
}

// Execute executes the request
//
//	@return ApplicationSnoop
func (a *ApplicationsAPIService) SnoopApplicationCallExecute(r ApiSnoopApplicationCallRequest) (*ApplicationSnoop, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *ApplicationSnoop
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ApplicationsAPIService.SnoopApplicationCall")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/applications/{application_uuid}/calls/{call_id}/snoops"
	localVarPath = strings.Replace(localVarPath, "{"+"application_uuid"+"}", url.PathEscape(parameterValueToString(r.applicationUuid, "applicationUuid")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"call_id"+"}", url.PathEscape(parameterValueToString(r.callId, "callId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("body is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["accent_auth_token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Auth-Token"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 503 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiStartApplicationCallMOHRequest struct {
	ctx             context.Context
	ApiService      ApplicationsAPI
	applicationUuid string
	callId          string
	mohUuid         string
}

func (r ApiStartApplicationCallMOHRequest) Execute() (*http.Response, error) {
	return r.ApiService.StartApplicationCallMOHExecute(r)
}

/*
StartApplicationCallMOH Starts playing a music on hold

**Required ACL:** `calld.applications.{application_uuid}.calls.{call_id}.moh.{moh_uuid}.start.update`
Starts playing a music on hold on a call. If the music on hold is interrupted for a playback or another
action, the music on hold will not restart automatically after the interruption.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param applicationUuid UUID of the application
	@param callId ID of the call
	@param mohUuid UUID of the music on hold
	@return ApiStartApplicationCallMOHRequest
*/
func (a *ApplicationsAPIService) StartApplicationCallMOH(ctx context.Context, applicationUuid string, callId string, mohUuid string) ApiStartApplicationCallMOHRequest {
	return ApiStartApplicationCallMOHRequest{
		ApiService:      a,
		ctx:             ctx,
		applicationUuid: applicationUuid,
		callId:          callId,
		mohUuid:         mohUuid,
	}
}

// Execute executes the request
func (a *ApplicationsAPIService) StartApplicationCallMOHExecute(r ApiStartApplicationCallMOHRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodPut
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ApplicationsAPIService.StartApplicationCallMOH")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/applications/{application_uuid}/calls/{call_id}/moh/{moh_uuid}/start"
	localVarPath = strings.Replace(localVarPath, "{"+"application_uuid"+"}", url.PathEscape(parameterValueToString(r.applicationUuid, "applicationUuid")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"call_id"+"}", url.PathEscape(parameterValueToString(r.callId, "callId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"moh_uuid"+"}", url.PathEscape(parameterValueToString(r.mohUuid, "mohUuid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["accent_auth_token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Auth-Token"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 503 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiStartApplicationCallProgressRequest struct {
	ctx             context.Context
	ApiService      ApplicationsAPI
	applicationUuid string
	callId          string
}

func (r ApiStartApplicationCallProgressRequest) Execute() (*http.Response, error) {
	return r.ApiService.StartApplicationCallProgressExecute(r)
}

/*
StartApplicationCallProgress Play the progress ringing tone

**Required ACL:** `calld.applications.{application_uuid}.calls.{call_id}.progress.start.update` The progress ringing tone is the sound heard by a caller while the other party is ringing.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param applicationUuid UUID of the application
	@param callId ID of the call
	@return ApiStartApplicationCallProgressRequest
*/
func (a *ApplicationsAPIService) StartApplicationCallProgress(ctx context.Context, applicationUuid string, callId string) ApiStartApplicationCallProgressRequest {
	return ApiStartApplicationCallProgressRequest{
		ApiService:      a,
		ctx:             ctx,
		applicationUuid: applicationUuid,
		callId:          callId,
	}
}

// Execute executes the request
func (a *ApplicationsAPIService) StartApplicationCallProgressExecute(r ApiStartApplicationCallProgressRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodPut
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ApplicationsAPIService.StartApplicationCallProgress")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/applications/{application_uuid}/calls/{call_id}/progress/start"
	localVarPath = strings.Replace(localVarPath, "{"+"application_uuid"+"}", url.PathEscape(parameterValueToString(r.applicationUuid, "applicationUuid")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"call_id"+"}", url.PathEscape(parameterValueToString(r.callId, "callId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["accent_auth_token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Auth-Token"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 503 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiStopApplicationCallMOHRequest struct {
	ctx             context.Context
	ApiService      ApplicationsAPI
	applicationUuid string
	callId          string
}

func (r ApiStopApplicationCallMOHRequest) Execute() (*http.Response, error) {
	return r.ApiService.StopApplicationCallMOHExecute(r)
}

/*
StopApplicationCallMOH Stops playing a music on hold

**Required ACL:** `calld.applications.{application_uuid}.calls.{call_id}.moh.{moh_uuid}.stop.update

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param applicationUuid UUID of the application
	@param callId ID of the call
	@return ApiStopApplicationCallMOHRequest
*/
func (a *ApplicationsAPIService) StopApplicationCallMOH(ctx context.Context, applicationUuid string, callId string) ApiStopApplicationCallMOHRequest {
	return ApiStopApplicationCallMOHRequest{
		ApiService:      a,
		ctx:             ctx,
		applicationUuid: applicationUuid,
		callId:          callId,
	}
}

// Execute executes the request
func (a *ApplicationsAPIService) StopApplicationCallMOHExecute(r ApiStopApplicationCallMOHRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodPut
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ApplicationsAPIService.StopApplicationCallMOH")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/applications/{application_uuid}/calls/{call_id}/moh/stop"
	localVarPath = strings.Replace(localVarPath, "{"+"application_uuid"+"}", url.PathEscape(parameterValueToString(r.applicationUuid, "applicationUuid")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"call_id"+"}", url.PathEscape(parameterValueToString(r.callId, "callId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["accent_auth_token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Auth-Token"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 503 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiStopApplicationCallProgressRequest struct {
	ctx             context.Context
	ApiService      ApplicationsAPI
	applicationUuid string
	callId          string
}

func (r ApiStopApplicationCallProgressRequest) Execute() (*http.Response, error) {
	return r.ApiService.StopApplicationCallProgressExecute(r)
}

/*
StopApplicationCallProgress Stop playing the progress ringing tone.

**Required ACL:** `calld.applications.{application_uuid}.calls.{call_id}.progress.stop.update` The progress ringing tone is the sound heard by a caller while the other party is ringing. Limitation: this only works when the ringing tone is played by Accent through audio media (e.g. when using `/progress` after `/answer`). If the phone is emitting the ringing tone directly to the user, then it cannot be stopped, and the response code will still be 204.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param applicationUuid UUID of the application
	@param callId ID of the call
	@return ApiStopApplicationCallProgressRequest
*/
func (a *ApplicationsAPIService) StopApplicationCallProgress(ctx context.Context, applicationUuid string, callId string) ApiStopApplicationCallProgressRequest {
	return ApiStopApplicationCallProgressRequest{
		ApiService:      a,
		ctx:             ctx,
		applicationUuid: applicationUuid,
		callId:          callId,
	}
}

// Execute executes the request
func (a *ApplicationsAPIService) StopApplicationCallProgressExecute(r ApiStopApplicationCallProgressRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodPut
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ApplicationsAPIService.StopApplicationCallProgress")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/applications/{application_uuid}/calls/{call_id}/progress/stop"
	localVarPath = strings.Replace(localVarPath, "{"+"application_uuid"+"}", url.PathEscape(parameterValueToString(r.applicationUuid, "applicationUuid")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"call_id"+"}", url.PathEscape(parameterValueToString(r.callId, "callId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["accent_auth_token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Auth-Token"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 503 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiStopSnoopRequest struct {
	ctx             context.Context
	ApiService      ApplicationsAPI
	applicationUuid string
	snoopUuid       string
}

func (r ApiStopSnoopRequest) Execute() (*http.Response, error) {
	return r.ApiService.StopSnoopExecute(r)
}

/*
StopSnoop Stop snooping

**Required ACL:** `calld.applications.{application_uuid}.snoops.{snoop_uuid}.delete`

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param applicationUuid UUID of the application
	@param snoopUuid UUID of the snoop
	@return ApiStopSnoopRequest
*/
func (a *ApplicationsAPIService) StopSnoop(ctx context.Context, applicationUuid string, snoopUuid string) ApiStopSnoopRequest {
	return ApiStopSnoopRequest{
		ApiService:      a,
		ctx:             ctx,
		applicationUuid: applicationUuid,
		snoopUuid:       snoopUuid,
	}
}

// Execute executes the request
func (a *ApplicationsAPIService) StopSnoopExecute(r ApiStopSnoopRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodDelete
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ApplicationsAPIService.StopSnoop")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/applications/{application_uuid}/snoops/{snoop_uuid}"
	localVarPath = strings.Replace(localVarPath, "{"+"application_uuid"+"}", url.PathEscape(parameterValueToString(r.applicationUuid, "applicationUuid")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"snoop_uuid"+"}", url.PathEscape(parameterValueToString(r.snoopUuid, "snoopUuid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["accent_auth_token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Auth-Token"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 503 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiUnmuteApplicationCallRequest struct {
	ctx             context.Context
	ApiService      ApplicationsAPI
	applicationUuid string
	callId          string
}

func (r ApiUnmuteApplicationCallRequest) Execute() (*http.Response, error) {
	return r.ApiService.UnmuteApplicationCallExecute(r)
}

/*
UnmuteApplicationCall Unmute a call

**Required ACL:** `calld.applications.{application_uuid}.calls.{call_id}.mute.stop.update`

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param applicationUuid UUID of the application
	@param callId ID of the call
	@return ApiUnmuteApplicationCallRequest
*/
func (a *ApplicationsAPIService) UnmuteApplicationCall(ctx context.Context, applicationUuid string, callId string) ApiUnmuteApplicationCallRequest {
	return ApiUnmuteApplicationCallRequest{
		ApiService:      a,
		ctx:             ctx,
		applicationUuid: applicationUuid,
		callId:          callId,
	}
}

// Execute executes the request
func (a *ApplicationsAPIService) UnmuteApplicationCallExecute(r ApiUnmuteApplicationCallRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodPut
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ApplicationsAPIService.UnmuteApplicationCall")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/applications/{application_uuid}/calls/{call_id}/mute/stop"
	localVarPath = strings.Replace(localVarPath, "{"+"application_uuid"+"}", url.PathEscape(parameterValueToString(r.applicationUuid, "applicationUuid")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"call_id"+"}", url.PathEscape(parameterValueToString(r.callId, "callId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["accent_auth_token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Auth-Token"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 503 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiUpdateSnoopRequest struct {
	ctx             context.Context
	ApiService      ApplicationsAPI
	body            *ApplicationSnoopPut
	applicationUuid string
	snoopUuid       string
}

// snoop parameters
func (r ApiUpdateSnoopRequest) Body(body ApplicationSnoopPut) ApiUpdateSnoopRequest {
	r.body = &body
	return r
}

func (r ApiUpdateSnoopRequest) Execute() (*http.Response, error) {
	return r.ApiService.UpdateSnoopExecute(r)
}

/*
UpdateSnoop Change snooping parameters

**Required ACL:** `calld.applications.{application_uuid}.snoops.{snoop_uuid}.update`

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param applicationUuid UUID of the application
	@param snoopUuid UUID of the snoop
	@return ApiUpdateSnoopRequest
*/
func (a *ApplicationsAPIService) UpdateSnoop(ctx context.Context, applicationUuid string, snoopUuid string) ApiUpdateSnoopRequest {
	return ApiUpdateSnoopRequest{
		ApiService:      a,
		ctx:             ctx,
		applicationUuid: applicationUuid,
		snoopUuid:       snoopUuid,
	}
}

// Execute executes the request
func (a *ApplicationsAPIService) UpdateSnoopExecute(r ApiUpdateSnoopRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodPut
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ApplicationsAPIService.UpdateSnoop")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/applications/{application_uuid}/snoops/{snoop_uuid}"
	localVarPath = strings.Replace(localVarPath, "{"+"application_uuid"+"}", url.PathEscape(parameterValueToString(r.applicationUuid, "applicationUuid")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"snoop_uuid"+"}", url.PathEscape(parameterValueToString(r.snoopUuid, "snoopUuid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return nil, reportError("body is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["accent_auth_token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Auth-Token"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 503 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

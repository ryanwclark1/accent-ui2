/*
accent-calld

Control your calls from a REST API

API version: 1.0.0
Contact: help@accentvoice.io
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package calld

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"strings"
)

type SwitchboardsAPI interface {

	/*
		AnswerHeldCall Answer the specified held call

		 **Required ACL:** `calld.switchboards.{switchboard_uuid}.calls.held.{call_id}.answer.update`

	 **Warning:** This endpoint is still in development and may change in the future.

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param switchboardUuid Unique identifier of the switchboard
		@param callId ID of the call
		@return ApiAnswerHeldCallRequest
	*/
	AnswerHeldCall(ctx context.Context, switchboardUuid string, callId string) ApiAnswerHeldCallRequest

	// AnswerHeldCallExecute executes the request
	//  @return CallID
	AnswerHeldCallExecute(r ApiAnswerHeldCallRequest) (*CallID, *http.Response, error)

	/*
		AnswerQueuedCall Answer the specified queued call

		 **Required ACL:** `calld.switchboards.{switchboard_uuid}.calls.queued.{call_id}.answer.update`

	 **Warning:** This endpoint is still in development and may change in the future.

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param switchboardUuid Unique identifier of the switchboard
		@param callId ID of the call
		@return ApiAnswerQueuedCallRequest
	*/
	AnswerQueuedCall(ctx context.Context, switchboardUuid string, callId string) ApiAnswerQueuedCallRequest

	// AnswerQueuedCallExecute executes the request
	//  @return CallID
	AnswerQueuedCallExecute(r ApiAnswerQueuedCallRequest) (*CallID, *http.Response, error)

	/*
		HoldSwitchboardCall Put the specified call on hold in the switchboard

		 **Required ACL:** `calld.switchboards.{switchboard_uuid}.calls.held.{call_id}.update`

	 **Warning:** This endpoint is still in development and may change in the future.

	 This action will also hangup the previous call talking to the held call, if there was any.

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param switchboardUuid Unique identifier of the switchboard
		@param callId ID of the call
		@return ApiHoldSwitchboardCallRequest
	*/
	HoldSwitchboardCall(ctx context.Context, switchboardUuid string, callId string) ApiHoldSwitchboardCallRequest

	// HoldSwitchboardCallExecute executes the request
	HoldSwitchboardCallExecute(r ApiHoldSwitchboardCallRequest) (*http.Response, error)

	/*
		ListSwitchboardHeldCalls List calls held in the switchboard

		 **Required ACL:** `calld.switchboards.{switchboard_uuid}.calls.held.read`

	 **Warning:** This endpoint is still in development and may change in the future.

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param switchboardUuid Unique identifier of the switchboard
		@return ApiListSwitchboardHeldCallsRequest
	*/
	ListSwitchboardHeldCalls(ctx context.Context, switchboardUuid string) ApiListSwitchboardHeldCallsRequest

	// ListSwitchboardHeldCallsExecute executes the request
	//  @return SwitchboardHeldCalls
	ListSwitchboardHeldCallsExecute(r ApiListSwitchboardHeldCallsRequest) (*SwitchboardHeldCalls, *http.Response, error)

	/*
		ListSwitchboardQueuedCalls List calls queued in the switchboard

		 **Required ACL:** `calld.switchboards.{switchboard_uuid}.calls.queued.read`

	 **Warning:** This endpoint is still in development and may change in the future.

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param switchboardUuid Unique identifier of the switchboard
		@return ApiListSwitchboardQueuedCallsRequest
	*/
	ListSwitchboardQueuedCalls(ctx context.Context, switchboardUuid string) ApiListSwitchboardQueuedCallsRequest

	// ListSwitchboardQueuedCallsExecute executes the request
	//  @return SwitchboardQueuedCalls
	ListSwitchboardQueuedCallsExecute(r ApiListSwitchboardQueuedCallsRequest) (*SwitchboardQueuedCalls, *http.Response, error)
}

// SwitchboardsAPIService SwitchboardsAPI service
type SwitchboardsAPIService service

type ApiAnswerHeldCallRequest struct {
	ctx             context.Context
	ApiService      SwitchboardsAPI
	switchboardUuid string
	callId          string
	accentTenant    *string
	lineId          *int32
}

// The tenant&#39;s UUID, defining the ownership of a given resource.
func (r ApiAnswerHeldCallRequest) AccentTenant(accentTenant string) ApiAnswerHeldCallRequest {
	r.accentTenant = &accentTenant
	return r
}

// ID of the line of the user used to make the call. Default is the main line of the user.
func (r ApiAnswerHeldCallRequest) LineId(lineId int32) ApiAnswerHeldCallRequest {
	r.lineId = &lineId
	return r
}

func (r ApiAnswerHeldCallRequest) Execute() (*CallID, *http.Response, error) {
	return r.ApiService.AnswerHeldCallExecute(r)
}

/*
AnswerHeldCall Answer the specified held call

	**Required ACL:** `calld.switchboards.{switchboard_uuid}.calls.held.{call_id}.answer.update`

	**Warning:** This endpoint is still in development and may change in the future.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param switchboardUuid Unique identifier of the switchboard
	@param callId ID of the call
	@return ApiAnswerHeldCallRequest
*/
func (a *SwitchboardsAPIService) AnswerHeldCall(ctx context.Context, switchboardUuid string, callId string) ApiAnswerHeldCallRequest {
	return ApiAnswerHeldCallRequest{
		ApiService:      a,
		ctx:             ctx,
		switchboardUuid: switchboardUuid,
		callId:          callId,
	}
}

// Execute executes the request
//
//	@return CallID
func (a *SwitchboardsAPIService) AnswerHeldCallExecute(r ApiAnswerHeldCallRequest) (*CallID, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPut
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *CallID
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SwitchboardsAPIService.AnswerHeldCall")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/switchboards/{switchboard_uuid}/calls/held/{call_id}/answer"
	localVarPath = strings.Replace(localVarPath, "{"+"switchboard_uuid"+"}", url.PathEscape(parameterValueToString(r.switchboardUuid, "switchboardUuid")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"call_id"+"}", url.PathEscape(parameterValueToString(r.callId, "callId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.lineId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "line_id", r.lineId, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.accentTenant != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accent-Tenant", r.accentTenant, "")
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["accent_auth_token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Auth-Token"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 503 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiAnswerQueuedCallRequest struct {
	ctx             context.Context
	ApiService      SwitchboardsAPI
	switchboardUuid string
	callId          string
	accentTenant    *string
	lineId          *int32
}

// The tenant&#39;s UUID, defining the ownership of a given resource.
func (r ApiAnswerQueuedCallRequest) AccentTenant(accentTenant string) ApiAnswerQueuedCallRequest {
	r.accentTenant = &accentTenant
	return r
}

// ID of the line of the user used to make the call. Default is the main line of the user.
func (r ApiAnswerQueuedCallRequest) LineId(lineId int32) ApiAnswerQueuedCallRequest {
	r.lineId = &lineId
	return r
}

func (r ApiAnswerQueuedCallRequest) Execute() (*CallID, *http.Response, error) {
	return r.ApiService.AnswerQueuedCallExecute(r)
}

/*
AnswerQueuedCall Answer the specified queued call

	**Required ACL:** `calld.switchboards.{switchboard_uuid}.calls.queued.{call_id}.answer.update`

	**Warning:** This endpoint is still in development and may change in the future.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param switchboardUuid Unique identifier of the switchboard
	@param callId ID of the call
	@return ApiAnswerQueuedCallRequest
*/
func (a *SwitchboardsAPIService) AnswerQueuedCall(ctx context.Context, switchboardUuid string, callId string) ApiAnswerQueuedCallRequest {
	return ApiAnswerQueuedCallRequest{
		ApiService:      a,
		ctx:             ctx,
		switchboardUuid: switchboardUuid,
		callId:          callId,
	}
}

// Execute executes the request
//
//	@return CallID
func (a *SwitchboardsAPIService) AnswerQueuedCallExecute(r ApiAnswerQueuedCallRequest) (*CallID, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPut
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *CallID
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SwitchboardsAPIService.AnswerQueuedCall")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/switchboards/{switchboard_uuid}/calls/queued/{call_id}/answer"
	localVarPath = strings.Replace(localVarPath, "{"+"switchboard_uuid"+"}", url.PathEscape(parameterValueToString(r.switchboardUuid, "switchboardUuid")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"call_id"+"}", url.PathEscape(parameterValueToString(r.callId, "callId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.lineId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "line_id", r.lineId, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.accentTenant != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accent-Tenant", r.accentTenant, "")
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["accent_auth_token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Auth-Token"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 503 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiHoldSwitchboardCallRequest struct {
	ctx             context.Context
	ApiService      SwitchboardsAPI
	switchboardUuid string
	callId          string
	accentTenant    *string
}

// The tenant&#39;s UUID, defining the ownership of a given resource.
func (r ApiHoldSwitchboardCallRequest) AccentTenant(accentTenant string) ApiHoldSwitchboardCallRequest {
	r.accentTenant = &accentTenant
	return r
}

func (r ApiHoldSwitchboardCallRequest) Execute() (*http.Response, error) {
	return r.ApiService.HoldSwitchboardCallExecute(r)
}

/*
HoldSwitchboardCall Put the specified call on hold in the switchboard

	**Required ACL:** `calld.switchboards.{switchboard_uuid}.calls.held.{call_id}.update`

	**Warning:** This endpoint is still in development and may change in the future.

	This action will also hangup the previous call talking to the held call, if there was any.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param switchboardUuid Unique identifier of the switchboard
	@param callId ID of the call
	@return ApiHoldSwitchboardCallRequest
*/
func (a *SwitchboardsAPIService) HoldSwitchboardCall(ctx context.Context, switchboardUuid string, callId string) ApiHoldSwitchboardCallRequest {
	return ApiHoldSwitchboardCallRequest{
		ApiService:      a,
		ctx:             ctx,
		switchboardUuid: switchboardUuid,
		callId:          callId,
	}
}

// Execute executes the request
func (a *SwitchboardsAPIService) HoldSwitchboardCallExecute(r ApiHoldSwitchboardCallRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodPut
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SwitchboardsAPIService.HoldSwitchboardCall")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/switchboards/{switchboard_uuid}/calls/held/{call_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"switchboard_uuid"+"}", url.PathEscape(parameterValueToString(r.switchboardUuid, "switchboardUuid")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"call_id"+"}", url.PathEscape(parameterValueToString(r.callId, "callId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.accentTenant != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accent-Tenant", r.accentTenant, "")
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["accent_auth_token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Auth-Token"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 503 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiListSwitchboardHeldCallsRequest struct {
	ctx             context.Context
	ApiService      SwitchboardsAPI
	switchboardUuid string
	accentTenant    *string
}

// The tenant&#39;s UUID, defining the ownership of a given resource.
func (r ApiListSwitchboardHeldCallsRequest) AccentTenant(accentTenant string) ApiListSwitchboardHeldCallsRequest {
	r.accentTenant = &accentTenant
	return r
}

func (r ApiListSwitchboardHeldCallsRequest) Execute() (*SwitchboardHeldCalls, *http.Response, error) {
	return r.ApiService.ListSwitchboardHeldCallsExecute(r)
}

/*
ListSwitchboardHeldCalls List calls held in the switchboard

	**Required ACL:** `calld.switchboards.{switchboard_uuid}.calls.held.read`

	**Warning:** This endpoint is still in development and may change in the future.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param switchboardUuid Unique identifier of the switchboard
	@return ApiListSwitchboardHeldCallsRequest
*/
func (a *SwitchboardsAPIService) ListSwitchboardHeldCalls(ctx context.Context, switchboardUuid string) ApiListSwitchboardHeldCallsRequest {
	return ApiListSwitchboardHeldCallsRequest{
		ApiService:      a,
		ctx:             ctx,
		switchboardUuid: switchboardUuid,
	}
}

// Execute executes the request
//
//	@return SwitchboardHeldCalls
func (a *SwitchboardsAPIService) ListSwitchboardHeldCallsExecute(r ApiListSwitchboardHeldCallsRequest) (*SwitchboardHeldCalls, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *SwitchboardHeldCalls
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SwitchboardsAPIService.ListSwitchboardHeldCalls")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/switchboards/{switchboard_uuid}/calls/held"
	localVarPath = strings.Replace(localVarPath, "{"+"switchboard_uuid"+"}", url.PathEscape(parameterValueToString(r.switchboardUuid, "switchboardUuid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.accentTenant != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accent-Tenant", r.accentTenant, "")
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["accent_auth_token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Auth-Token"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 503 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiListSwitchboardQueuedCallsRequest struct {
	ctx             context.Context
	ApiService      SwitchboardsAPI
	switchboardUuid string
	accentTenant    *string
}

// The tenant&#39;s UUID, defining the ownership of a given resource.
func (r ApiListSwitchboardQueuedCallsRequest) AccentTenant(accentTenant string) ApiListSwitchboardQueuedCallsRequest {
	r.accentTenant = &accentTenant
	return r
}

func (r ApiListSwitchboardQueuedCallsRequest) Execute() (*SwitchboardQueuedCalls, *http.Response, error) {
	return r.ApiService.ListSwitchboardQueuedCallsExecute(r)
}

/*
ListSwitchboardQueuedCalls List calls queued in the switchboard

	**Required ACL:** `calld.switchboards.{switchboard_uuid}.calls.queued.read`

	**Warning:** This endpoint is still in development and may change in the future.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param switchboardUuid Unique identifier of the switchboard
	@return ApiListSwitchboardQueuedCallsRequest
*/
func (a *SwitchboardsAPIService) ListSwitchboardQueuedCalls(ctx context.Context, switchboardUuid string) ApiListSwitchboardQueuedCallsRequest {
	return ApiListSwitchboardQueuedCallsRequest{
		ApiService:      a,
		ctx:             ctx,
		switchboardUuid: switchboardUuid,
	}
}

// Execute executes the request
//
//	@return SwitchboardQueuedCalls
func (a *SwitchboardsAPIService) ListSwitchboardQueuedCallsExecute(r ApiListSwitchboardQueuedCallsRequest) (*SwitchboardQueuedCalls, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *SwitchboardQueuedCalls
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SwitchboardsAPIService.ListSwitchboardQueuedCalls")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/switchboards/{switchboard_uuid}/calls/queued"
	localVarPath = strings.Replace(localVarPath, "{"+"switchboard_uuid"+"}", url.PathEscape(parameterValueToString(r.switchboardUuid, "switchboardUuid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.accentTenant != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accent-Tenant", r.accentTenant, "")
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["accent_auth_token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Auth-Token"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 503 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

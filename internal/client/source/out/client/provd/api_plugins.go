/*
accent-provd

Provisioning application REST API

API version: 0.2
Contact: help@accentvoice.io
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package provd

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"strings"
)

type PluginsAPI interface {

	/*
		DeletePgMgrInstall Delete the Operation In Progress

		**Required ACL:** `provd.operation.delete` This does not cancel the underlying operation; it only deletes the monitor Every monitor that is created should be deleted, else they won't be freed by the process and they will accumulate, taking memory

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param operationId Operation In Progress ID
		@return ApiDeletePgMgrInstallRequest
	*/
	DeletePgMgrInstall(ctx context.Context, operationId string) ApiDeletePgMgrInstallRequest

	// DeletePgMgrInstallExecute executes the request
	DeletePgMgrInstallExecute(r ApiDeletePgMgrInstallRequest) (*http.Response, error)

	/*
		DeletePgMgrInstallMonitor Delete the Operation In Progress

		**Required ACL:** `provd.operation.delete` This does not cancel the underlying operation; it only deletes the monitor Every monitor that is created should be deleted, else they won't be freed by the process and they will accumulate, taking memory

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param pluginId Plugin ID
		@param operationId Operation In Progress ID
		@return ApiDeletePgMgrInstallMonitorRequest
	*/
	DeletePgMgrInstallMonitor(ctx context.Context, pluginId string, operationId string) ApiDeletePgMgrInstallMonitorRequest

	// DeletePgMgrInstallMonitorExecute executes the request
	DeletePgMgrInstallMonitorExecute(r ApiDeletePgMgrInstallMonitorRequest) (*http.Response, error)

	/*
		DeletePgMgrMonitor Delete the Operation In Progress

		**Required ACL:** `provd.operation.delete` This does not cancel the underlying operation; it only deletes the monitor Every monitor that is created should be deleted, else they won't be freed by the process and they will accumulate, taking memory

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param operationId Operation In Progress ID
		@return ApiDeletePgMgrMonitorRequest
	*/
	DeletePgMgrMonitor(ctx context.Context, operationId string) ApiDeletePgMgrMonitorRequest

	// DeletePgMgrMonitorExecute executes the request
	DeletePgMgrMonitorExecute(r ApiDeletePgMgrMonitorRequest) (*http.Response, error)

	/*
		DeletePgMgrPluginUpgradeMonitor Delete the Operation In Progress

		**Required ACL:** `provd.operation.delete` This does not cancel the underlying operation; it only deletes the monitor Every monitor that is created should be deleted, else they won't be freed by the process and they will accumulate, taking memory

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param pluginId Plugin ID
		@param operationId Operation In Progress ID
		@return ApiDeletePgMgrPluginUpgradeMonitorRequest
	*/
	DeletePgMgrPluginUpgradeMonitor(ctx context.Context, pluginId string, operationId string) ApiDeletePgMgrPluginUpgradeMonitorRequest

	// DeletePgMgrPluginUpgradeMonitorExecute executes the request
	DeletePgMgrPluginUpgradeMonitorExecute(r ApiDeletePgMgrPluginUpgradeMonitorRequest) (*http.Response, error)

	/*
		DeletePgMgrUpgradeMonitor Delete the Operation In Progress

		**Required ACL:** `provd.operation.delete` This does not cancel the underlying operation; it only deletes the monitor Every monitor that is created should be deleted, else they won't be freed by the process and they will accumulate, taking memory

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param operationId Operation In Progress ID
		@return ApiDeletePgMgrUpgradeMonitorRequest
	*/
	DeletePgMgrUpgradeMonitor(ctx context.Context, operationId string) ApiDeletePgMgrUpgradeMonitorRequest

	// DeletePgMgrUpgradeMonitorExecute executes the request
	DeletePgMgrUpgradeMonitorExecute(r ApiDeletePgMgrUpgradeMonitorRequest) (*http.Response, error)

	/*
		GetPgMgr Get the Plugin Manager resource

		**Required ACL:** `provd.pg_mgr.read` The plugin manager resource represents the entry point to the accent-provd plugin REST API

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@return ApiGetPgMgrRequest
	*/
	GetPgMgr(ctx context.Context) ApiGetPgMgrRequest

	// GetPgMgrExecute executes the request
	//  @return LinksObject
	GetPgMgrExecute(r ApiGetPgMgrRequest) (*LinksObject, *http.Response, error)

	/*
		GetPgMgrInstall Get the installation service resources

		**Required ACL:** `provd.pg_mgr.install.read`

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@return ApiGetPgMgrInstallRequest
	*/
	GetPgMgrInstall(ctx context.Context) ApiGetPgMgrInstallRequest

	// GetPgMgrInstallExecute executes the request
	//  @return LinksObject
	GetPgMgrInstallExecute(r ApiGetPgMgrInstallRequest) (*LinksObject, *http.Response, error)

	/*
		GetPgMgrInstallStatus Get the status of a plugin installation Operation In Progress

		**Required ACL:** `provd.operation.read`

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param operationId Operation In Progress ID
		@return ApiGetPgMgrInstallStatusRequest
	*/
	GetPgMgrInstallStatus(ctx context.Context, operationId string) ApiGetPgMgrInstallStatusRequest

	// GetPgMgrInstallStatusExecute executes the request
	//  @return OperationInProgressObject
	GetPgMgrInstallStatusExecute(r ApiGetPgMgrInstallStatusRequest) (*OperationInProgressObject, *http.Response, error)

	/*
		GetPgMgrInstallable Get the installable plugins list

		**Required ACL:** `provd.pg_mgr.install.installable.read`

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@return ApiGetPgMgrInstallableRequest
	*/
	GetPgMgrInstallable(ctx context.Context) ApiGetPgMgrInstallableRequest

	// GetPgMgrInstallableExecute executes the request
	//  @return PackageList
	GetPgMgrInstallableExecute(r ApiGetPgMgrInstallableRequest) (*PackageList, *http.Response, error)

	/*
		GetPgMgrInstallableList Get the installable packages list

		**Required ACL:** `provd.pg_mgr.plugins.{plugin_id}.install.installable.read`

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param pluginId Plugin ID
		@return ApiGetPgMgrInstallableListRequest
	*/
	GetPgMgrInstallableList(ctx context.Context, pluginId string) ApiGetPgMgrInstallableListRequest

	// GetPgMgrInstallableListExecute executes the request
	//  @return PackageList
	GetPgMgrInstallableListExecute(r ApiGetPgMgrInstallableListRequest) (*PackageList, *http.Response, error)

	/*
		GetPgMgrInstalled Get the installed plugins list

		**Required ACL:** `provd.pg_mgr.install.installed.read`

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@return ApiGetPgMgrInstalledRequest
	*/
	GetPgMgrInstalled(ctx context.Context) ApiGetPgMgrInstalledRequest

	// GetPgMgrInstalledExecute executes the request
	//  @return PackageList
	GetPgMgrInstalledExecute(r ApiGetPgMgrInstalledRequest) (*PackageList, *http.Response, error)

	/*
		GetPgMgrInstalledList Get the installed packages list

		**Required ACL:** `provd.pg_mgr.plugins.{plugin_id}.install.installed.read`

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param pluginId Plugin ID
		@return ApiGetPgMgrInstalledListRequest
	*/
	GetPgMgrInstalledList(ctx context.Context, pluginId string) ApiGetPgMgrInstalledListRequest

	// GetPgMgrInstalledListExecute executes the request
	//  @return PackageList
	GetPgMgrInstalledListExecute(r ApiGetPgMgrInstalledListRequest) (*PackageList, *http.Response, error)

	/*
		GetPgMgrPlugin Get the resources of a specific plugin

		**Required ACL:** `provd.pg_mgr.plugins.{plugin_id}.read`

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param pluginId Plugin ID
		@return ApiGetPgMgrPluginRequest
	*/
	GetPgMgrPlugin(ctx context.Context, pluginId string) ApiGetPgMgrPluginRequest

	// GetPgMgrPluginExecute executes the request
	//  @return LinksObject
	GetPgMgrPluginExecute(r ApiGetPgMgrPluginRequest) (*LinksObject, *http.Response, error)

	/*
		GetPgMgrPluginInfo Get the information of a plugin

		**Required ACL:** `provd.pg_mgr.plugins.{plugin_id}.info.read`

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param pluginId Plugin ID
		@return ApiGetPgMgrPluginInfoRequest
	*/
	GetPgMgrPluginInfo(ctx context.Context, pluginId string) ApiGetPgMgrPluginInfoRequest

	// GetPgMgrPluginInfoExecute executes the request
	//  @return PluginInfo
	GetPgMgrPluginInfoExecute(r ApiGetPgMgrPluginInfoRequest) (*PluginInfo, *http.Response, error)

	/*
		GetPgMgrPluginInstall Get the package installation service resources

		**Required ACL:** `provd.pg_mgr.plugins.{plugin_id}.install.read`

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param pluginId Plugin ID
		@return ApiGetPgMgrPluginInstallRequest
	*/
	GetPgMgrPluginInstall(ctx context.Context, pluginId string) ApiGetPgMgrPluginInstallRequest

	// GetPgMgrPluginInstallExecute executes the request
	//  @return LinksObject
	GetPgMgrPluginInstallExecute(r ApiGetPgMgrPluginInstallRequest) (*LinksObject, *http.Response, error)

	/*
		GetPgMgrPluginInstallStatus Get the status of a package installation Operation In Progress

		**Required ACL:** `provd.operation.read`

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param pluginId Plugin ID
		@param operationId Operation In Progress ID
		@return ApiGetPgMgrPluginInstallStatusRequest
	*/
	GetPgMgrPluginInstallStatus(ctx context.Context, pluginId string, operationId string) ApiGetPgMgrPluginInstallStatusRequest

	// GetPgMgrPluginInstallStatusExecute executes the request
	//  @return OperationInProgressObject
	GetPgMgrPluginInstallStatusExecute(r ApiGetPgMgrPluginInstallStatusRequest) (*OperationInProgressObject, *http.Response, error)

	/*
		GetPgMgrPluginUpgradeStatus Get the status of a package upgrade Operation In Progress

		**Required ACL:** `provd.operation.read`

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param pluginId Plugin ID
		@param operationId Operation In Progress ID
		@return ApiGetPgMgrPluginUpgradeStatusRequest
	*/
	GetPgMgrPluginUpgradeStatus(ctx context.Context, pluginId string, operationId string) ApiGetPgMgrPluginUpgradeStatusRequest

	// GetPgMgrPluginUpgradeStatusExecute executes the request
	//  @return OperationInProgressObject
	GetPgMgrPluginUpgradeStatusExecute(r ApiGetPgMgrPluginUpgradeStatusRequest) (*OperationInProgressObject, *http.Response, error)

	/*
		GetPgMgrPlugins List the installed plugins

		**Required ACL:** `provd.pg_mgr.plugins.read`

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@return ApiGetPgMgrPluginsRequest
	*/
	GetPgMgrPlugins(ctx context.Context) ApiGetPgMgrPluginsRequest

	// GetPgMgrPluginsExecute executes the request
	//  @return PluginsObject
	GetPgMgrPluginsExecute(r ApiGetPgMgrPluginsRequest) (*PluginsObject, *http.Response, error)

	/*
		GetPgMgrUpdateStatus Get the status of a plugin database update Operation In Progress

		**Required ACL:** `provd.operation.read`

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param operationId Operation In Progress ID
		@return ApiGetPgMgrUpdateStatusRequest
	*/
	GetPgMgrUpdateStatus(ctx context.Context, operationId string) ApiGetPgMgrUpdateStatusRequest

	// GetPgMgrUpdateStatusExecute executes the request
	//  @return OperationInProgressObject
	GetPgMgrUpdateStatusExecute(r ApiGetPgMgrUpdateStatusRequest) (*OperationInProgressObject, *http.Response, error)

	/*
		GetPgMgrUpgradeStatus Get the status of a plugin upgrade Operation In Progress

		**Required ACL:** `provd.operation.read`

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param operationId Operation In Progress ID
		@return ApiGetPgMgrUpgradeStatusRequest
	*/
	GetPgMgrUpgradeStatus(ctx context.Context, operationId string) ApiGetPgMgrUpgradeStatusRequest

	// GetPgMgrUpgradeStatusExecute executes the request
	//  @return OperationInProgressObject
	GetPgMgrUpgradeStatusExecute(r ApiGetPgMgrUpgradeStatusRequest) (*OperationInProgressObject, *http.Response, error)

	/*
		PostPgMgrInstallPlugin Install a plugin

		**Required ACL:** `provd.pg_mgr.install.install.create`

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@return ApiPostPgMgrInstallPluginRequest
	*/
	PostPgMgrInstallPlugin(ctx context.Context) ApiPostPgMgrInstallPluginRequest

	// PostPgMgrInstallPluginExecute executes the request
	PostPgMgrInstallPluginExecute(r ApiPostPgMgrInstallPluginRequest) (*http.Response, error)

	/*
		PostPgMgrPluginInstallPlugin Install a package

		**Required ACL:** `provd.pg_mgr.plugins.{plugin_id}.install.install.create`

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param pluginId Plugin ID
		@return ApiPostPgMgrPluginInstallPluginRequest
	*/
	PostPgMgrPluginInstallPlugin(ctx context.Context, pluginId string) ApiPostPgMgrPluginInstallPluginRequest

	// PostPgMgrPluginInstallPluginExecute executes the request
	PostPgMgrPluginInstallPluginExecute(r ApiPostPgMgrPluginInstallPluginRequest) (*http.Response, error)

	/*
		PostPgMgrPluginUninstallPlugin Uninstall a package

		**Required ACL:** `provd.pg_mgr.plugins.{plugin_id}.install.uninstall.create`

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param pluginId Plugin ID
		@return ApiPostPgMgrPluginUninstallPluginRequest
	*/
	PostPgMgrPluginUninstallPlugin(ctx context.Context, pluginId string) ApiPostPgMgrPluginUninstallPluginRequest

	// PostPgMgrPluginUninstallPluginExecute executes the request
	PostPgMgrPluginUninstallPluginExecute(r ApiPostPgMgrPluginUninstallPluginRequest) (*http.Response, error)

	/*
		PostPgMgrReload Reload a plugin

		**Required ACL:** `provd.pg_mgr.reload.create` This is mostly useful during plugin development, after changing the code of the plugin, instead of restarting the accent-provd application

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@return ApiPostPgMgrReloadRequest
	*/
	PostPgMgrReload(ctx context.Context) ApiPostPgMgrReloadRequest

	// PostPgMgrReloadExecute executes the request
	PostPgMgrReloadExecute(r ApiPostPgMgrReloadRequest) (*http.Response, error)

	/*
		PostPgMgrUninstallPlugin Uninstall a plugin

		**Required ACL:** `provd.pg_mgr.install.uninstall.create`

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@return ApiPostPgMgrUninstallPluginRequest
	*/
	PostPgMgrUninstallPlugin(ctx context.Context) ApiPostPgMgrUninstallPluginRequest

	// PostPgMgrUninstallPluginExecute executes the request
	PostPgMgrUninstallPluginExecute(r ApiPostPgMgrUninstallPluginRequest) (*http.Response, error)

	/*
		PostPgMgrUpdateList Update the List of installable plugins

		**Required ACL:** `provd.pg_mgr.install.update.create`

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@return ApiPostPgMgrUpdateListRequest
	*/
	PostPgMgrUpdateList(ctx context.Context) ApiPostPgMgrUpdateListRequest

	// PostPgMgrUpdateListExecute executes the request
	PostPgMgrUpdateListExecute(r ApiPostPgMgrUpdateListRequest) (*http.Response, error)

	/*
		PostPgMgrUpgradePlugin Upgrade a plugin

		**Required ACL:** `provd.pg_mgr.install.upgrade.create`

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@return ApiPostPgMgrUpgradePluginRequest
	*/
	PostPgMgrUpgradePlugin(ctx context.Context) ApiPostPgMgrUpgradePluginRequest

	// PostPgMgrUpgradePluginExecute executes the request
	PostPgMgrUpgradePluginExecute(r ApiPostPgMgrUpgradePluginRequest) (*http.Response, error)
}

// PluginsAPIService PluginsAPI service
type PluginsAPIService service

type ApiDeletePgMgrInstallRequest struct {
	ctx         context.Context
	ApiService  PluginsAPI
	operationId string
}

func (r ApiDeletePgMgrInstallRequest) Execute() (*http.Response, error) {
	return r.ApiService.DeletePgMgrInstallExecute(r)
}

/*
DeletePgMgrInstall Delete the Operation In Progress

**Required ACL:** `provd.operation.delete` This does not cancel the underlying operation; it only deletes the monitor Every monitor that is created should be deleted, else they won't be freed by the process and they will accumulate, taking memory

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param operationId Operation In Progress ID
	@return ApiDeletePgMgrInstallRequest
*/
func (a *PluginsAPIService) DeletePgMgrInstall(ctx context.Context, operationId string) ApiDeletePgMgrInstallRequest {
	return ApiDeletePgMgrInstallRequest{
		ApiService:  a,
		ctx:         ctx,
		operationId: operationId,
	}
}

// Execute executes the request
func (a *PluginsAPIService) DeletePgMgrInstallExecute(r ApiDeletePgMgrInstallRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodDelete
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PluginsAPIService.DeletePgMgrInstall")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/pg_mgr/install/install/{operation_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"operation_id"+"}", url.PathEscape(parameterValueToString(r.operationId, "operationId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/vnd.accent.provd+json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["accent_auth_token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Auth-Token"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v string
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiDeletePgMgrInstallMonitorRequest struct {
	ctx         context.Context
	ApiService  PluginsAPI
	pluginId    string
	operationId string
}

func (r ApiDeletePgMgrInstallMonitorRequest) Execute() (*http.Response, error) {
	return r.ApiService.DeletePgMgrInstallMonitorExecute(r)
}

/*
DeletePgMgrInstallMonitor Delete the Operation In Progress

**Required ACL:** `provd.operation.delete` This does not cancel the underlying operation; it only deletes the monitor Every monitor that is created should be deleted, else they won't be freed by the process and they will accumulate, taking memory

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param pluginId Plugin ID
	@param operationId Operation In Progress ID
	@return ApiDeletePgMgrInstallMonitorRequest
*/
func (a *PluginsAPIService) DeletePgMgrInstallMonitor(ctx context.Context, pluginId string, operationId string) ApiDeletePgMgrInstallMonitorRequest {
	return ApiDeletePgMgrInstallMonitorRequest{
		ApiService:  a,
		ctx:         ctx,
		pluginId:    pluginId,
		operationId: operationId,
	}
}

// Execute executes the request
func (a *PluginsAPIService) DeletePgMgrInstallMonitorExecute(r ApiDeletePgMgrInstallMonitorRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodDelete
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PluginsAPIService.DeletePgMgrInstallMonitor")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/pg_mgr/plugins/{plugin_id}/install/install/{operation_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"plugin_id"+"}", url.PathEscape(parameterValueToString(r.pluginId, "pluginId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"operation_id"+"}", url.PathEscape(parameterValueToString(r.operationId, "operationId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/vnd.accent.provd+json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["accent_auth_token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Auth-Token"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v string
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiDeletePgMgrMonitorRequest struct {
	ctx         context.Context
	ApiService  PluginsAPI
	operationId string
}

func (r ApiDeletePgMgrMonitorRequest) Execute() (*http.Response, error) {
	return r.ApiService.DeletePgMgrMonitorExecute(r)
}

/*
DeletePgMgrMonitor Delete the Operation In Progress

**Required ACL:** `provd.operation.delete` This does not cancel the underlying operation; it only deletes the monitor Every monitor that is created should be deleted, else they won't be freed by the process and they will accumulate, taking memory

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param operationId Operation In Progress ID
	@return ApiDeletePgMgrMonitorRequest
*/
func (a *PluginsAPIService) DeletePgMgrMonitor(ctx context.Context, operationId string) ApiDeletePgMgrMonitorRequest {
	return ApiDeletePgMgrMonitorRequest{
		ApiService:  a,
		ctx:         ctx,
		operationId: operationId,
	}
}

// Execute executes the request
func (a *PluginsAPIService) DeletePgMgrMonitorExecute(r ApiDeletePgMgrMonitorRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodDelete
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PluginsAPIService.DeletePgMgrMonitor")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/pg_mgr/install/update/{operation_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"operation_id"+"}", url.PathEscape(parameterValueToString(r.operationId, "operationId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/vnd.accent.provd+json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["accent_auth_token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Auth-Token"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v string
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiDeletePgMgrPluginUpgradeMonitorRequest struct {
	ctx         context.Context
	ApiService  PluginsAPI
	pluginId    string
	operationId string
}

func (r ApiDeletePgMgrPluginUpgradeMonitorRequest) Execute() (*http.Response, error) {
	return r.ApiService.DeletePgMgrPluginUpgradeMonitorExecute(r)
}

/*
DeletePgMgrPluginUpgradeMonitor Delete the Operation In Progress

**Required ACL:** `provd.operation.delete` This does not cancel the underlying operation; it only deletes the monitor Every monitor that is created should be deleted, else they won't be freed by the process and they will accumulate, taking memory

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param pluginId Plugin ID
	@param operationId Operation In Progress ID
	@return ApiDeletePgMgrPluginUpgradeMonitorRequest
*/
func (a *PluginsAPIService) DeletePgMgrPluginUpgradeMonitor(ctx context.Context, pluginId string, operationId string) ApiDeletePgMgrPluginUpgradeMonitorRequest {
	return ApiDeletePgMgrPluginUpgradeMonitorRequest{
		ApiService:  a,
		ctx:         ctx,
		pluginId:    pluginId,
		operationId: operationId,
	}
}

// Execute executes the request
func (a *PluginsAPIService) DeletePgMgrPluginUpgradeMonitorExecute(r ApiDeletePgMgrPluginUpgradeMonitorRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodDelete
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PluginsAPIService.DeletePgMgrPluginUpgradeMonitor")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/pg_mgr/plugins/{plugin_id}/install/upgrade/{operation_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"plugin_id"+"}", url.PathEscape(parameterValueToString(r.pluginId, "pluginId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"operation_id"+"}", url.PathEscape(parameterValueToString(r.operationId, "operationId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/vnd.accent.provd+json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["accent_auth_token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Auth-Token"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v string
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiDeletePgMgrUpgradeMonitorRequest struct {
	ctx         context.Context
	ApiService  PluginsAPI
	operationId string
}

func (r ApiDeletePgMgrUpgradeMonitorRequest) Execute() (*http.Response, error) {
	return r.ApiService.DeletePgMgrUpgradeMonitorExecute(r)
}

/*
DeletePgMgrUpgradeMonitor Delete the Operation In Progress

**Required ACL:** `provd.operation.delete` This does not cancel the underlying operation; it only deletes the monitor Every monitor that is created should be deleted, else they won't be freed by the process and they will accumulate, taking memory

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param operationId Operation In Progress ID
	@return ApiDeletePgMgrUpgradeMonitorRequest
*/
func (a *PluginsAPIService) DeletePgMgrUpgradeMonitor(ctx context.Context, operationId string) ApiDeletePgMgrUpgradeMonitorRequest {
	return ApiDeletePgMgrUpgradeMonitorRequest{
		ApiService:  a,
		ctx:         ctx,
		operationId: operationId,
	}
}

// Execute executes the request
func (a *PluginsAPIService) DeletePgMgrUpgradeMonitorExecute(r ApiDeletePgMgrUpgradeMonitorRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodDelete
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PluginsAPIService.DeletePgMgrUpgradeMonitor")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/pg_mgr/install/upgrade/{operation_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"operation_id"+"}", url.PathEscape(parameterValueToString(r.operationId, "operationId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/vnd.accent.provd+json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["accent_auth_token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Auth-Token"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v string
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiGetPgMgrRequest struct {
	ctx        context.Context
	ApiService PluginsAPI
}

func (r ApiGetPgMgrRequest) Execute() (*LinksObject, *http.Response, error) {
	return r.ApiService.GetPgMgrExecute(r)
}

/*
GetPgMgr Get the Plugin Manager resource

**Required ACL:** `provd.pg_mgr.read` The plugin manager resource represents the entry point to the accent-provd plugin REST API

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiGetPgMgrRequest
*/
func (a *PluginsAPIService) GetPgMgr(ctx context.Context) ApiGetPgMgrRequest {
	return ApiGetPgMgrRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return LinksObject
func (a *PluginsAPIService) GetPgMgrExecute(r ApiGetPgMgrRequest) (*LinksObject, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *LinksObject
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PluginsAPIService.GetPgMgr")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/pg_mgr"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/vnd.accent.provd+json", "links"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["accent_auth_token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Auth-Token"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetPgMgrInstallRequest struct {
	ctx        context.Context
	ApiService PluginsAPI
}

func (r ApiGetPgMgrInstallRequest) Execute() (*LinksObject, *http.Response, error) {
	return r.ApiService.GetPgMgrInstallExecute(r)
}

/*
GetPgMgrInstall Get the installation service resources

**Required ACL:** `provd.pg_mgr.install.read`

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiGetPgMgrInstallRequest
*/
func (a *PluginsAPIService) GetPgMgrInstall(ctx context.Context) ApiGetPgMgrInstallRequest {
	return ApiGetPgMgrInstallRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return LinksObject
func (a *PluginsAPIService) GetPgMgrInstallExecute(r ApiGetPgMgrInstallRequest) (*LinksObject, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *LinksObject
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PluginsAPIService.GetPgMgrInstall")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/pg_mgr/install"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/vnd.accent.provd+json", "links"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["accent_auth_token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Auth-Token"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetPgMgrInstallStatusRequest struct {
	ctx         context.Context
	ApiService  PluginsAPI
	operationId string
}

func (r ApiGetPgMgrInstallStatusRequest) Execute() (*OperationInProgressObject, *http.Response, error) {
	return r.ApiService.GetPgMgrInstallStatusExecute(r)
}

/*
GetPgMgrInstallStatus Get the status of a plugin installation Operation In Progress

**Required ACL:** `provd.operation.read`

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param operationId Operation In Progress ID
	@return ApiGetPgMgrInstallStatusRequest
*/
func (a *PluginsAPIService) GetPgMgrInstallStatus(ctx context.Context, operationId string) ApiGetPgMgrInstallStatusRequest {
	return ApiGetPgMgrInstallStatusRequest{
		ApiService:  a,
		ctx:         ctx,
		operationId: operationId,
	}
}

// Execute executes the request
//
//	@return OperationInProgressObject
func (a *PluginsAPIService) GetPgMgrInstallStatusExecute(r ApiGetPgMgrInstallStatusRequest) (*OperationInProgressObject, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *OperationInProgressObject
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PluginsAPIService.GetPgMgrInstallStatus")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/pg_mgr/install/install/{operation_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"operation_id"+"}", url.PathEscape(parameterValueToString(r.operationId, "operationId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/vnd.accent.provd+json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["accent_auth_token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Auth-Token"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v string
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetPgMgrInstallableRequest struct {
	ctx        context.Context
	ApiService PluginsAPI
}

func (r ApiGetPgMgrInstallableRequest) Execute() (*PackageList, *http.Response, error) {
	return r.ApiService.GetPgMgrInstallableExecute(r)
}

/*
GetPgMgrInstallable Get the installable plugins list

**Required ACL:** `provd.pg_mgr.install.installable.read`

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiGetPgMgrInstallableRequest
*/
func (a *PluginsAPIService) GetPgMgrInstallable(ctx context.Context) ApiGetPgMgrInstallableRequest {
	return ApiGetPgMgrInstallableRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return PackageList
func (a *PluginsAPIService) GetPgMgrInstallableExecute(r ApiGetPgMgrInstallableRequest) (*PackageList, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *PackageList
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PluginsAPIService.GetPgMgrInstallable")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/pg_mgr/install/installable"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/vnd.accent.provd+json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["accent_auth_token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Auth-Token"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetPgMgrInstallableListRequest struct {
	ctx        context.Context
	ApiService PluginsAPI
	pluginId   string
}

func (r ApiGetPgMgrInstallableListRequest) Execute() (*PackageList, *http.Response, error) {
	return r.ApiService.GetPgMgrInstallableListExecute(r)
}

/*
GetPgMgrInstallableList Get the installable packages list

**Required ACL:** `provd.pg_mgr.plugins.{plugin_id}.install.installable.read`

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param pluginId Plugin ID
	@return ApiGetPgMgrInstallableListRequest
*/
func (a *PluginsAPIService) GetPgMgrInstallableList(ctx context.Context, pluginId string) ApiGetPgMgrInstallableListRequest {
	return ApiGetPgMgrInstallableListRequest{
		ApiService: a,
		ctx:        ctx,
		pluginId:   pluginId,
	}
}

// Execute executes the request
//
//	@return PackageList
func (a *PluginsAPIService) GetPgMgrInstallableListExecute(r ApiGetPgMgrInstallableListRequest) (*PackageList, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *PackageList
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PluginsAPIService.GetPgMgrInstallableList")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/pg_mgr/plugins/{plugin_id}/install/installable"
	localVarPath = strings.Replace(localVarPath, "{"+"plugin_id"+"}", url.PathEscape(parameterValueToString(r.pluginId, "pluginId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/vnd.accent.provd+json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["accent_auth_token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Auth-Token"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v string
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetPgMgrInstalledRequest struct {
	ctx        context.Context
	ApiService PluginsAPI
}

func (r ApiGetPgMgrInstalledRequest) Execute() (*PackageList, *http.Response, error) {
	return r.ApiService.GetPgMgrInstalledExecute(r)
}

/*
GetPgMgrInstalled Get the installed plugins list

**Required ACL:** `provd.pg_mgr.install.installed.read`

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiGetPgMgrInstalledRequest
*/
func (a *PluginsAPIService) GetPgMgrInstalled(ctx context.Context) ApiGetPgMgrInstalledRequest {
	return ApiGetPgMgrInstalledRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return PackageList
func (a *PluginsAPIService) GetPgMgrInstalledExecute(r ApiGetPgMgrInstalledRequest) (*PackageList, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *PackageList
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PluginsAPIService.GetPgMgrInstalled")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/pg_mgr/install/installed"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/vnd.accent.provd+json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["accent_auth_token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Auth-Token"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetPgMgrInstalledListRequest struct {
	ctx        context.Context
	ApiService PluginsAPI
	pluginId   string
}

func (r ApiGetPgMgrInstalledListRequest) Execute() (*PackageList, *http.Response, error) {
	return r.ApiService.GetPgMgrInstalledListExecute(r)
}

/*
GetPgMgrInstalledList Get the installed packages list

**Required ACL:** `provd.pg_mgr.plugins.{plugin_id}.install.installed.read`

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param pluginId Plugin ID
	@return ApiGetPgMgrInstalledListRequest
*/
func (a *PluginsAPIService) GetPgMgrInstalledList(ctx context.Context, pluginId string) ApiGetPgMgrInstalledListRequest {
	return ApiGetPgMgrInstalledListRequest{
		ApiService: a,
		ctx:        ctx,
		pluginId:   pluginId,
	}
}

// Execute executes the request
//
//	@return PackageList
func (a *PluginsAPIService) GetPgMgrInstalledListExecute(r ApiGetPgMgrInstalledListRequest) (*PackageList, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *PackageList
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PluginsAPIService.GetPgMgrInstalledList")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/pg_mgr/plugins/{plugin_id}/install/installed"
	localVarPath = strings.Replace(localVarPath, "{"+"plugin_id"+"}", url.PathEscape(parameterValueToString(r.pluginId, "pluginId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/vnd.accent.provd+json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["accent_auth_token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Auth-Token"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v string
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetPgMgrPluginRequest struct {
	ctx        context.Context
	ApiService PluginsAPI
	pluginId   string
}

func (r ApiGetPgMgrPluginRequest) Execute() (*LinksObject, *http.Response, error) {
	return r.ApiService.GetPgMgrPluginExecute(r)
}

/*
GetPgMgrPlugin Get the resources of a specific plugin

**Required ACL:** `provd.pg_mgr.plugins.{plugin_id}.read`

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param pluginId Plugin ID
	@return ApiGetPgMgrPluginRequest
*/
func (a *PluginsAPIService) GetPgMgrPlugin(ctx context.Context, pluginId string) ApiGetPgMgrPluginRequest {
	return ApiGetPgMgrPluginRequest{
		ApiService: a,
		ctx:        ctx,
		pluginId:   pluginId,
	}
}

// Execute executes the request
//
//	@return LinksObject
func (a *PluginsAPIService) GetPgMgrPluginExecute(r ApiGetPgMgrPluginRequest) (*LinksObject, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *LinksObject
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PluginsAPIService.GetPgMgrPlugin")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/pg_mgr/plugins/{plugin_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"plugin_id"+"}", url.PathEscape(parameterValueToString(r.pluginId, "pluginId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/vnd.accent.provd+json", "links"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["accent_auth_token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Auth-Token"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v string
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetPgMgrPluginInfoRequest struct {
	ctx        context.Context
	ApiService PluginsAPI
	pluginId   string
}

func (r ApiGetPgMgrPluginInfoRequest) Execute() (*PluginInfo, *http.Response, error) {
	return r.ApiService.GetPgMgrPluginInfoExecute(r)
}

/*
GetPgMgrPluginInfo Get the information of a plugin

**Required ACL:** `provd.pg_mgr.plugins.{plugin_id}.info.read`

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param pluginId Plugin ID
	@return ApiGetPgMgrPluginInfoRequest
*/
func (a *PluginsAPIService) GetPgMgrPluginInfo(ctx context.Context, pluginId string) ApiGetPgMgrPluginInfoRequest {
	return ApiGetPgMgrPluginInfoRequest{
		ApiService: a,
		ctx:        ctx,
		pluginId:   pluginId,
	}
}

// Execute executes the request
//
//	@return PluginInfo
func (a *PluginsAPIService) GetPgMgrPluginInfoExecute(r ApiGetPgMgrPluginInfoRequest) (*PluginInfo, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *PluginInfo
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PluginsAPIService.GetPgMgrPluginInfo")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/pg_mgr/plugins/{plugin_id}/info"
	localVarPath = strings.Replace(localVarPath, "{"+"plugin_id"+"}", url.PathEscape(parameterValueToString(r.pluginId, "pluginId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/vnd.accent.provd+json", "plugin_info"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["accent_auth_token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Auth-Token"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v string
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetPgMgrPluginInstallRequest struct {
	ctx        context.Context
	ApiService PluginsAPI
	pluginId   string
}

func (r ApiGetPgMgrPluginInstallRequest) Execute() (*LinksObject, *http.Response, error) {
	return r.ApiService.GetPgMgrPluginInstallExecute(r)
}

/*
GetPgMgrPluginInstall Get the package installation service resources

**Required ACL:** `provd.pg_mgr.plugins.{plugin_id}.install.read`

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param pluginId Plugin ID
	@return ApiGetPgMgrPluginInstallRequest
*/
func (a *PluginsAPIService) GetPgMgrPluginInstall(ctx context.Context, pluginId string) ApiGetPgMgrPluginInstallRequest {
	return ApiGetPgMgrPluginInstallRequest{
		ApiService: a,
		ctx:        ctx,
		pluginId:   pluginId,
	}
}

// Execute executes the request
//
//	@return LinksObject
func (a *PluginsAPIService) GetPgMgrPluginInstallExecute(r ApiGetPgMgrPluginInstallRequest) (*LinksObject, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *LinksObject
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PluginsAPIService.GetPgMgrPluginInstall")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/pg_mgr/plugins/{plugin_id}/install"
	localVarPath = strings.Replace(localVarPath, "{"+"plugin_id"+"}", url.PathEscape(parameterValueToString(r.pluginId, "pluginId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/vnd.accent.provd+json", "links"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["accent_auth_token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Auth-Token"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v string
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetPgMgrPluginInstallStatusRequest struct {
	ctx         context.Context
	ApiService  PluginsAPI
	pluginId    string
	operationId string
}

func (r ApiGetPgMgrPluginInstallStatusRequest) Execute() (*OperationInProgressObject, *http.Response, error) {
	return r.ApiService.GetPgMgrPluginInstallStatusExecute(r)
}

/*
GetPgMgrPluginInstallStatus Get the status of a package installation Operation In Progress

**Required ACL:** `provd.operation.read`

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param pluginId Plugin ID
	@param operationId Operation In Progress ID
	@return ApiGetPgMgrPluginInstallStatusRequest
*/
func (a *PluginsAPIService) GetPgMgrPluginInstallStatus(ctx context.Context, pluginId string, operationId string) ApiGetPgMgrPluginInstallStatusRequest {
	return ApiGetPgMgrPluginInstallStatusRequest{
		ApiService:  a,
		ctx:         ctx,
		pluginId:    pluginId,
		operationId: operationId,
	}
}

// Execute executes the request
//
//	@return OperationInProgressObject
func (a *PluginsAPIService) GetPgMgrPluginInstallStatusExecute(r ApiGetPgMgrPluginInstallStatusRequest) (*OperationInProgressObject, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *OperationInProgressObject
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PluginsAPIService.GetPgMgrPluginInstallStatus")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/pg_mgr/plugins/{plugin_id}/install/install/{operation_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"plugin_id"+"}", url.PathEscape(parameterValueToString(r.pluginId, "pluginId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"operation_id"+"}", url.PathEscape(parameterValueToString(r.operationId, "operationId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/vnd.accent.provd+json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["accent_auth_token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Auth-Token"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v string
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetPgMgrPluginUpgradeStatusRequest struct {
	ctx         context.Context
	ApiService  PluginsAPI
	pluginId    string
	operationId string
}

func (r ApiGetPgMgrPluginUpgradeStatusRequest) Execute() (*OperationInProgressObject, *http.Response, error) {
	return r.ApiService.GetPgMgrPluginUpgradeStatusExecute(r)
}

/*
GetPgMgrPluginUpgradeStatus Get the status of a package upgrade Operation In Progress

**Required ACL:** `provd.operation.read`

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param pluginId Plugin ID
	@param operationId Operation In Progress ID
	@return ApiGetPgMgrPluginUpgradeStatusRequest
*/
func (a *PluginsAPIService) GetPgMgrPluginUpgradeStatus(ctx context.Context, pluginId string, operationId string) ApiGetPgMgrPluginUpgradeStatusRequest {
	return ApiGetPgMgrPluginUpgradeStatusRequest{
		ApiService:  a,
		ctx:         ctx,
		pluginId:    pluginId,
		operationId: operationId,
	}
}

// Execute executes the request
//
//	@return OperationInProgressObject
func (a *PluginsAPIService) GetPgMgrPluginUpgradeStatusExecute(r ApiGetPgMgrPluginUpgradeStatusRequest) (*OperationInProgressObject, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *OperationInProgressObject
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PluginsAPIService.GetPgMgrPluginUpgradeStatus")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/pg_mgr/plugins/{plugin_id}/install/upgrade/{operation_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"plugin_id"+"}", url.PathEscape(parameterValueToString(r.pluginId, "pluginId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"operation_id"+"}", url.PathEscape(parameterValueToString(r.operationId, "operationId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/vnd.accent.provd+json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["accent_auth_token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Auth-Token"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v string
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetPgMgrPluginsRequest struct {
	ctx        context.Context
	ApiService PluginsAPI
}

func (r ApiGetPgMgrPluginsRequest) Execute() (*PluginsObject, *http.Response, error) {
	return r.ApiService.GetPgMgrPluginsExecute(r)
}

/*
GetPgMgrPlugins List the installed plugins

**Required ACL:** `provd.pg_mgr.plugins.read`

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiGetPgMgrPluginsRequest
*/
func (a *PluginsAPIService) GetPgMgrPlugins(ctx context.Context) ApiGetPgMgrPluginsRequest {
	return ApiGetPgMgrPluginsRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return PluginsObject
func (a *PluginsAPIService) GetPgMgrPluginsExecute(r ApiGetPgMgrPluginsRequest) (*PluginsObject, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *PluginsObject
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PluginsAPIService.GetPgMgrPlugins")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/pg_mgr/plugins"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/vnd.accent.provd+json", "plugins"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["accent_auth_token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Auth-Token"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetPgMgrUpdateStatusRequest struct {
	ctx         context.Context
	ApiService  PluginsAPI
	operationId string
}

func (r ApiGetPgMgrUpdateStatusRequest) Execute() (*OperationInProgressObject, *http.Response, error) {
	return r.ApiService.GetPgMgrUpdateStatusExecute(r)
}

/*
GetPgMgrUpdateStatus Get the status of a plugin database update Operation In Progress

**Required ACL:** `provd.operation.read`

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param operationId Operation In Progress ID
	@return ApiGetPgMgrUpdateStatusRequest
*/
func (a *PluginsAPIService) GetPgMgrUpdateStatus(ctx context.Context, operationId string) ApiGetPgMgrUpdateStatusRequest {
	return ApiGetPgMgrUpdateStatusRequest{
		ApiService:  a,
		ctx:         ctx,
		operationId: operationId,
	}
}

// Execute executes the request
//
//	@return OperationInProgressObject
func (a *PluginsAPIService) GetPgMgrUpdateStatusExecute(r ApiGetPgMgrUpdateStatusRequest) (*OperationInProgressObject, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *OperationInProgressObject
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PluginsAPIService.GetPgMgrUpdateStatus")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/pg_mgr/install/update/{operation_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"operation_id"+"}", url.PathEscape(parameterValueToString(r.operationId, "operationId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/vnd.accent.provd+json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["accent_auth_token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Auth-Token"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v string
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetPgMgrUpgradeStatusRequest struct {
	ctx         context.Context
	ApiService  PluginsAPI
	operationId string
}

func (r ApiGetPgMgrUpgradeStatusRequest) Execute() (*OperationInProgressObject, *http.Response, error) {
	return r.ApiService.GetPgMgrUpgradeStatusExecute(r)
}

/*
GetPgMgrUpgradeStatus Get the status of a plugin upgrade Operation In Progress

**Required ACL:** `provd.operation.read`

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param operationId Operation In Progress ID
	@return ApiGetPgMgrUpgradeStatusRequest
*/
func (a *PluginsAPIService) GetPgMgrUpgradeStatus(ctx context.Context, operationId string) ApiGetPgMgrUpgradeStatusRequest {
	return ApiGetPgMgrUpgradeStatusRequest{
		ApiService:  a,
		ctx:         ctx,
		operationId: operationId,
	}
}

// Execute executes the request
//
//	@return OperationInProgressObject
func (a *PluginsAPIService) GetPgMgrUpgradeStatusExecute(r ApiGetPgMgrUpgradeStatusRequest) (*OperationInProgressObject, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *OperationInProgressObject
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PluginsAPIService.GetPgMgrUpgradeStatus")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/pg_mgr/install/upgrade/{operation_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"operation_id"+"}", url.PathEscape(parameterValueToString(r.operationId, "operationId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/vnd.accent.provd+json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["accent_auth_token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Auth-Token"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v string
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPostPgMgrInstallPluginRequest struct {
	ctx        context.Context
	ApiService PluginsAPI
	body       *IdObject
}

// Package ID body definition
func (r ApiPostPgMgrInstallPluginRequest) Body(body IdObject) ApiPostPgMgrInstallPluginRequest {
	r.body = &body
	return r
}

func (r ApiPostPgMgrInstallPluginRequest) Execute() (*http.Response, error) {
	return r.ApiService.PostPgMgrInstallPluginExecute(r)
}

/*
PostPgMgrInstallPlugin Install a plugin

**Required ACL:** `provd.pg_mgr.install.install.create`

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiPostPgMgrInstallPluginRequest
*/
func (a *PluginsAPIService) PostPgMgrInstallPlugin(ctx context.Context) ApiPostPgMgrInstallPluginRequest {
	return ApiPostPgMgrInstallPluginRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
func (a *PluginsAPIService) PostPgMgrInstallPluginExecute(r ApiPostPgMgrInstallPluginRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodPost
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PluginsAPIService.PostPgMgrInstallPlugin")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/pg_mgr/install/install"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/vnd.accent.provd+json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/vnd.accent.provd+json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["accent_auth_token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Auth-Token"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v string
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 415 {
			var v string
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiPostPgMgrPluginInstallPluginRequest struct {
	ctx        context.Context
	ApiService PluginsAPI
	pluginId   string
	body       *IdObject
}

// Package ID body definition
func (r ApiPostPgMgrPluginInstallPluginRequest) Body(body IdObject) ApiPostPgMgrPluginInstallPluginRequest {
	r.body = &body
	return r
}

func (r ApiPostPgMgrPluginInstallPluginRequest) Execute() (*http.Response, error) {
	return r.ApiService.PostPgMgrPluginInstallPluginExecute(r)
}

/*
PostPgMgrPluginInstallPlugin Install a package

**Required ACL:** `provd.pg_mgr.plugins.{plugin_id}.install.install.create`

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param pluginId Plugin ID
	@return ApiPostPgMgrPluginInstallPluginRequest
*/
func (a *PluginsAPIService) PostPgMgrPluginInstallPlugin(ctx context.Context, pluginId string) ApiPostPgMgrPluginInstallPluginRequest {
	return ApiPostPgMgrPluginInstallPluginRequest{
		ApiService: a,
		ctx:        ctx,
		pluginId:   pluginId,
	}
}

// Execute executes the request
func (a *PluginsAPIService) PostPgMgrPluginInstallPluginExecute(r ApiPostPgMgrPluginInstallPluginRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodPost
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PluginsAPIService.PostPgMgrPluginInstallPlugin")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/pg_mgr/plugins/{plugin_id}/install/install"
	localVarPath = strings.Replace(localVarPath, "{"+"plugin_id"+"}", url.PathEscape(parameterValueToString(r.pluginId, "pluginId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/vnd.accent.provd+json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/vnd.accent.provd+json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["accent_auth_token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Auth-Token"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v string
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v string
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 415 {
			var v string
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiPostPgMgrPluginUninstallPluginRequest struct {
	ctx        context.Context
	ApiService PluginsAPI
	pluginId   string
	body       *IdObject
}

// Package ID body definition
func (r ApiPostPgMgrPluginUninstallPluginRequest) Body(body IdObject) ApiPostPgMgrPluginUninstallPluginRequest {
	r.body = &body
	return r
}

func (r ApiPostPgMgrPluginUninstallPluginRequest) Execute() (*http.Response, error) {
	return r.ApiService.PostPgMgrPluginUninstallPluginExecute(r)
}

/*
PostPgMgrPluginUninstallPlugin Uninstall a package

**Required ACL:** `provd.pg_mgr.plugins.{plugin_id}.install.uninstall.create`

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param pluginId Plugin ID
	@return ApiPostPgMgrPluginUninstallPluginRequest
*/
func (a *PluginsAPIService) PostPgMgrPluginUninstallPlugin(ctx context.Context, pluginId string) ApiPostPgMgrPluginUninstallPluginRequest {
	return ApiPostPgMgrPluginUninstallPluginRequest{
		ApiService: a,
		ctx:        ctx,
		pluginId:   pluginId,
	}
}

// Execute executes the request
func (a *PluginsAPIService) PostPgMgrPluginUninstallPluginExecute(r ApiPostPgMgrPluginUninstallPluginRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodPost
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PluginsAPIService.PostPgMgrPluginUninstallPlugin")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/pg_mgr/plugins/{plugin_id}/install/uninstall"
	localVarPath = strings.Replace(localVarPath, "{"+"plugin_id"+"}", url.PathEscape(parameterValueToString(r.pluginId, "pluginId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/vnd.accent.provd+json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/vnd.accent.provd+json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["accent_auth_token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Auth-Token"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v string
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v string
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 415 {
			var v string
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiPostPgMgrReloadRequest struct {
	ctx        context.Context
	ApiService PluginsAPI
	body       *IdObject
}

// Plugin ID body definition
func (r ApiPostPgMgrReloadRequest) Body(body IdObject) ApiPostPgMgrReloadRequest {
	r.body = &body
	return r
}

func (r ApiPostPgMgrReloadRequest) Execute() (*http.Response, error) {
	return r.ApiService.PostPgMgrReloadExecute(r)
}

/*
PostPgMgrReload Reload a plugin

**Required ACL:** `provd.pg_mgr.reload.create` This is mostly useful during plugin development, after changing the code of the plugin, instead of restarting the accent-provd application

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiPostPgMgrReloadRequest
*/
func (a *PluginsAPIService) PostPgMgrReload(ctx context.Context) ApiPostPgMgrReloadRequest {
	return ApiPostPgMgrReloadRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
func (a *PluginsAPIService) PostPgMgrReloadExecute(r ApiPostPgMgrReloadRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodPost
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PluginsAPIService.PostPgMgrReload")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/pg_mgr/reload"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/vnd.accent.provd+json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["accent_auth_token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Auth-Token"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiPostPgMgrUninstallPluginRequest struct {
	ctx        context.Context
	ApiService PluginsAPI
	body       *IdObject
}

// Package ID body definition
func (r ApiPostPgMgrUninstallPluginRequest) Body(body IdObject) ApiPostPgMgrUninstallPluginRequest {
	r.body = &body
	return r
}

func (r ApiPostPgMgrUninstallPluginRequest) Execute() (*http.Response, error) {
	return r.ApiService.PostPgMgrUninstallPluginExecute(r)
}

/*
PostPgMgrUninstallPlugin Uninstall a plugin

**Required ACL:** `provd.pg_mgr.install.uninstall.create`

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiPostPgMgrUninstallPluginRequest
*/
func (a *PluginsAPIService) PostPgMgrUninstallPlugin(ctx context.Context) ApiPostPgMgrUninstallPluginRequest {
	return ApiPostPgMgrUninstallPluginRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
func (a *PluginsAPIService) PostPgMgrUninstallPluginExecute(r ApiPostPgMgrUninstallPluginRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodPost
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PluginsAPIService.PostPgMgrUninstallPlugin")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/pg_mgr/install/uninstall"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/vnd.accent.provd+json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/vnd.accent.provd+json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["accent_auth_token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Auth-Token"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v string
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 415 {
			var v string
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiPostPgMgrUpdateListRequest struct {
	ctx        context.Context
	ApiService PluginsAPI
	body       *map[string]interface{}
}

// Empty object body
func (r ApiPostPgMgrUpdateListRequest) Body(body map[string]interface{}) ApiPostPgMgrUpdateListRequest {
	r.body = &body
	return r
}

func (r ApiPostPgMgrUpdateListRequest) Execute() (*http.Response, error) {
	return r.ApiService.PostPgMgrUpdateListExecute(r)
}

/*
PostPgMgrUpdateList Update the List of installable plugins

**Required ACL:** `provd.pg_mgr.install.update.create`

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiPostPgMgrUpdateListRequest
*/
func (a *PluginsAPIService) PostPgMgrUpdateList(ctx context.Context) ApiPostPgMgrUpdateListRequest {
	return ApiPostPgMgrUpdateListRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
func (a *PluginsAPIService) PostPgMgrUpdateListExecute(r ApiPostPgMgrUpdateListRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodPost
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PluginsAPIService.PostPgMgrUpdateList")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/pg_mgr/install/update"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/vnd.accent.provd+json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/vnd.accent.provd+json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["accent_auth_token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Auth-Token"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v string
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiPostPgMgrUpgradePluginRequest struct {
	ctx        context.Context
	ApiService PluginsAPI
	body       *IdObject
}

// Package ID body definition
func (r ApiPostPgMgrUpgradePluginRequest) Body(body IdObject) ApiPostPgMgrUpgradePluginRequest {
	r.body = &body
	return r
}

func (r ApiPostPgMgrUpgradePluginRequest) Execute() (*http.Response, error) {
	return r.ApiService.PostPgMgrUpgradePluginExecute(r)
}

/*
PostPgMgrUpgradePlugin Upgrade a plugin

**Required ACL:** `provd.pg_mgr.install.upgrade.create`

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiPostPgMgrUpgradePluginRequest
*/
func (a *PluginsAPIService) PostPgMgrUpgradePlugin(ctx context.Context) ApiPostPgMgrUpgradePluginRequest {
	return ApiPostPgMgrUpgradePluginRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
func (a *PluginsAPIService) PostPgMgrUpgradePluginExecute(r ApiPostPgMgrUpgradePluginRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodPost
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PluginsAPIService.PostPgMgrUpgradePlugin")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/pg_mgr/install/upgrade"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/vnd.accent.provd+json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/vnd.accent.provd+json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["accent_auth_token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Auth-Token"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v string
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 415 {
			var v string
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

/*
accent-confd

Confd exposes an API for managing core resources on a Accent server such as users, extensions, devices, voicemails, queues, etc. Resources can be associated together to provide additional functionality. For example: By associating a voicemail with a user, calls will automatically fallback on to the voicemail when the user cannot answer.  Implementation notes ====================  Errors ------  Responses containing errors will have a status code in the 400 or 500 class. A list of error messages will be returned in the body of the response as a JSON-encoded array:  ~~~ [     \"Input error - User not found\",     \"Resource error - User not associated to a line\" ] ~~~   Updating resources via PUT --------------------------  When updating a resource, all fields become optional. In other words, only values that have been changed need to be sent to the server. Please note that this behavior may change in future versions of the API.

API version: 1.1
Contact: help@accentvoice.io
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package confd

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"strings"
)

type LinesAPI interface {

	/*
		AssociateLineApplication Associate line and application

		'**Required ACL:** `confd.lines.{line_id}.applications.{application_uuid}.update`'

	**WARNING**: Association will disable the effect of the line `context` field


		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param lineId
		@param applicationUuid Application's UUID
		@return ApiAssociateLineApplicationRequest
	*/
	AssociateLineApplication(ctx context.Context, lineId int32, applicationUuid int32) ApiAssociateLineApplicationRequest

	// AssociateLineApplicationExecute executes the request
	AssociateLineApplicationExecute(r ApiAssociateLineApplicationRequest) (*http.Response, error)

	/*
		AssociateLineDevice Associate line and device

		**Required ACL:** `confd.lines.{line_id}.devices.{device_id}.update`

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param lineId
		@param deviceId Device's ID
		@return ApiAssociateLineDeviceRequest
	*/
	AssociateLineDevice(ctx context.Context, lineId int32, deviceId string) ApiAssociateLineDeviceRequest

	// AssociateLineDeviceExecute executes the request
	AssociateLineDeviceExecute(r ApiAssociateLineDeviceRequest) (*http.Response, error)

	/*
		AssociateLineEndpointCustom Associate line and Custom endpoint

		**Required ACL:** `confd.lines.{line_id}.endpoints.custom.{custom_id}.update`

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param lineId
		@param customId
		@return ApiAssociateLineEndpointCustomRequest
	*/
	AssociateLineEndpointCustom(ctx context.Context, lineId int32, customId int32) ApiAssociateLineEndpointCustomRequest

	// AssociateLineEndpointCustomExecute executes the request
	AssociateLineEndpointCustomExecute(r ApiAssociateLineEndpointCustomRequest) (*http.Response, error)

	/*
		AssociateLineEndpointSccp Associate line and SCCP endpoint

		**Required ACL:** `confd.lines.{line_id}.endpoints.sccp.{sccp_id}.update`

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param lineId
		@param sccpId
		@return ApiAssociateLineEndpointSccpRequest
	*/
	AssociateLineEndpointSccp(ctx context.Context, lineId int32, sccpId int32) ApiAssociateLineEndpointSccpRequest

	// AssociateLineEndpointSccpExecute executes the request
	AssociateLineEndpointSccpExecute(r ApiAssociateLineEndpointSccpRequest) (*http.Response, error)

	/*
		AssociateLineEndpointSip Associate line and SIP endpoint

		**Required ACL:** `confd.lines.{line_id}.endpoints.sip.{sip_uuid}.update`

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param lineId
		@param sipUuid
		@return ApiAssociateLineEndpointSipRequest
	*/
	AssociateLineEndpointSip(ctx context.Context, lineId int32, sipUuid string) ApiAssociateLineEndpointSipRequest

	// AssociateLineEndpointSipExecute executes the request
	AssociateLineEndpointSipExecute(r ApiAssociateLineEndpointSipRequest) (*http.Response, error)

	/*
		AssociateLineExtension Associate line and extension

		**Required ACL:** `confd.lines.{line_id}.extensions.{extension_id}.update`

	Because of technical limitations, a line can only have a single ‘internal’ extension associated (i.e. an extension with a context of type ‘internal’)

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param lineId
		@param extensionId
		@return ApiAssociateLineExtensionRequest
	*/
	AssociateLineExtension(ctx context.Context, lineId int32, extensionId int32) ApiAssociateLineExtensionRequest

	// AssociateLineExtensionExecute executes the request
	AssociateLineExtensionExecute(r ApiAssociateLineExtensionRequest) (*http.Response, error)

	/*
		AssociateUserLine Associate user and line

		**Required ACL:** `confd.users.{user_id}.lines.{line_id}.update`

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param userId the user's ID or UUID
		@param lineId
		@return ApiAssociateUserLineRequest
	*/
	AssociateUserLine(ctx context.Context, userId string, lineId int32) ApiAssociateUserLineRequest

	// AssociateUserLineExecute executes the request
	AssociateUserLineExecute(r ApiAssociateUserLineRequest) (*http.Response, error)

	/*
		AssociateUserLines Associate user and lines

		**Required ACL:** `confd.users.{user_id}.lines.update`

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param userId the user's ID or UUID
		@return ApiAssociateUserLinesRequest
	*/
	AssociateUserLines(ctx context.Context, userId string) ApiAssociateUserLinesRequest

	// AssociateUserLinesExecute executes the request
	AssociateUserLinesExecute(r ApiAssociateUserLinesRequest) (*http.Response, error)

	/*
		CreateLine Create line

		**Required ACL:** `confd.lines.create`

	When creating a line with an extension or a SIP endpoint as part of it's body, the line's context
	will be used as a default for the endpoint and context if ommited.


		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@return ApiCreateLineRequest
	*/
	CreateLine(ctx context.Context) ApiCreateLineRequest

	// CreateLineExecute executes the request
	//  @return LineView
	CreateLineExecute(r ApiCreateLineRequest) (*LineView, *http.Response, error)

	/*
		CreateLineExtension Create extension

		**Required ACL:** `confd.lines.{line_id}.extensions.create`
	The extension number must be included in one of the extension ranges for the given context.

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param lineId
		@return ApiCreateLineExtensionRequest
	*/
	CreateLineExtension(ctx context.Context, lineId int32) ApiCreateLineExtensionRequest

	// CreateLineExtensionExecute executes the request
	//  @return Extension
	CreateLineExtensionExecute(r ApiCreateLineExtensionRequest) (*Extension, *http.Response, error)

	/*
		DeleteLine Delete line

		**Required ACL:** `confd.lines.{line_id}.delete`

	**Disclaimer**: if `recursive=true`, the line is deleted, all their associations with any related resources are removed.

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param lineId
		@return ApiDeleteLineRequest
	*/
	DeleteLine(ctx context.Context, lineId int32) ApiDeleteLineRequest

	// DeleteLineExecute executes the request
	DeleteLineExecute(r ApiDeleteLineRequest) (*http.Response, error)

	/*
		DissociateLineApplication Dissociate line and application

		**Required ACL:** `confd.lines.{line_id}.applications.{application_uuid}.delete`

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param lineId
		@param applicationUuid Application's UUID
		@return ApiDissociateLineApplicationRequest
	*/
	DissociateLineApplication(ctx context.Context, lineId int32, applicationUuid int32) ApiDissociateLineApplicationRequest

	// DissociateLineApplicationExecute executes the request
	DissociateLineApplicationExecute(r ApiDissociateLineApplicationRequest) (*http.Response, error)

	/*
		DissociateLineDevice Dissociate line and device

		**Required ACL:** `confd.lines.{line_id}.devices.{device_id}.delete`

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param lineId
		@param deviceId Device's ID
		@return ApiDissociateLineDeviceRequest
	*/
	DissociateLineDevice(ctx context.Context, lineId int32, deviceId string) ApiDissociateLineDeviceRequest

	// DissociateLineDeviceExecute executes the request
	DissociateLineDeviceExecute(r ApiDissociateLineDeviceRequest) (*http.Response, error)

	/*
		DissociateLineEndpointCustom Dissociate line and Custom endpoint

		**Required ACL:** `confd.lines.{line_id}.endpoints.custom.{custom_id}.delete`

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param lineId
		@param customId
		@return ApiDissociateLineEndpointCustomRequest
	*/
	DissociateLineEndpointCustom(ctx context.Context, lineId int32, customId int32) ApiDissociateLineEndpointCustomRequest

	// DissociateLineEndpointCustomExecute executes the request
	DissociateLineEndpointCustomExecute(r ApiDissociateLineEndpointCustomRequest) (*http.Response, error)

	/*
		DissociateLineEndpointSccp Dissociate line and SCCP endpoint

		**Required ACL:** `confd.lines.{line_id}.endpoints.sccp.{sccp_id}.delete`

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param lineId
		@param sccpId
		@return ApiDissociateLineEndpointSccpRequest
	*/
	DissociateLineEndpointSccp(ctx context.Context, lineId int32, sccpId int32) ApiDissociateLineEndpointSccpRequest

	// DissociateLineEndpointSccpExecute executes the request
	DissociateLineEndpointSccpExecute(r ApiDissociateLineEndpointSccpRequest) (*http.Response, error)

	/*
		DissociateLineEndpointSip Dissociate line and SIP endpoint

		**Required ACL:** `confd.lines.{line_id}.endpoints.sip.{sip_uuid}.delete`

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param lineId
		@param sipUuid
		@return ApiDissociateLineEndpointSipRequest
	*/
	DissociateLineEndpointSip(ctx context.Context, lineId int32, sipUuid string) ApiDissociateLineEndpointSipRequest

	// DissociateLineEndpointSipExecute executes the request
	DissociateLineEndpointSipExecute(r ApiDissociateLineEndpointSipRequest) (*http.Response, error)

	/*
		DissociateLineExtension Dissociate line and extension

		**Required ACL:** `confd.lines.{line_id}.extensions.{extension_id}.delete`

	Any devices that are attached to a line must be removed before dissociating an extension from its line. A device can be dissociated by resetting it to autoprov mode.

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param lineId
		@param extensionId
		@return ApiDissociateLineExtensionRequest
	*/
	DissociateLineExtension(ctx context.Context, lineId int32, extensionId int32) ApiDissociateLineExtensionRequest

	// DissociateLineExtensionExecute executes the request
	DissociateLineExtensionExecute(r ApiDissociateLineExtensionRequest) (*http.Response, error)

	/*
		DissociateUserLine Dissociate user and line

		**Required ACL:** `confd.users.{user_id}.lines.{line_id}.delete`

	Any devices that are attached the line must be removed before dissociating a user from its line. A device can be dissociated be resetting it to autoprov mode.

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param userId the user's ID or UUID
		@param lineId
		@return ApiDissociateUserLineRequest
	*/
	DissociateUserLine(ctx context.Context, userId string, lineId int32) ApiDissociateUserLineRequest

	// DissociateUserLineExecute executes the request
	DissociateUserLineExecute(r ApiDissociateUserLineRequest) (*http.Response, error)

	/*
		GetDeviceLineAssociation List lines associated to device

		**Required ACL:** `confd.devices.{device_id}.lines.read`

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param deviceId Device's ID
		@return ApiGetDeviceLineAssociationRequest
	*/
	GetDeviceLineAssociation(ctx context.Context, deviceId string) ApiGetDeviceLineAssociationRequest

	// GetDeviceLineAssociationExecute executes the request
	//  @return LineDeviceItems
	GetDeviceLineAssociationExecute(r ApiGetDeviceLineAssociationRequest) (*LineDeviceItems, *http.Response, error)

	/*
		GetLine Get line

		**Required ACL:** `confd.lines.{line_id}.read`

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param lineId
		@return ApiGetLineRequest
	*/
	GetLine(ctx context.Context, lineId int32) ApiGetLineRequest

	// GetLineExecute executes the request
	//  @return LineView
	GetLineExecute(r ApiGetLineRequest) (*LineView, *http.Response, error)

	/*
		GetLineDevice Get Device associated to Line

		**Required ACL:** `confd.lines.{line_id}.devices.read`

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param lineId
		@return ApiGetLineDeviceRequest
	*/
	GetLineDevice(ctx context.Context, lineId int32) ApiGetLineDeviceRequest

	// GetLineDeviceExecute executes the request
	//  @return LineDevice
	GetLineDeviceExecute(r ApiGetLineDeviceRequest) (*LineDevice, *http.Response, error)

	/*
		GetUserLineAssociatedEndpointsSip Get SIP endpoint of a line for a user

		**Required ACL:** `confd.users.{user_uuid}.lines.{line_id}.associated.endpoints.sip.read`

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param userUuid the user's UUID
		@param lineId
		@return ApiGetUserLineAssociatedEndpointsSipRequest
	*/
	GetUserLineAssociatedEndpointsSip(ctx context.Context, userUuid string, lineId int32) ApiGetUserLineAssociatedEndpointsSipRequest

	// GetUserLineAssociatedEndpointsSipExecute executes the request
	//  @return EndpointSIP
	GetUserLineAssociatedEndpointsSipExecute(r ApiGetUserLineAssociatedEndpointsSipRequest) (*EndpointSIP, *http.Response, error)

	/*
		GetUserLineMainAssociatedEndpointsSip Get SIP endpoint of main line for a user

		**Required ACL:** `confd.users.{user_uuid}.lines.main.associated.endpoints.sip.read`

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param userUuid the user's UUID
		@return ApiGetUserLineMainAssociatedEndpointsSipRequest
	*/
	GetUserLineMainAssociatedEndpointsSip(ctx context.Context, userUuid string) ApiGetUserLineMainAssociatedEndpointsSipRequest

	// GetUserLineMainAssociatedEndpointsSipExecute executes the request
	//  @return EndpointSIP
	GetUserLineMainAssociatedEndpointsSipExecute(r ApiGetUserLineMainAssociatedEndpointsSipRequest) (*EndpointSIP, *http.Response, error)

	/*
		ListLines List lines

		**Required ACL:** `confd.lines.read`

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@return ApiListLinesRequest
	*/
	ListLines(ctx context.Context) ApiListLinesRequest

	// ListLinesExecute executes the request
	//  @return LineItems
	ListLinesExecute(r ApiListLinesRequest) (*LineItems, *http.Response, error)

	/*
		UpdateLine Update line

		**Required ACL:** `confd.lines.{line_id}.update`

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param lineId
		@return ApiUpdateLineRequest
	*/
	UpdateLine(ctx context.Context, lineId int32) ApiUpdateLineRequest

	// UpdateLineExecute executes the request
	UpdateLineExecute(r ApiUpdateLineRequest) (*http.Response, error)
}

// LinesAPIService LinesAPI service
type LinesAPIService service

type ApiAssociateLineApplicationRequest struct {
	ctx             context.Context
	ApiService      LinesAPI
	lineId          int32
	applicationUuid int32
	accentTenant    *string
}

// The tenant&#39;s UUID, defining the ownership of a given resource.
func (r ApiAssociateLineApplicationRequest) AccentTenant(accentTenant string) ApiAssociateLineApplicationRequest {
	r.accentTenant = &accentTenant
	return r
}

func (r ApiAssociateLineApplicationRequest) Execute() (*http.Response, error) {
	return r.ApiService.AssociateLineApplicationExecute(r)
}

/*
AssociateLineApplication Associate line and application

'**Required ACL:** `confd.lines.{line_id}.applications.{application_uuid}.update`'

**WARNING**: Association will disable the effect of the line `context` field

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param lineId
	@param applicationUuid Application's UUID
	@return ApiAssociateLineApplicationRequest
*/
func (a *LinesAPIService) AssociateLineApplication(ctx context.Context, lineId int32, applicationUuid int32) ApiAssociateLineApplicationRequest {
	return ApiAssociateLineApplicationRequest{
		ApiService:      a,
		ctx:             ctx,
		lineId:          lineId,
		applicationUuid: applicationUuid,
	}
}

// Execute executes the request
func (a *LinesAPIService) AssociateLineApplicationExecute(r ApiAssociateLineApplicationRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodPut
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LinesAPIService.AssociateLineApplication")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/lines/{line_id}/applications/{application_uuid}"
	localVarPath = strings.Replace(localVarPath, "{"+"line_id"+"}", url.PathEscape(parameterValueToString(r.lineId, "lineId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"application_uuid"+"}", url.PathEscape(parameterValueToString(r.applicationUuid, "applicationUuid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.accentTenant != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accent-Tenant", r.accentTenant, "")
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["accent_auth_token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Auth-Token"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v []string
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v []string
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiAssociateLineDeviceRequest struct {
	ctx          context.Context
	ApiService   LinesAPI
	lineId       int32
	deviceId     string
	accentTenant *string
}

// The tenant&#39;s UUID, defining the ownership of a given resource.
func (r ApiAssociateLineDeviceRequest) AccentTenant(accentTenant string) ApiAssociateLineDeviceRequest {
	r.accentTenant = &accentTenant
	return r
}

func (r ApiAssociateLineDeviceRequest) Execute() (*http.Response, error) {
	return r.ApiService.AssociateLineDeviceExecute(r)
}

/*
AssociateLineDevice Associate line and device

**Required ACL:** `confd.lines.{line_id}.devices.{device_id}.update`

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param lineId
	@param deviceId Device's ID
	@return ApiAssociateLineDeviceRequest
*/
func (a *LinesAPIService) AssociateLineDevice(ctx context.Context, lineId int32, deviceId string) ApiAssociateLineDeviceRequest {
	return ApiAssociateLineDeviceRequest{
		ApiService: a,
		ctx:        ctx,
		lineId:     lineId,
		deviceId:   deviceId,
	}
}

// Execute executes the request
func (a *LinesAPIService) AssociateLineDeviceExecute(r ApiAssociateLineDeviceRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodPut
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LinesAPIService.AssociateLineDevice")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/lines/{line_id}/devices/{device_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"line_id"+"}", url.PathEscape(parameterValueToString(r.lineId, "lineId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"device_id"+"}", url.PathEscape(parameterValueToString(r.deviceId, "deviceId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.accentTenant != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accent-Tenant", r.accentTenant, "")
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["accent_auth_token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Auth-Token"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v []string
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v []string
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiAssociateLineEndpointCustomRequest struct {
	ctx        context.Context
	ApiService LinesAPI
	lineId     int32
	customId   int32
}

func (r ApiAssociateLineEndpointCustomRequest) Execute() (*http.Response, error) {
	return r.ApiService.AssociateLineEndpointCustomExecute(r)
}

/*
AssociateLineEndpointCustom Associate line and Custom endpoint

**Required ACL:** `confd.lines.{line_id}.endpoints.custom.{custom_id}.update`

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param lineId
	@param customId
	@return ApiAssociateLineEndpointCustomRequest
*/
func (a *LinesAPIService) AssociateLineEndpointCustom(ctx context.Context, lineId int32, customId int32) ApiAssociateLineEndpointCustomRequest {
	return ApiAssociateLineEndpointCustomRequest{
		ApiService: a,
		ctx:        ctx,
		lineId:     lineId,
		customId:   customId,
	}
}

// Execute executes the request
func (a *LinesAPIService) AssociateLineEndpointCustomExecute(r ApiAssociateLineEndpointCustomRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodPut
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LinesAPIService.AssociateLineEndpointCustom")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/lines/{line_id}/endpoints/custom/{custom_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"line_id"+"}", url.PathEscape(parameterValueToString(r.lineId, "lineId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"custom_id"+"}", url.PathEscape(parameterValueToString(r.customId, "customId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["accent_auth_token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Auth-Token"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v []string
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v []string
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiAssociateLineEndpointSccpRequest struct {
	ctx        context.Context
	ApiService LinesAPI
	lineId     int32
	sccpId     int32
}

func (r ApiAssociateLineEndpointSccpRequest) Execute() (*http.Response, error) {
	return r.ApiService.AssociateLineEndpointSccpExecute(r)
}

/*
AssociateLineEndpointSccp Associate line and SCCP endpoint

**Required ACL:** `confd.lines.{line_id}.endpoints.sccp.{sccp_id}.update`

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param lineId
	@param sccpId
	@return ApiAssociateLineEndpointSccpRequest
*/
func (a *LinesAPIService) AssociateLineEndpointSccp(ctx context.Context, lineId int32, sccpId int32) ApiAssociateLineEndpointSccpRequest {
	return ApiAssociateLineEndpointSccpRequest{
		ApiService: a,
		ctx:        ctx,
		lineId:     lineId,
		sccpId:     sccpId,
	}
}

// Execute executes the request
func (a *LinesAPIService) AssociateLineEndpointSccpExecute(r ApiAssociateLineEndpointSccpRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodPut
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LinesAPIService.AssociateLineEndpointSccp")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/lines/{line_id}/endpoints/sccp/{sccp_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"line_id"+"}", url.PathEscape(parameterValueToString(r.lineId, "lineId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"sccp_id"+"}", url.PathEscape(parameterValueToString(r.sccpId, "sccpId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["accent_auth_token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Auth-Token"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v []string
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v []string
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiAssociateLineEndpointSipRequest struct {
	ctx        context.Context
	ApiService LinesAPI
	lineId     int32
	sipUuid    string
}

func (r ApiAssociateLineEndpointSipRequest) Execute() (*http.Response, error) {
	return r.ApiService.AssociateLineEndpointSipExecute(r)
}

/*
AssociateLineEndpointSip Associate line and SIP endpoint

**Required ACL:** `confd.lines.{line_id}.endpoints.sip.{sip_uuid}.update`

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param lineId
	@param sipUuid
	@return ApiAssociateLineEndpointSipRequest
*/
func (a *LinesAPIService) AssociateLineEndpointSip(ctx context.Context, lineId int32, sipUuid string) ApiAssociateLineEndpointSipRequest {
	return ApiAssociateLineEndpointSipRequest{
		ApiService: a,
		ctx:        ctx,
		lineId:     lineId,
		sipUuid:    sipUuid,
	}
}

// Execute executes the request
func (a *LinesAPIService) AssociateLineEndpointSipExecute(r ApiAssociateLineEndpointSipRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodPut
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LinesAPIService.AssociateLineEndpointSip")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/lines/{line_id}/endpoints/sip/{sip_uuid}"
	localVarPath = strings.Replace(localVarPath, "{"+"line_id"+"}", url.PathEscape(parameterValueToString(r.lineId, "lineId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"sip_uuid"+"}", url.PathEscape(parameterValueToString(r.sipUuid, "sipUuid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["accent_auth_token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Auth-Token"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v []string
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v []string
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiAssociateLineExtensionRequest struct {
	ctx         context.Context
	ApiService  LinesAPI
	lineId      int32
	extensionId int32
}

func (r ApiAssociateLineExtensionRequest) Execute() (*http.Response, error) {
	return r.ApiService.AssociateLineExtensionExecute(r)
}

/*
AssociateLineExtension Associate line and extension

**Required ACL:** `confd.lines.{line_id}.extensions.{extension_id}.update`

Because of technical limitations, a line can only have a single ‘internal’ extension associated (i.e. an extension with a context of type ‘internal’)

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param lineId
	@param extensionId
	@return ApiAssociateLineExtensionRequest
*/
func (a *LinesAPIService) AssociateLineExtension(ctx context.Context, lineId int32, extensionId int32) ApiAssociateLineExtensionRequest {
	return ApiAssociateLineExtensionRequest{
		ApiService:  a,
		ctx:         ctx,
		lineId:      lineId,
		extensionId: extensionId,
	}
}

// Execute executes the request
func (a *LinesAPIService) AssociateLineExtensionExecute(r ApiAssociateLineExtensionRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodPut
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LinesAPIService.AssociateLineExtension")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/lines/{line_id}/extensions/{extension_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"line_id"+"}", url.PathEscape(parameterValueToString(r.lineId, "lineId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"extension_id"+"}", url.PathEscape(parameterValueToString(r.extensionId, "extensionId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["accent_auth_token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Auth-Token"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v []string
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v []string
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiAssociateUserLineRequest struct {
	ctx        context.Context
	ApiService LinesAPI
	userId     string
	lineId     int32
}

func (r ApiAssociateUserLineRequest) Execute() (*http.Response, error) {
	return r.ApiService.AssociateUserLineExecute(r)
}

/*
AssociateUserLine Associate user and line

**Required ACL:** `confd.users.{user_id}.lines.{line_id}.update`

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param userId the user's ID or UUID
	@param lineId
	@return ApiAssociateUserLineRequest
*/
func (a *LinesAPIService) AssociateUserLine(ctx context.Context, userId string, lineId int32) ApiAssociateUserLineRequest {
	return ApiAssociateUserLineRequest{
		ApiService: a,
		ctx:        ctx,
		userId:     userId,
		lineId:     lineId,
	}
}

// Execute executes the request
func (a *LinesAPIService) AssociateUserLineExecute(r ApiAssociateUserLineRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodPut
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LinesAPIService.AssociateUserLine")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/{user_id}/lines/{line_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"user_id"+"}", url.PathEscape(parameterValueToString(r.userId, "userId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"line_id"+"}", url.PathEscape(parameterValueToString(r.lineId, "lineId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["accent_auth_token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Auth-Token"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v []string
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v []string
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiAssociateUserLinesRequest struct {
	ctx        context.Context
	ApiService LinesAPI
	body       *LinesID
	userId     string
}

func (r ApiAssociateUserLinesRequest) Body(body LinesID) ApiAssociateUserLinesRequest {
	r.body = &body
	return r
}

func (r ApiAssociateUserLinesRequest) Execute() (*http.Response, error) {
	return r.ApiService.AssociateUserLinesExecute(r)
}

/*
AssociateUserLines Associate user and lines

**Required ACL:** `confd.users.{user_id}.lines.update`

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param userId the user's ID or UUID
	@return ApiAssociateUserLinesRequest
*/
func (a *LinesAPIService) AssociateUserLines(ctx context.Context, userId string) ApiAssociateUserLinesRequest {
	return ApiAssociateUserLinesRequest{
		ApiService: a,
		ctx:        ctx,
		userId:     userId,
	}
}

// Execute executes the request
func (a *LinesAPIService) AssociateUserLinesExecute(r ApiAssociateUserLinesRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodPut
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LinesAPIService.AssociateUserLines")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/{user_id}/lines"
	localVarPath = strings.Replace(localVarPath, "{"+"user_id"+"}", url.PathEscape(parameterValueToString(r.userId, "userId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return nil, reportError("body is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["accent_auth_token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Auth-Token"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v []string
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v []string
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiCreateLineRequest struct {
	ctx          context.Context
	ApiService   LinesAPI
	body         *LineCreate
	accentTenant *string
}

func (r ApiCreateLineRequest) Body(body LineCreate) ApiCreateLineRequest {
	r.body = &body
	return r
}

// The tenant&#39;s UUID, defining the ownership of a given resource.
func (r ApiCreateLineRequest) AccentTenant(accentTenant string) ApiCreateLineRequest {
	r.accentTenant = &accentTenant
	return r
}

func (r ApiCreateLineRequest) Execute() (*LineView, *http.Response, error) {
	return r.ApiService.CreateLineExecute(r)
}

/*
CreateLine Create line

**Required ACL:** `confd.lines.create`

When creating a line with an extension or a SIP endpoint as part of it's body, the line's context
will be used as a default for the endpoint and context if ommited.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiCreateLineRequest
*/
func (a *LinesAPIService) CreateLine(ctx context.Context) ApiCreateLineRequest {
	return ApiCreateLineRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return LineView
func (a *LinesAPIService) CreateLineExecute(r ApiCreateLineRequest) (*LineView, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *LineView
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LinesAPIService.CreateLine")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/lines"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("body is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.accentTenant != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accent-Tenant", r.accentTenant, "")
	}
	// body params
	localVarPostBody = r.body
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["accent_auth_token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Auth-Token"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v []string
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCreateLineExtensionRequest struct {
	ctx          context.Context
	ApiService   LinesAPI
	body         *Extension
	lineId       int32
	accentTenant *string
}

// Extension to create
func (r ApiCreateLineExtensionRequest) Body(body Extension) ApiCreateLineExtensionRequest {
	r.body = &body
	return r
}

// The tenant&#39;s UUID, defining the ownership of a given resource.
func (r ApiCreateLineExtensionRequest) AccentTenant(accentTenant string) ApiCreateLineExtensionRequest {
	r.accentTenant = &accentTenant
	return r
}

func (r ApiCreateLineExtensionRequest) Execute() (*Extension, *http.Response, error) {
	return r.ApiService.CreateLineExtensionExecute(r)
}

/*
CreateLineExtension Create extension

**Required ACL:** `confd.lines.{line_id}.extensions.create`
The extension number must be included in one of the extension ranges for the given context.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param lineId
	@return ApiCreateLineExtensionRequest
*/
func (a *LinesAPIService) CreateLineExtension(ctx context.Context, lineId int32) ApiCreateLineExtensionRequest {
	return ApiCreateLineExtensionRequest{
		ApiService: a,
		ctx:        ctx,
		lineId:     lineId,
	}
}

// Execute executes the request
//
//	@return Extension
func (a *LinesAPIService) CreateLineExtensionExecute(r ApiCreateLineExtensionRequest) (*Extension, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *Extension
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LinesAPIService.CreateLineExtension")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/lines/{line_id}/extensions"
	localVarPath = strings.Replace(localVarPath, "{"+"line_id"+"}", url.PathEscape(parameterValueToString(r.lineId, "lineId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("body is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.accentTenant != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accent-Tenant", r.accentTenant, "")
	}
	// body params
	localVarPostBody = r.body
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["accent_auth_token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Auth-Token"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v []string
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v Object
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDeleteLineRequest struct {
	ctx          context.Context
	ApiService   LinesAPI
	lineId       int32
	accentTenant *string
}

// The tenant&#39;s UUID, defining the ownership of a given resource.
func (r ApiDeleteLineRequest) AccentTenant(accentTenant string) ApiDeleteLineRequest {
	r.accentTenant = &accentTenant
	return r
}

func (r ApiDeleteLineRequest) Execute() (*http.Response, error) {
	return r.ApiService.DeleteLineExecute(r)
}

/*
DeleteLine Delete line

**Required ACL:** `confd.lines.{line_id}.delete`

**Disclaimer**: if `recursive=true`, the line is deleted, all their associations with any related resources are removed.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param lineId
	@return ApiDeleteLineRequest
*/
func (a *LinesAPIService) DeleteLine(ctx context.Context, lineId int32) ApiDeleteLineRequest {
	return ApiDeleteLineRequest{
		ApiService: a,
		ctx:        ctx,
		lineId:     lineId,
	}
}

// Execute executes the request
func (a *LinesAPIService) DeleteLineExecute(r ApiDeleteLineRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodDelete
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LinesAPIService.DeleteLine")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/lines/{line_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"line_id"+"}", url.PathEscape(parameterValueToString(r.lineId, "lineId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.accentTenant != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accent-Tenant", r.accentTenant, "")
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["accent_auth_token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Auth-Token"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v []string
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiDissociateLineApplicationRequest struct {
	ctx             context.Context
	ApiService      LinesAPI
	lineId          int32
	applicationUuid int32
	accentTenant    *string
}

// The tenant&#39;s UUID, defining the ownership of a given resource.
func (r ApiDissociateLineApplicationRequest) AccentTenant(accentTenant string) ApiDissociateLineApplicationRequest {
	r.accentTenant = &accentTenant
	return r
}

func (r ApiDissociateLineApplicationRequest) Execute() (*http.Response, error) {
	return r.ApiService.DissociateLineApplicationExecute(r)
}

/*
DissociateLineApplication Dissociate line and application

**Required ACL:** `confd.lines.{line_id}.applications.{application_uuid}.delete`

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param lineId
	@param applicationUuid Application's UUID
	@return ApiDissociateLineApplicationRequest
*/
func (a *LinesAPIService) DissociateLineApplication(ctx context.Context, lineId int32, applicationUuid int32) ApiDissociateLineApplicationRequest {
	return ApiDissociateLineApplicationRequest{
		ApiService:      a,
		ctx:             ctx,
		lineId:          lineId,
		applicationUuid: applicationUuid,
	}
}

// Execute executes the request
func (a *LinesAPIService) DissociateLineApplicationExecute(r ApiDissociateLineApplicationRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodDelete
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LinesAPIService.DissociateLineApplication")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/lines/{line_id}/applications/{application_uuid}"
	localVarPath = strings.Replace(localVarPath, "{"+"line_id"+"}", url.PathEscape(parameterValueToString(r.lineId, "lineId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"application_uuid"+"}", url.PathEscape(parameterValueToString(r.applicationUuid, "applicationUuid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.accentTenant != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accent-Tenant", r.accentTenant, "")
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["accent_auth_token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Auth-Token"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v []string
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v []string
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiDissociateLineDeviceRequest struct {
	ctx          context.Context
	ApiService   LinesAPI
	lineId       int32
	deviceId     string
	accentTenant *string
}

// The tenant&#39;s UUID, defining the ownership of a given resource.
func (r ApiDissociateLineDeviceRequest) AccentTenant(accentTenant string) ApiDissociateLineDeviceRequest {
	r.accentTenant = &accentTenant
	return r
}

func (r ApiDissociateLineDeviceRequest) Execute() (*http.Response, error) {
	return r.ApiService.DissociateLineDeviceExecute(r)
}

/*
DissociateLineDevice Dissociate line and device

**Required ACL:** `confd.lines.{line_id}.devices.{device_id}.delete`

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param lineId
	@param deviceId Device's ID
	@return ApiDissociateLineDeviceRequest
*/
func (a *LinesAPIService) DissociateLineDevice(ctx context.Context, lineId int32, deviceId string) ApiDissociateLineDeviceRequest {
	return ApiDissociateLineDeviceRequest{
		ApiService: a,
		ctx:        ctx,
		lineId:     lineId,
		deviceId:   deviceId,
	}
}

// Execute executes the request
func (a *LinesAPIService) DissociateLineDeviceExecute(r ApiDissociateLineDeviceRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodDelete
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LinesAPIService.DissociateLineDevice")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/lines/{line_id}/devices/{device_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"line_id"+"}", url.PathEscape(parameterValueToString(r.lineId, "lineId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"device_id"+"}", url.PathEscape(parameterValueToString(r.deviceId, "deviceId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.accentTenant != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accent-Tenant", r.accentTenant, "")
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["accent_auth_token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Auth-Token"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v []string
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v []string
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiDissociateLineEndpointCustomRequest struct {
	ctx        context.Context
	ApiService LinesAPI
	lineId     int32
	customId   int32
}

func (r ApiDissociateLineEndpointCustomRequest) Execute() (*http.Response, error) {
	return r.ApiService.DissociateLineEndpointCustomExecute(r)
}

/*
DissociateLineEndpointCustom Dissociate line and Custom endpoint

**Required ACL:** `confd.lines.{line_id}.endpoints.custom.{custom_id}.delete`

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param lineId
	@param customId
	@return ApiDissociateLineEndpointCustomRequest
*/
func (a *LinesAPIService) DissociateLineEndpointCustom(ctx context.Context, lineId int32, customId int32) ApiDissociateLineEndpointCustomRequest {
	return ApiDissociateLineEndpointCustomRequest{
		ApiService: a,
		ctx:        ctx,
		lineId:     lineId,
		customId:   customId,
	}
}

// Execute executes the request
func (a *LinesAPIService) DissociateLineEndpointCustomExecute(r ApiDissociateLineEndpointCustomRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodDelete
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LinesAPIService.DissociateLineEndpointCustom")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/lines/{line_id}/endpoints/custom/{custom_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"line_id"+"}", url.PathEscape(parameterValueToString(r.lineId, "lineId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"custom_id"+"}", url.PathEscape(parameterValueToString(r.customId, "customId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["accent_auth_token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Auth-Token"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v []string
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v []string
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiDissociateLineEndpointSccpRequest struct {
	ctx        context.Context
	ApiService LinesAPI
	lineId     int32
	sccpId     int32
}

func (r ApiDissociateLineEndpointSccpRequest) Execute() (*http.Response, error) {
	return r.ApiService.DissociateLineEndpointSccpExecute(r)
}

/*
DissociateLineEndpointSccp Dissociate line and SCCP endpoint

**Required ACL:** `confd.lines.{line_id}.endpoints.sccp.{sccp_id}.delete`

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param lineId
	@param sccpId
	@return ApiDissociateLineEndpointSccpRequest
*/
func (a *LinesAPIService) DissociateLineEndpointSccp(ctx context.Context, lineId int32, sccpId int32) ApiDissociateLineEndpointSccpRequest {
	return ApiDissociateLineEndpointSccpRequest{
		ApiService: a,
		ctx:        ctx,
		lineId:     lineId,
		sccpId:     sccpId,
	}
}

// Execute executes the request
func (a *LinesAPIService) DissociateLineEndpointSccpExecute(r ApiDissociateLineEndpointSccpRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodDelete
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LinesAPIService.DissociateLineEndpointSccp")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/lines/{line_id}/endpoints/sccp/{sccp_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"line_id"+"}", url.PathEscape(parameterValueToString(r.lineId, "lineId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"sccp_id"+"}", url.PathEscape(parameterValueToString(r.sccpId, "sccpId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["accent_auth_token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Auth-Token"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v []string
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v []string
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiDissociateLineEndpointSipRequest struct {
	ctx        context.Context
	ApiService LinesAPI
	lineId     int32
	sipUuid    string
}

func (r ApiDissociateLineEndpointSipRequest) Execute() (*http.Response, error) {
	return r.ApiService.DissociateLineEndpointSipExecute(r)
}

/*
DissociateLineEndpointSip Dissociate line and SIP endpoint

**Required ACL:** `confd.lines.{line_id}.endpoints.sip.{sip_uuid}.delete`

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param lineId
	@param sipUuid
	@return ApiDissociateLineEndpointSipRequest
*/
func (a *LinesAPIService) DissociateLineEndpointSip(ctx context.Context, lineId int32, sipUuid string) ApiDissociateLineEndpointSipRequest {
	return ApiDissociateLineEndpointSipRequest{
		ApiService: a,
		ctx:        ctx,
		lineId:     lineId,
		sipUuid:    sipUuid,
	}
}

// Execute executes the request
func (a *LinesAPIService) DissociateLineEndpointSipExecute(r ApiDissociateLineEndpointSipRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodDelete
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LinesAPIService.DissociateLineEndpointSip")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/lines/{line_id}/endpoints/sip/{sip_uuid}"
	localVarPath = strings.Replace(localVarPath, "{"+"line_id"+"}", url.PathEscape(parameterValueToString(r.lineId, "lineId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"sip_uuid"+"}", url.PathEscape(parameterValueToString(r.sipUuid, "sipUuid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["accent_auth_token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Auth-Token"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v []string
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v []string
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiDissociateLineExtensionRequest struct {
	ctx         context.Context
	ApiService  LinesAPI
	lineId      int32
	extensionId int32
}

func (r ApiDissociateLineExtensionRequest) Execute() (*http.Response, error) {
	return r.ApiService.DissociateLineExtensionExecute(r)
}

/*
DissociateLineExtension Dissociate line and extension

**Required ACL:** `confd.lines.{line_id}.extensions.{extension_id}.delete`

Any devices that are attached to a line must be removed before dissociating an extension from its line. A device can be dissociated by resetting it to autoprov mode.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param lineId
	@param extensionId
	@return ApiDissociateLineExtensionRequest
*/
func (a *LinesAPIService) DissociateLineExtension(ctx context.Context, lineId int32, extensionId int32) ApiDissociateLineExtensionRequest {
	return ApiDissociateLineExtensionRequest{
		ApiService:  a,
		ctx:         ctx,
		lineId:      lineId,
		extensionId: extensionId,
	}
}

// Execute executes the request
func (a *LinesAPIService) DissociateLineExtensionExecute(r ApiDissociateLineExtensionRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodDelete
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LinesAPIService.DissociateLineExtension")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/lines/{line_id}/extensions/{extension_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"line_id"+"}", url.PathEscape(parameterValueToString(r.lineId, "lineId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"extension_id"+"}", url.PathEscape(parameterValueToString(r.extensionId, "extensionId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["accent_auth_token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Auth-Token"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v []string
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v []string
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiDissociateUserLineRequest struct {
	ctx        context.Context
	ApiService LinesAPI
	userId     string
	lineId     int32
}

func (r ApiDissociateUserLineRequest) Execute() (*http.Response, error) {
	return r.ApiService.DissociateUserLineExecute(r)
}

/*
DissociateUserLine Dissociate user and line

**Required ACL:** `confd.users.{user_id}.lines.{line_id}.delete`

Any devices that are attached the line must be removed before dissociating a user from its line. A device can be dissociated be resetting it to autoprov mode.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param userId the user's ID or UUID
	@param lineId
	@return ApiDissociateUserLineRequest
*/
func (a *LinesAPIService) DissociateUserLine(ctx context.Context, userId string, lineId int32) ApiDissociateUserLineRequest {
	return ApiDissociateUserLineRequest{
		ApiService: a,
		ctx:        ctx,
		userId:     userId,
		lineId:     lineId,
	}
}

// Execute executes the request
func (a *LinesAPIService) DissociateUserLineExecute(r ApiDissociateUserLineRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodDelete
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LinesAPIService.DissociateUserLine")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/{user_id}/lines/{line_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"user_id"+"}", url.PathEscape(parameterValueToString(r.userId, "userId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"line_id"+"}", url.PathEscape(parameterValueToString(r.lineId, "lineId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["accent_auth_token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Auth-Token"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v []string
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v []string
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiGetDeviceLineAssociationRequest struct {
	ctx          context.Context
	ApiService   LinesAPI
	deviceId     string
	accentTenant *string
}

// The tenant&#39;s UUID, defining the ownership of a given resource.
func (r ApiGetDeviceLineAssociationRequest) AccentTenant(accentTenant string) ApiGetDeviceLineAssociationRequest {
	r.accentTenant = &accentTenant
	return r
}

func (r ApiGetDeviceLineAssociationRequest) Execute() (*LineDeviceItems, *http.Response, error) {
	return r.ApiService.GetDeviceLineAssociationExecute(r)
}

/*
GetDeviceLineAssociation List lines associated to device

**Required ACL:** `confd.devices.{device_id}.lines.read`

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param deviceId Device's ID
	@return ApiGetDeviceLineAssociationRequest
*/
func (a *LinesAPIService) GetDeviceLineAssociation(ctx context.Context, deviceId string) ApiGetDeviceLineAssociationRequest {
	return ApiGetDeviceLineAssociationRequest{
		ApiService: a,
		ctx:        ctx,
		deviceId:   deviceId,
	}
}

// Execute executes the request
//
//	@return LineDeviceItems
func (a *LinesAPIService) GetDeviceLineAssociationExecute(r ApiGetDeviceLineAssociationRequest) (*LineDeviceItems, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *LineDeviceItems
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LinesAPIService.GetDeviceLineAssociation")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/devices/{device_id}/lines"
	localVarPath = strings.Replace(localVarPath, "{"+"device_id"+"}", url.PathEscape(parameterValueToString(r.deviceId, "deviceId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.accentTenant != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accent-Tenant", r.accentTenant, "")
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["accent_auth_token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Auth-Token"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v []string
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetLineRequest struct {
	ctx          context.Context
	ApiService   LinesAPI
	lineId       int32
	accentTenant *string
}

// The tenant&#39;s UUID, defining the ownership of a given resource.
func (r ApiGetLineRequest) AccentTenant(accentTenant string) ApiGetLineRequest {
	r.accentTenant = &accentTenant
	return r
}

func (r ApiGetLineRequest) Execute() (*LineView, *http.Response, error) {
	return r.ApiService.GetLineExecute(r)
}

/*
GetLine Get line

**Required ACL:** `confd.lines.{line_id}.read`

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param lineId
	@return ApiGetLineRequest
*/
func (a *LinesAPIService) GetLine(ctx context.Context, lineId int32) ApiGetLineRequest {
	return ApiGetLineRequest{
		ApiService: a,
		ctx:        ctx,
		lineId:     lineId,
	}
}

// Execute executes the request
//
//	@return LineView
func (a *LinesAPIService) GetLineExecute(r ApiGetLineRequest) (*LineView, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *LineView
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LinesAPIService.GetLine")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/lines/{line_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"line_id"+"}", url.PathEscape(parameterValueToString(r.lineId, "lineId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.accentTenant != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accent-Tenant", r.accentTenant, "")
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["accent_auth_token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Auth-Token"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v []string
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetLineDeviceRequest struct {
	ctx          context.Context
	ApiService   LinesAPI
	lineId       int32
	accentTenant *string
}

// The tenant&#39;s UUID, defining the ownership of a given resource.
func (r ApiGetLineDeviceRequest) AccentTenant(accentTenant string) ApiGetLineDeviceRequest {
	r.accentTenant = &accentTenant
	return r
}

func (r ApiGetLineDeviceRequest) Execute() (*LineDevice, *http.Response, error) {
	return r.ApiService.GetLineDeviceExecute(r)
}

/*
GetLineDevice Get Device associated to Line

**Required ACL:** `confd.lines.{line_id}.devices.read`

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param lineId
	@return ApiGetLineDeviceRequest
*/
func (a *LinesAPIService) GetLineDevice(ctx context.Context, lineId int32) ApiGetLineDeviceRequest {
	return ApiGetLineDeviceRequest{
		ApiService: a,
		ctx:        ctx,
		lineId:     lineId,
	}
}

// Execute executes the request
//
//	@return LineDevice
func (a *LinesAPIService) GetLineDeviceExecute(r ApiGetLineDeviceRequest) (*LineDevice, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *LineDevice
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LinesAPIService.GetLineDevice")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/lines/{line_id}/devices"
	localVarPath = strings.Replace(localVarPath, "{"+"line_id"+"}", url.PathEscape(parameterValueToString(r.lineId, "lineId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.accentTenant != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accent-Tenant", r.accentTenant, "")
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["accent_auth_token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Auth-Token"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v []string
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v []string
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetUserLineAssociatedEndpointsSipRequest struct {
	ctx        context.Context
	ApiService LinesAPI
	userUuid   string
	lineId     int32
	view       *string
}

// Different view of the SIP endpoint  The &#x60;default&#x60; view, when the argument is omitted, is to include only options that are defined on the specified endpoint.  The &#x60;merged&#x60; view includes all options from included templates.
func (r ApiGetUserLineAssociatedEndpointsSipRequest) View(view string) ApiGetUserLineAssociatedEndpointsSipRequest {
	r.view = &view
	return r
}

func (r ApiGetUserLineAssociatedEndpointsSipRequest) Execute() (*EndpointSIP, *http.Response, error) {
	return r.ApiService.GetUserLineAssociatedEndpointsSipExecute(r)
}

/*
GetUserLineAssociatedEndpointsSip Get SIP endpoint of a line for a user

**Required ACL:** `confd.users.{user_uuid}.lines.{line_id}.associated.endpoints.sip.read`

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param userUuid the user's UUID
	@param lineId
	@return ApiGetUserLineAssociatedEndpointsSipRequest
*/
func (a *LinesAPIService) GetUserLineAssociatedEndpointsSip(ctx context.Context, userUuid string, lineId int32) ApiGetUserLineAssociatedEndpointsSipRequest {
	return ApiGetUserLineAssociatedEndpointsSipRequest{
		ApiService: a,
		ctx:        ctx,
		userUuid:   userUuid,
		lineId:     lineId,
	}
}

// Execute executes the request
//
//	@return EndpointSIP
func (a *LinesAPIService) GetUserLineAssociatedEndpointsSipExecute(r ApiGetUserLineAssociatedEndpointsSipRequest) (*EndpointSIP, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *EndpointSIP
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LinesAPIService.GetUserLineAssociatedEndpointsSip")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/{user_uuid}/lines/{line_id}/associated/endpoints/sip"
	localVarPath = strings.Replace(localVarPath, "{"+"user_uuid"+"}", url.PathEscape(parameterValueToString(r.userUuid, "userUuid")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"line_id"+"}", url.PathEscape(parameterValueToString(r.lineId, "lineId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.view != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "view", r.view, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["accent_auth_token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Auth-Token"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetUserLineMainAssociatedEndpointsSipRequest struct {
	ctx        context.Context
	ApiService LinesAPI
	userUuid   string
	view       *string
}

// Different view of the SIP endpoint  The &#x60;default&#x60; view, when the argument is omitted, is to include only options that are defined on the specified endpoint.  The &#x60;merged&#x60; view includes all options from included templates.
func (r ApiGetUserLineMainAssociatedEndpointsSipRequest) View(view string) ApiGetUserLineMainAssociatedEndpointsSipRequest {
	r.view = &view
	return r
}

func (r ApiGetUserLineMainAssociatedEndpointsSipRequest) Execute() (*EndpointSIP, *http.Response, error) {
	return r.ApiService.GetUserLineMainAssociatedEndpointsSipExecute(r)
}

/*
GetUserLineMainAssociatedEndpointsSip Get SIP endpoint of main line for a user

**Required ACL:** `confd.users.{user_uuid}.lines.main.associated.endpoints.sip.read`

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param userUuid the user's UUID
	@return ApiGetUserLineMainAssociatedEndpointsSipRequest
*/
func (a *LinesAPIService) GetUserLineMainAssociatedEndpointsSip(ctx context.Context, userUuid string) ApiGetUserLineMainAssociatedEndpointsSipRequest {
	return ApiGetUserLineMainAssociatedEndpointsSipRequest{
		ApiService: a,
		ctx:        ctx,
		userUuid:   userUuid,
	}
}

// Execute executes the request
//
//	@return EndpointSIP
func (a *LinesAPIService) GetUserLineMainAssociatedEndpointsSipExecute(r ApiGetUserLineMainAssociatedEndpointsSipRequest) (*EndpointSIP, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *EndpointSIP
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LinesAPIService.GetUserLineMainAssociatedEndpointsSip")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/{user_uuid}/lines/main/associated/endpoints/sip"
	localVarPath = strings.Replace(localVarPath, "{"+"user_uuid"+"}", url.PathEscape(parameterValueToString(r.userUuid, "userUuid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.view != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "view", r.view, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["accent_auth_token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Auth-Token"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiListLinesRequest struct {
	ctx          context.Context
	ApiService   LinesAPI
	accentTenant *string
	recurse      *bool
	order        *string
	direction    *string
	limit        *int32
	offset       *int32
	search       *string
}

// The tenant&#39;s UUID, defining the ownership of a given resource.
func (r ApiListLinesRequest) AccentTenant(accentTenant string) ApiListLinesRequest {
	r.accentTenant = &accentTenant
	return r
}

// Should the query include sub-tenants
func (r ApiListLinesRequest) Recurse(recurse bool) ApiListLinesRequest {
	r.recurse = &recurse
	return r
}

// Name of the field to use for sorting the list of items returned.
func (r ApiListLinesRequest) Order(order string) ApiListLinesRequest {
	r.order = &order
	return r
}

// Sort list of items in &#39;asc&#39; (ascending) or &#39;desc&#39; (descending) order
func (r ApiListLinesRequest) Direction(direction string) ApiListLinesRequest {
	r.direction = &direction
	return r
}

// Maximum number of items to return in the list
func (r ApiListLinesRequest) Limit(limit int32) ApiListLinesRequest {
	r.limit = &limit
	return r
}

// Number of items to skip over in the list. Useful for pagination.
func (r ApiListLinesRequest) Offset(offset int32) ApiListLinesRequest {
	r.offset = &offset
	return r
}

// Search term for filtering a list of items. Only items with a field containing the search term will be returned.
func (r ApiListLinesRequest) Search(search string) ApiListLinesRequest {
	r.search = &search
	return r
}

func (r ApiListLinesRequest) Execute() (*LineItems, *http.Response, error) {
	return r.ApiService.ListLinesExecute(r)
}

/*
ListLines List lines

**Required ACL:** `confd.lines.read`

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiListLinesRequest
*/
func (a *LinesAPIService) ListLines(ctx context.Context) ApiListLinesRequest {
	return ApiListLinesRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return LineItems
func (a *LinesAPIService) ListLinesExecute(r ApiListLinesRequest) (*LineItems, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *LineItems
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LinesAPIService.ListLines")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/lines"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.recurse != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "recurse", r.recurse, "")
	} else {
		var defaultValue bool = false
		r.recurse = &defaultValue
	}
	if r.order != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "order", r.order, "")
	}
	if r.direction != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "direction", r.direction, "")
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "")
	}
	if r.offset != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "offset", r.offset, "")
	}
	if r.search != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "search", r.search, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.accentTenant != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accent-Tenant", r.accentTenant, "")
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["accent_auth_token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Auth-Token"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUpdateLineRequest struct {
	ctx          context.Context
	ApiService   LinesAPI
	body         *Line
	lineId       int32
	accentTenant *string
}

func (r ApiUpdateLineRequest) Body(body Line) ApiUpdateLineRequest {
	r.body = &body
	return r
}

// The tenant&#39;s UUID, defining the ownership of a given resource.
func (r ApiUpdateLineRequest) AccentTenant(accentTenant string) ApiUpdateLineRequest {
	r.accentTenant = &accentTenant
	return r
}

func (r ApiUpdateLineRequest) Execute() (*http.Response, error) {
	return r.ApiService.UpdateLineExecute(r)
}

/*
UpdateLine Update line

**Required ACL:** `confd.lines.{line_id}.update`

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param lineId
	@return ApiUpdateLineRequest
*/
func (a *LinesAPIService) UpdateLine(ctx context.Context, lineId int32) ApiUpdateLineRequest {
	return ApiUpdateLineRequest{
		ApiService: a,
		ctx:        ctx,
		lineId:     lineId,
	}
}

// Execute executes the request
func (a *LinesAPIService) UpdateLineExecute(r ApiUpdateLineRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodPut
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LinesAPIService.UpdateLine")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/lines/{line_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"line_id"+"}", url.PathEscape(parameterValueToString(r.lineId, "lineId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return nil, reportError("body is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.accentTenant != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accent-Tenant", r.accentTenant, "")
	}
	// body params
	localVarPostBody = r.body
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["accent_auth_token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Auth-Token"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v []string
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v []string
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

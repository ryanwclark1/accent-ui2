/*
accent-confd

Confd exposes an API for managing core resources on a Accent server such as users, extensions, devices, voicemails, queues, etc. Resources can be associated together to provide additional functionality. For example: By associating a voicemail with a user, calls will automatically fallback on to the voicemail when the user cannot answer.  Implementation notes ====================  Errors ------  Responses containing errors will have a status code in the 400 or 500 class. A list of error messages will be returned in the body of the response as a JSON-encoded array:  ~~~ [     \"Input error - User not found\",     \"Resource error - User not associated to a line\" ] ~~~   Updating resources via PUT --------------------------  When updating a resource, all fields become optional. In other words, only values that have been changed need to be sent to the server. Please note that this behavior may change in future versions of the API.

API version: 1.1
Contact: help@accentvoice.io
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package confd

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
)

type AsteriskAPI interface {

	/*
		ListAsteriskConfbridgeAccentDefaultBridge List ConfBridge accent_default_bridge options

		**Required ACL:** `confd.asterisk.confbridge.accent_default_bridge.read`

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@return AsteriskAPIListAsteriskConfbridgeAccentDefaultBridgeRequest
	*/
	ListAsteriskConfbridgeAccentDefaultBridge(ctx context.Context) AsteriskAPIListAsteriskConfbridgeAccentDefaultBridgeRequest

	// ListAsteriskConfbridgeAccentDefaultBridgeExecute executes the request
	//  @return ConfBridgeConfiguration
	ListAsteriskConfbridgeAccentDefaultBridgeExecute(r AsteriskAPIListAsteriskConfbridgeAccentDefaultBridgeRequest) (*ConfBridgeConfiguration, *http.Response, error)

	/*
		ListAsteriskConfbridgeAccentDefaultUser List ConfBridge accent_default_user options

		**Required ACL:** `confd.asterisk.confbridge.accent_default_user.read`

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@return AsteriskAPIListAsteriskConfbridgeAccentDefaultUserRequest
	*/
	ListAsteriskConfbridgeAccentDefaultUser(ctx context.Context) AsteriskAPIListAsteriskConfbridgeAccentDefaultUserRequest

	// ListAsteriskConfbridgeAccentDefaultUserExecute executes the request
	//  @return ConfBridgeConfiguration
	ListAsteriskConfbridgeAccentDefaultUserExecute(r AsteriskAPIListAsteriskConfbridgeAccentDefaultUserRequest) (*ConfBridgeConfiguration, *http.Response, error)

	/*
		ListAsteriskFeaturesApplicationmap List Features applicationmap options

		**Required ACL:** `confd.asterisk.features.applicationmap.read`

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@return AsteriskAPIListAsteriskFeaturesApplicationmapRequest
	*/
	ListAsteriskFeaturesApplicationmap(ctx context.Context) AsteriskAPIListAsteriskFeaturesApplicationmapRequest

	// ListAsteriskFeaturesApplicationmapExecute executes the request
	//  @return FeaturesConfiguration
	ListAsteriskFeaturesApplicationmapExecute(r AsteriskAPIListAsteriskFeaturesApplicationmapRequest) (*FeaturesConfiguration, *http.Response, error)

	/*
		ListAsteriskFeaturesFeaturemap List Features featuremap options

		**Required ACL:** `confd.asterisk.features.featuremap.read`

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@return AsteriskAPIListAsteriskFeaturesFeaturemapRequest
	*/
	ListAsteriskFeaturesFeaturemap(ctx context.Context) AsteriskAPIListAsteriskFeaturesFeaturemapRequest

	// ListAsteriskFeaturesFeaturemapExecute executes the request
	//  @return FeaturesConfiguration
	ListAsteriskFeaturesFeaturemapExecute(r AsteriskAPIListAsteriskFeaturesFeaturemapRequest) (*FeaturesConfiguration, *http.Response, error)

	/*
		ListAsteriskFeaturesGeneral List Features general options

		**Required ACL:** `confd.asterisk.features.general.read`

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@return AsteriskAPIListAsteriskFeaturesGeneralRequest
	*/
	ListAsteriskFeaturesGeneral(ctx context.Context) AsteriskAPIListAsteriskFeaturesGeneralRequest

	// ListAsteriskFeaturesGeneralExecute executes the request
	//  @return FeaturesConfiguration
	ListAsteriskFeaturesGeneralExecute(r AsteriskAPIListAsteriskFeaturesGeneralRequest) (*FeaturesConfiguration, *http.Response, error)

	/*
		ListAsteriskHepGeneral List HEP general options

		**Required ACL:** `confd.asterisk.hep.general.read`

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@return AsteriskAPIListAsteriskHepGeneralRequest
	*/
	ListAsteriskHepGeneral(ctx context.Context) AsteriskAPIListAsteriskHepGeneralRequest

	// ListAsteriskHepGeneralExecute executes the request
	//  @return HEPConfiguration
	ListAsteriskHepGeneralExecute(r AsteriskAPIListAsteriskHepGeneralRequest) (*HEPConfiguration, *http.Response, error)

	/*
		ListAsteriskIaxCallnumberlimits List IAX callnumberlimits options

		**Required ACL:** `confd.asterisk.iax.callnumberlimits.read`

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@return AsteriskAPIListAsteriskIaxCallnumberlimitsRequest
	*/
	ListAsteriskIaxCallnumberlimits(ctx context.Context) AsteriskAPIListAsteriskIaxCallnumberlimitsRequest

	// ListAsteriskIaxCallnumberlimitsExecute executes the request
	//  @return IAXCallNumberLimitss
	ListAsteriskIaxCallnumberlimitsExecute(r AsteriskAPIListAsteriskIaxCallnumberlimitsRequest) (*IAXCallNumberLimitss, *http.Response, error)

	/*
		ListAsteriskIaxGeneral List IAX general options

		**Required ACL:** `confd.asterisk.iax.general.read`

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@return AsteriskAPIListAsteriskIaxGeneralRequest
	*/
	ListAsteriskIaxGeneral(ctx context.Context) AsteriskAPIListAsteriskIaxGeneralRequest

	// ListAsteriskIaxGeneralExecute executes the request
	//  @return IAXGeneral
	ListAsteriskIaxGeneralExecute(r AsteriskAPIListAsteriskIaxGeneralRequest) (*IAXGeneral, *http.Response, error)

	/*
		ListAsteriskPjsipGlobal List of PJSIP options for the `global` section

		**Required ACL:** `confd.asterisk.pjsip.global.read`

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@return AsteriskAPIListAsteriskPjsipGlobalRequest
	*/
	ListAsteriskPjsipGlobal(ctx context.Context) AsteriskAPIListAsteriskPjsipGlobalRequest

	// ListAsteriskPjsipGlobalExecute executes the request
	//  @return PJSIPGlobal
	ListAsteriskPjsipGlobalExecute(r AsteriskAPIListAsteriskPjsipGlobalRequest) (*PJSIPGlobal, *http.Response, error)

	/*
		ListAsteriskPjsipSystem List of PJSIP options for the `system` section

		**Required ACL:** `confd.asterisk.pjsip.system.read`

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@return AsteriskAPIListAsteriskPjsipSystemRequest
	*/
	ListAsteriskPjsipSystem(ctx context.Context) AsteriskAPIListAsteriskPjsipSystemRequest

	// ListAsteriskPjsipSystemExecute executes the request
	//  @return PJSIPSystem
	ListAsteriskPjsipSystemExecute(r AsteriskAPIListAsteriskPjsipSystemRequest) (*PJSIPSystem, *http.Response, error)

	/*
		ListAsteriskQueueGeneral List Queue general options

		**Required ACL:** `confd.asterisk.queue.general.read`

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@return AsteriskAPIListAsteriskQueueGeneralRequest
	*/
	ListAsteriskQueueGeneral(ctx context.Context) AsteriskAPIListAsteriskQueueGeneralRequest

	// ListAsteriskQueueGeneralExecute executes the request
	//  @return QueueGeneral
	ListAsteriskQueueGeneralExecute(r AsteriskAPIListAsteriskQueueGeneralRequest) (*QueueGeneral, *http.Response, error)

	/*
		ListAsteriskRtpGeneral List RTP general options

		**Required ACL:** `confd.asterisk.rtp.general.read`

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@return AsteriskAPIListAsteriskRtpGeneralRequest
	*/
	ListAsteriskRtpGeneral(ctx context.Context) AsteriskAPIListAsteriskRtpGeneralRequest

	// ListAsteriskRtpGeneralExecute executes the request
	//  @return RTPConfiguration
	ListAsteriskRtpGeneralExecute(r AsteriskAPIListAsteriskRtpGeneralRequest) (*RTPConfiguration, *http.Response, error)

	/*
		ListAsteriskRtpIceHostCandidates List RTP ice_host_candidates options

		**Required ACL:** `confd.asterisk.rtp.ice_host_candidates.read`

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@return AsteriskAPIListAsteriskRtpIceHostCandidatesRequest
	*/
	ListAsteriskRtpIceHostCandidates(ctx context.Context) AsteriskAPIListAsteriskRtpIceHostCandidatesRequest

	// ListAsteriskRtpIceHostCandidatesExecute executes the request
	//  @return RTPConfiguration
	ListAsteriskRtpIceHostCandidatesExecute(r AsteriskAPIListAsteriskRtpIceHostCandidatesRequest) (*RTPConfiguration, *http.Response, error)

	/*
		ListAsteriskSccpGeneral List SCCP general options

		**Required ACL:** `confd.asterisk.sccp.general.read`

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@return AsteriskAPIListAsteriskSccpGeneralRequest
	*/
	ListAsteriskSccpGeneral(ctx context.Context) AsteriskAPIListAsteriskSccpGeneralRequest

	// ListAsteriskSccpGeneralExecute executes the request
	//  @return SCCPGeneral
	ListAsteriskSccpGeneralExecute(r AsteriskAPIListAsteriskSccpGeneralRequest) (*SCCPGeneral, *http.Response, error)

	/*
		ListAsteriskVoicemailGeneral List Voicemail general options

		**Required ACL:** `confd.asterisk.voicemail.general.read`

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@return AsteriskAPIListAsteriskVoicemailGeneralRequest
	*/
	ListAsteriskVoicemailGeneral(ctx context.Context) AsteriskAPIListAsteriskVoicemailGeneralRequest

	// ListAsteriskVoicemailGeneralExecute executes the request
	//  @return VoicemailGeneral
	ListAsteriskVoicemailGeneralExecute(r AsteriskAPIListAsteriskVoicemailGeneralRequest) (*VoicemailGeneral, *http.Response, error)

	/*
		ListAsteriskVoicemailZonemessages List Voicemail zonemessages options

		**Required ACL:** `confd.asterisk.voicemail.zonemessages.read`

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@return AsteriskAPIListAsteriskVoicemailZonemessagesRequest
	*/
	ListAsteriskVoicemailZonemessages(ctx context.Context) AsteriskAPIListAsteriskVoicemailZonemessagesRequest

	// ListAsteriskVoicemailZonemessagesExecute executes the request
	//  @return VoicemailZoneMessages
	ListAsteriskVoicemailZonemessagesExecute(r AsteriskAPIListAsteriskVoicemailZonemessagesRequest) (*VoicemailZoneMessages, *http.Response, error)

	/*
		ShowPjsipDoc List all PJSIP configuration options

		**Required ACL:**: `confd.asterisk.pjsip.doc.read` List all available configuration options for PJSIP, those values are used to validate to content of POST and PUT requests.

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@return AsteriskAPIShowPjsipDocRequest
	*/
	ShowPjsipDoc(ctx context.Context) AsteriskAPIShowPjsipDocRequest

	// ShowPjsipDocExecute executes the request
	//  @return PJSIPConfigurationOptions
	ShowPjsipDocExecute(r AsteriskAPIShowPjsipDocRequest) (*PJSIPConfigurationOptions, *http.Response, error)

	/*
		UpdateAsteriskConfbridgeAccentDefaultBridge Update ConfBridge accent_default_bridge option

		**Required ACL:** `confd.asterisk.confbridge.accent_default_bridge.update` **WARNING** This endpoint restore to default value or delete all fields that are not defined. All available configuration options are listed in the [sample](https://raw.githubusercontent.com/asterisk/asterisk/master/configs/samples/confbridge.conf.sample) Asterisk configuration file.

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@return AsteriskAPIUpdateAsteriskConfbridgeAccentDefaultBridgeRequest
	*/
	UpdateAsteriskConfbridgeAccentDefaultBridge(ctx context.Context) AsteriskAPIUpdateAsteriskConfbridgeAccentDefaultBridgeRequest

	// UpdateAsteriskConfbridgeAccentDefaultBridgeExecute executes the request
	UpdateAsteriskConfbridgeAccentDefaultBridgeExecute(r AsteriskAPIUpdateAsteriskConfbridgeAccentDefaultBridgeRequest) (*http.Response, error)

	/*
		UpdateAsteriskConfbridgeAccentDefaultUser Update ConfBridge accent_default_user option

		**Required ACL:** `confd.asterisk.confbridge.accent_default_user.update` **WARNING** This endpoint restore to default value or delete all fields that are not defined. All available configuration options are listed in the [sample](https://raw.githubusercontent.com/asterisk/asterisk/master/configs/samples/confbridge.conf.sample) Asterisk configuration file.

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@return AsteriskAPIUpdateAsteriskConfbridgeAccentDefaultUserRequest
	*/
	UpdateAsteriskConfbridgeAccentDefaultUser(ctx context.Context) AsteriskAPIUpdateAsteriskConfbridgeAccentDefaultUserRequest

	// UpdateAsteriskConfbridgeAccentDefaultUserExecute executes the request
	UpdateAsteriskConfbridgeAccentDefaultUserExecute(r AsteriskAPIUpdateAsteriskConfbridgeAccentDefaultUserRequest) (*http.Response, error)

	/*
		UpdateAsteriskFeaturesApplicationmap Update Features applicationmap option

		**Required ACL:** `confd.asterisk.features.applicationmap.update` **WARNING** This endpoint restore to default value or delete all fields that are not defined.

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@return AsteriskAPIUpdateAsteriskFeaturesApplicationmapRequest
	*/
	UpdateAsteriskFeaturesApplicationmap(ctx context.Context) AsteriskAPIUpdateAsteriskFeaturesApplicationmapRequest

	// UpdateAsteriskFeaturesApplicationmapExecute executes the request
	UpdateAsteriskFeaturesApplicationmapExecute(r AsteriskAPIUpdateAsteriskFeaturesApplicationmapRequest) (*http.Response, error)

	/*
		UpdateAsteriskFeaturesFeaturemap Update Features featuremap option

		**Required ACL:** `confd.asterisk.features.featuremap.update` **WARNING** This endpoint restore to default value or delete all fields that are not defined.

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@return AsteriskAPIUpdateAsteriskFeaturesFeaturemapRequest
	*/
	UpdateAsteriskFeaturesFeaturemap(ctx context.Context) AsteriskAPIUpdateAsteriskFeaturesFeaturemapRequest

	// UpdateAsteriskFeaturesFeaturemapExecute executes the request
	UpdateAsteriskFeaturesFeaturemapExecute(r AsteriskAPIUpdateAsteriskFeaturesFeaturemapRequest) (*http.Response, error)

	/*
		UpdateAsteriskFeaturesGeneral Update Features general option

		**Required ACL:** `confd.asterisk.features.general.update` **WARNING** This endpoint restore to default value or delete all fields that are not defined.

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@return AsteriskAPIUpdateAsteriskFeaturesGeneralRequest
	*/
	UpdateAsteriskFeaturesGeneral(ctx context.Context) AsteriskAPIUpdateAsteriskFeaturesGeneralRequest

	// UpdateAsteriskFeaturesGeneralExecute executes the request
	UpdateAsteriskFeaturesGeneralExecute(r AsteriskAPIUpdateAsteriskFeaturesGeneralRequest) (*http.Response, error)

	/*
		UpdateAsteriskHepGeneral Update HEP general option

		**Required ACL:** `confd.asterisk.hep.general.update`

	**WARNING** This endpoint restore to default value or delete all fields that are not defined.

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@return AsteriskAPIUpdateAsteriskHepGeneralRequest
	*/
	UpdateAsteriskHepGeneral(ctx context.Context) AsteriskAPIUpdateAsteriskHepGeneralRequest

	// UpdateAsteriskHepGeneralExecute executes the request
	UpdateAsteriskHepGeneralExecute(r AsteriskAPIUpdateAsteriskHepGeneralRequest) (*http.Response, error)

	/*
		UpdateAsteriskIaxCallnumberlimits Update IAX callnumberlimits option

		**Required ACL:** `confd.asterisk.iax.callnumberlimits.update` **WARNING** This endpoint restore to default value or delete all fields that are not defined.

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@return AsteriskAPIUpdateAsteriskIaxCallnumberlimitsRequest
	*/
	UpdateAsteriskIaxCallnumberlimits(ctx context.Context) AsteriskAPIUpdateAsteriskIaxCallnumberlimitsRequest

	// UpdateAsteriskIaxCallnumberlimitsExecute executes the request
	UpdateAsteriskIaxCallnumberlimitsExecute(r AsteriskAPIUpdateAsteriskIaxCallnumberlimitsRequest) (*http.Response, error)

	/*
		UpdateAsteriskIaxGeneral Update IAX general option

		**Required ACL:** `confd.asterisk.iax.general.update` **WARNING** This endpoint restore to default value or delete all fields that are not defined.

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@return AsteriskAPIUpdateAsteriskIaxGeneralRequest
	*/
	UpdateAsteriskIaxGeneral(ctx context.Context) AsteriskAPIUpdateAsteriskIaxGeneralRequest

	// UpdateAsteriskIaxGeneralExecute executes the request
	UpdateAsteriskIaxGeneralExecute(r AsteriskAPIUpdateAsteriskIaxGeneralRequest) (*http.Response, error)

	/*
		UpdateAsteriskPjsipGlobal Update PJSIP section options

		**Required ACL:** `confd.asterisk.pjsip.global.update` The PJSIP global configuration is shared among all tenants of an instance. **WARNING** This endpoint restore to default value or delete all fields that are not defined.

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@return AsteriskAPIUpdateAsteriskPjsipGlobalRequest
	*/
	UpdateAsteriskPjsipGlobal(ctx context.Context) AsteriskAPIUpdateAsteriskPjsipGlobalRequest

	// UpdateAsteriskPjsipGlobalExecute executes the request
	UpdateAsteriskPjsipGlobalExecute(r AsteriskAPIUpdateAsteriskPjsipGlobalRequest) (*http.Response, error)

	/*
		UpdateAsteriskPjsipSystem Update PJSIP section options

		**Required ACL:** `confd.asterisk.pjsip.system.update` The PJSIP system configuration is shared among all tenants of an instance. **WARNING** This endpoint restore to default value or delete all fields that are not defined.

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@return AsteriskAPIUpdateAsteriskPjsipSystemRequest
	*/
	UpdateAsteriskPjsipSystem(ctx context.Context) AsteriskAPIUpdateAsteriskPjsipSystemRequest

	// UpdateAsteriskPjsipSystemExecute executes the request
	UpdateAsteriskPjsipSystemExecute(r AsteriskAPIUpdateAsteriskPjsipSystemRequest) (*http.Response, error)

	/*
		UpdateAsteriskQueueGeneral Update Queue general option

		**Required ACL:** `confd.asterisk.queue.general.update` **WARNING** This endpoint restore to default value or delete all fields that are not defined.

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@return AsteriskAPIUpdateAsteriskQueueGeneralRequest
	*/
	UpdateAsteriskQueueGeneral(ctx context.Context) AsteriskAPIUpdateAsteriskQueueGeneralRequest

	// UpdateAsteriskQueueGeneralExecute executes the request
	UpdateAsteriskQueueGeneralExecute(r AsteriskAPIUpdateAsteriskQueueGeneralRequest) (*http.Response, error)

	/*
		UpdateAsteriskRtpGeneral Update RTP general option

		**Required ACL:** `confd.asterisk.rtp.general.update` **WARNING** This endpoint restore to default value or delete all fields that are not defined.

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@return AsteriskAPIUpdateAsteriskRtpGeneralRequest
	*/
	UpdateAsteriskRtpGeneral(ctx context.Context) AsteriskAPIUpdateAsteriskRtpGeneralRequest

	// UpdateAsteriskRtpGeneralExecute executes the request
	UpdateAsteriskRtpGeneralExecute(r AsteriskAPIUpdateAsteriskRtpGeneralRequest) (*http.Response, error)

	/*
		UpdateAsteriskRtpIceHostCandidates Update RTP ice_host_candidates option

		**Required ACL:** `confd.asterisk.rtp.ice_host_candidates.update` **WARNING** This endpoint restore to default value or delete all fields that are not defined.

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@return AsteriskAPIUpdateAsteriskRtpIceHostCandidatesRequest
	*/
	UpdateAsteriskRtpIceHostCandidates(ctx context.Context) AsteriskAPIUpdateAsteriskRtpIceHostCandidatesRequest

	// UpdateAsteriskRtpIceHostCandidatesExecute executes the request
	UpdateAsteriskRtpIceHostCandidatesExecute(r AsteriskAPIUpdateAsteriskRtpIceHostCandidatesRequest) (*http.Response, error)

	/*
		UpdateAsteriskSccpGeneral Update SCCP general option

		**Required ACL:** `confd.asterisk.sccp.general.update` **WARNING** This endpoint restore to default value or delete all fields that are not defined.

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@return AsteriskAPIUpdateAsteriskSccpGeneralRequest
	*/
	UpdateAsteriskSccpGeneral(ctx context.Context) AsteriskAPIUpdateAsteriskSccpGeneralRequest

	// UpdateAsteriskSccpGeneralExecute executes the request
	UpdateAsteriskSccpGeneralExecute(r AsteriskAPIUpdateAsteriskSccpGeneralRequest) (*http.Response, error)

	/*
		UpdateAsteriskVoicemailGeneral Update Voicemail general option

		**Required ACL:** `confd.asterisk.voicemail.general.update` **WARNING** This endpoint restore to default value or delete all fields that are not defined.

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@return AsteriskAPIUpdateAsteriskVoicemailGeneralRequest
	*/
	UpdateAsteriskVoicemailGeneral(ctx context.Context) AsteriskAPIUpdateAsteriskVoicemailGeneralRequest

	// UpdateAsteriskVoicemailGeneralExecute executes the request
	UpdateAsteriskVoicemailGeneralExecute(r AsteriskAPIUpdateAsteriskVoicemailGeneralRequest) (*http.Response, error)

	/*
		UpdateAsteriskVoicemailZonemessages Update Voicemail zonemessages option

		**Required ACL:** `confd.asterisk.voicemail.zonemessages.update` **WARNING** This endpoint restore to default value or delete all fields that are not defined.

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@return AsteriskAPIUpdateAsteriskVoicemailZonemessagesRequest
	*/
	UpdateAsteriskVoicemailZonemessages(ctx context.Context) AsteriskAPIUpdateAsteriskVoicemailZonemessagesRequest

	// UpdateAsteriskVoicemailZonemessagesExecute executes the request
	UpdateAsteriskVoicemailZonemessagesExecute(r AsteriskAPIUpdateAsteriskVoicemailZonemessagesRequest) (*http.Response, error)
}

// AsteriskAPIService AsteriskAPI service
type AsteriskAPIService service

type AsteriskAPIListAsteriskConfbridgeAccentDefaultBridgeRequest struct {
	ctx        context.Context
	ApiService AsteriskAPI
}

func (r AsteriskAPIListAsteriskConfbridgeAccentDefaultBridgeRequest) Execute() (*ConfBridgeConfiguration, *http.Response, error) {
	return r.ApiService.ListAsteriskConfbridgeAccentDefaultBridgeExecute(r)
}

/*
ListAsteriskConfbridgeAccentDefaultBridge List ConfBridge accent_default_bridge options

**Required ACL:** `confd.asterisk.confbridge.accent_default_bridge.read`

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return AsteriskAPIListAsteriskConfbridgeAccentDefaultBridgeRequest
*/
func (a *AsteriskAPIService) ListAsteriskConfbridgeAccentDefaultBridge(ctx context.Context) AsteriskAPIListAsteriskConfbridgeAccentDefaultBridgeRequest {
	return AsteriskAPIListAsteriskConfbridgeAccentDefaultBridgeRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return ConfBridgeConfiguration
func (a *AsteriskAPIService) ListAsteriskConfbridgeAccentDefaultBridgeExecute(r AsteriskAPIListAsteriskConfbridgeAccentDefaultBridgeRequest) (*ConfBridgeConfiguration, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *ConfBridgeConfiguration
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AsteriskAPIService.ListAsteriskConfbridgeAccentDefaultBridge")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/asterisk/confbridge/accent_default_bridge"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["accent_auth_token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Auth-Token"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type AsteriskAPIListAsteriskConfbridgeAccentDefaultUserRequest struct {
	ctx        context.Context
	ApiService AsteriskAPI
}

func (r AsteriskAPIListAsteriskConfbridgeAccentDefaultUserRequest) Execute() (*ConfBridgeConfiguration, *http.Response, error) {
	return r.ApiService.ListAsteriskConfbridgeAccentDefaultUserExecute(r)
}

/*
ListAsteriskConfbridgeAccentDefaultUser List ConfBridge accent_default_user options

**Required ACL:** `confd.asterisk.confbridge.accent_default_user.read`

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return AsteriskAPIListAsteriskConfbridgeAccentDefaultUserRequest
*/
func (a *AsteriskAPIService) ListAsteriskConfbridgeAccentDefaultUser(ctx context.Context) AsteriskAPIListAsteriskConfbridgeAccentDefaultUserRequest {
	return AsteriskAPIListAsteriskConfbridgeAccentDefaultUserRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return ConfBridgeConfiguration
func (a *AsteriskAPIService) ListAsteriskConfbridgeAccentDefaultUserExecute(r AsteriskAPIListAsteriskConfbridgeAccentDefaultUserRequest) (*ConfBridgeConfiguration, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *ConfBridgeConfiguration
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AsteriskAPIService.ListAsteriskConfbridgeAccentDefaultUser")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/asterisk/confbridge/accent_default_user"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["accent_auth_token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Auth-Token"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type AsteriskAPIListAsteriskFeaturesApplicationmapRequest struct {
	ctx        context.Context
	ApiService AsteriskAPI
}

func (r AsteriskAPIListAsteriskFeaturesApplicationmapRequest) Execute() (*FeaturesConfiguration, *http.Response, error) {
	return r.ApiService.ListAsteriskFeaturesApplicationmapExecute(r)
}

/*
ListAsteriskFeaturesApplicationmap List Features applicationmap options

**Required ACL:** `confd.asterisk.features.applicationmap.read`

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return AsteriskAPIListAsteriskFeaturesApplicationmapRequest
*/
func (a *AsteriskAPIService) ListAsteriskFeaturesApplicationmap(ctx context.Context) AsteriskAPIListAsteriskFeaturesApplicationmapRequest {
	return AsteriskAPIListAsteriskFeaturesApplicationmapRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return FeaturesConfiguration
func (a *AsteriskAPIService) ListAsteriskFeaturesApplicationmapExecute(r AsteriskAPIListAsteriskFeaturesApplicationmapRequest) (*FeaturesConfiguration, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *FeaturesConfiguration
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AsteriskAPIService.ListAsteriskFeaturesApplicationmap")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/asterisk/features/applicationmap"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["accent_auth_token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Auth-Token"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type AsteriskAPIListAsteriskFeaturesFeaturemapRequest struct {
	ctx        context.Context
	ApiService AsteriskAPI
}

func (r AsteriskAPIListAsteriskFeaturesFeaturemapRequest) Execute() (*FeaturesConfiguration, *http.Response, error) {
	return r.ApiService.ListAsteriskFeaturesFeaturemapExecute(r)
}

/*
ListAsteriskFeaturesFeaturemap List Features featuremap options

**Required ACL:** `confd.asterisk.features.featuremap.read`

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return AsteriskAPIListAsteriskFeaturesFeaturemapRequest
*/
func (a *AsteriskAPIService) ListAsteriskFeaturesFeaturemap(ctx context.Context) AsteriskAPIListAsteriskFeaturesFeaturemapRequest {
	return AsteriskAPIListAsteriskFeaturesFeaturemapRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return FeaturesConfiguration
func (a *AsteriskAPIService) ListAsteriskFeaturesFeaturemapExecute(r AsteriskAPIListAsteriskFeaturesFeaturemapRequest) (*FeaturesConfiguration, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *FeaturesConfiguration
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AsteriskAPIService.ListAsteriskFeaturesFeaturemap")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/asterisk/features/featuremap"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["accent_auth_token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Auth-Token"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type AsteriskAPIListAsteriskFeaturesGeneralRequest struct {
	ctx        context.Context
	ApiService AsteriskAPI
}

func (r AsteriskAPIListAsteriskFeaturesGeneralRequest) Execute() (*FeaturesConfiguration, *http.Response, error) {
	return r.ApiService.ListAsteriskFeaturesGeneralExecute(r)
}

/*
ListAsteriskFeaturesGeneral List Features general options

**Required ACL:** `confd.asterisk.features.general.read`

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return AsteriskAPIListAsteriskFeaturesGeneralRequest
*/
func (a *AsteriskAPIService) ListAsteriskFeaturesGeneral(ctx context.Context) AsteriskAPIListAsteriskFeaturesGeneralRequest {
	return AsteriskAPIListAsteriskFeaturesGeneralRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return FeaturesConfiguration
func (a *AsteriskAPIService) ListAsteriskFeaturesGeneralExecute(r AsteriskAPIListAsteriskFeaturesGeneralRequest) (*FeaturesConfiguration, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *FeaturesConfiguration
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AsteriskAPIService.ListAsteriskFeaturesGeneral")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/asterisk/features/general"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["accent_auth_token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Auth-Token"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type AsteriskAPIListAsteriskHepGeneralRequest struct {
	ctx        context.Context
	ApiService AsteriskAPI
}

func (r AsteriskAPIListAsteriskHepGeneralRequest) Execute() (*HEPConfiguration, *http.Response, error) {
	return r.ApiService.ListAsteriskHepGeneralExecute(r)
}

/*
ListAsteriskHepGeneral List HEP general options

**Required ACL:** `confd.asterisk.hep.general.read`

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return AsteriskAPIListAsteriskHepGeneralRequest
*/
func (a *AsteriskAPIService) ListAsteriskHepGeneral(ctx context.Context) AsteriskAPIListAsteriskHepGeneralRequest {
	return AsteriskAPIListAsteriskHepGeneralRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return HEPConfiguration
func (a *AsteriskAPIService) ListAsteriskHepGeneralExecute(r AsteriskAPIListAsteriskHepGeneralRequest) (*HEPConfiguration, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *HEPConfiguration
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AsteriskAPIService.ListAsteriskHepGeneral")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/asterisk/hep/general"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["accent_auth_token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Auth-Token"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type AsteriskAPIListAsteriskIaxCallnumberlimitsRequest struct {
	ctx        context.Context
	ApiService AsteriskAPI
}

func (r AsteriskAPIListAsteriskIaxCallnumberlimitsRequest) Execute() (*IAXCallNumberLimitss, *http.Response, error) {
	return r.ApiService.ListAsteriskIaxCallnumberlimitsExecute(r)
}

/*
ListAsteriskIaxCallnumberlimits List IAX callnumberlimits options

**Required ACL:** `confd.asterisk.iax.callnumberlimits.read`

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return AsteriskAPIListAsteriskIaxCallnumberlimitsRequest
*/
func (a *AsteriskAPIService) ListAsteriskIaxCallnumberlimits(ctx context.Context) AsteriskAPIListAsteriskIaxCallnumberlimitsRequest {
	return AsteriskAPIListAsteriskIaxCallnumberlimitsRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return IAXCallNumberLimitss
func (a *AsteriskAPIService) ListAsteriskIaxCallnumberlimitsExecute(r AsteriskAPIListAsteriskIaxCallnumberlimitsRequest) (*IAXCallNumberLimitss, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *IAXCallNumberLimitss
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AsteriskAPIService.ListAsteriskIaxCallnumberlimits")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/asterisk/iax/callnumberlimits"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["accent_auth_token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Auth-Token"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type AsteriskAPIListAsteriskIaxGeneralRequest struct {
	ctx        context.Context
	ApiService AsteriskAPI
}

func (r AsteriskAPIListAsteriskIaxGeneralRequest) Execute() (*IAXGeneral, *http.Response, error) {
	return r.ApiService.ListAsteriskIaxGeneralExecute(r)
}

/*
ListAsteriskIaxGeneral List IAX general options

**Required ACL:** `confd.asterisk.iax.general.read`

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return AsteriskAPIListAsteriskIaxGeneralRequest
*/
func (a *AsteriskAPIService) ListAsteriskIaxGeneral(ctx context.Context) AsteriskAPIListAsteriskIaxGeneralRequest {
	return AsteriskAPIListAsteriskIaxGeneralRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return IAXGeneral
func (a *AsteriskAPIService) ListAsteriskIaxGeneralExecute(r AsteriskAPIListAsteriskIaxGeneralRequest) (*IAXGeneral, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *IAXGeneral
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AsteriskAPIService.ListAsteriskIaxGeneral")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/asterisk/iax/general"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["accent_auth_token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Auth-Token"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type AsteriskAPIListAsteriskPjsipGlobalRequest struct {
	ctx        context.Context
	ApiService AsteriskAPI
}

func (r AsteriskAPIListAsteriskPjsipGlobalRequest) Execute() (*PJSIPGlobal, *http.Response, error) {
	return r.ApiService.ListAsteriskPjsipGlobalExecute(r)
}

/*
ListAsteriskPjsipGlobal List of PJSIP options for the `global` section

**Required ACL:** `confd.asterisk.pjsip.global.read`

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return AsteriskAPIListAsteriskPjsipGlobalRequest
*/
func (a *AsteriskAPIService) ListAsteriskPjsipGlobal(ctx context.Context) AsteriskAPIListAsteriskPjsipGlobalRequest {
	return AsteriskAPIListAsteriskPjsipGlobalRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return PJSIPGlobal
func (a *AsteriskAPIService) ListAsteriskPjsipGlobalExecute(r AsteriskAPIListAsteriskPjsipGlobalRequest) (*PJSIPGlobal, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *PJSIPGlobal
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AsteriskAPIService.ListAsteriskPjsipGlobal")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/asterisk/pjsip/global"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["accent_auth_token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Auth-Token"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type AsteriskAPIListAsteriskPjsipSystemRequest struct {
	ctx        context.Context
	ApiService AsteriskAPI
}

func (r AsteriskAPIListAsteriskPjsipSystemRequest) Execute() (*PJSIPSystem, *http.Response, error) {
	return r.ApiService.ListAsteriskPjsipSystemExecute(r)
}

/*
ListAsteriskPjsipSystem List of PJSIP options for the `system` section

**Required ACL:** `confd.asterisk.pjsip.system.read`

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return AsteriskAPIListAsteriskPjsipSystemRequest
*/
func (a *AsteriskAPIService) ListAsteriskPjsipSystem(ctx context.Context) AsteriskAPIListAsteriskPjsipSystemRequest {
	return AsteriskAPIListAsteriskPjsipSystemRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return PJSIPSystem
func (a *AsteriskAPIService) ListAsteriskPjsipSystemExecute(r AsteriskAPIListAsteriskPjsipSystemRequest) (*PJSIPSystem, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *PJSIPSystem
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AsteriskAPIService.ListAsteriskPjsipSystem")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/asterisk/pjsip/system"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["accent_auth_token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Auth-Token"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type AsteriskAPIListAsteriskQueueGeneralRequest struct {
	ctx        context.Context
	ApiService AsteriskAPI
}

func (r AsteriskAPIListAsteriskQueueGeneralRequest) Execute() (*QueueGeneral, *http.Response, error) {
	return r.ApiService.ListAsteriskQueueGeneralExecute(r)
}

/*
ListAsteriskQueueGeneral List Queue general options

**Required ACL:** `confd.asterisk.queue.general.read`

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return AsteriskAPIListAsteriskQueueGeneralRequest
*/
func (a *AsteriskAPIService) ListAsteriskQueueGeneral(ctx context.Context) AsteriskAPIListAsteriskQueueGeneralRequest {
	return AsteriskAPIListAsteriskQueueGeneralRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return QueueGeneral
func (a *AsteriskAPIService) ListAsteriskQueueGeneralExecute(r AsteriskAPIListAsteriskQueueGeneralRequest) (*QueueGeneral, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *QueueGeneral
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AsteriskAPIService.ListAsteriskQueueGeneral")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/asterisk/queues/general"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["accent_auth_token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Auth-Token"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type AsteriskAPIListAsteriskRtpGeneralRequest struct {
	ctx        context.Context
	ApiService AsteriskAPI
}

func (r AsteriskAPIListAsteriskRtpGeneralRequest) Execute() (*RTPConfiguration, *http.Response, error) {
	return r.ApiService.ListAsteriskRtpGeneralExecute(r)
}

/*
ListAsteriskRtpGeneral List RTP general options

**Required ACL:** `confd.asterisk.rtp.general.read`

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return AsteriskAPIListAsteriskRtpGeneralRequest
*/
func (a *AsteriskAPIService) ListAsteriskRtpGeneral(ctx context.Context) AsteriskAPIListAsteriskRtpGeneralRequest {
	return AsteriskAPIListAsteriskRtpGeneralRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return RTPConfiguration
func (a *AsteriskAPIService) ListAsteriskRtpGeneralExecute(r AsteriskAPIListAsteriskRtpGeneralRequest) (*RTPConfiguration, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *RTPConfiguration
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AsteriskAPIService.ListAsteriskRtpGeneral")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/asterisk/rtp/general"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["accent_auth_token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Auth-Token"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type AsteriskAPIListAsteriskRtpIceHostCandidatesRequest struct {
	ctx        context.Context
	ApiService AsteriskAPI
}

func (r AsteriskAPIListAsteriskRtpIceHostCandidatesRequest) Execute() (*RTPConfiguration, *http.Response, error) {
	return r.ApiService.ListAsteriskRtpIceHostCandidatesExecute(r)
}

/*
ListAsteriskRtpIceHostCandidates List RTP ice_host_candidates options

**Required ACL:** `confd.asterisk.rtp.ice_host_candidates.read`

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return AsteriskAPIListAsteriskRtpIceHostCandidatesRequest
*/
func (a *AsteriskAPIService) ListAsteriskRtpIceHostCandidates(ctx context.Context) AsteriskAPIListAsteriskRtpIceHostCandidatesRequest {
	return AsteriskAPIListAsteriskRtpIceHostCandidatesRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return RTPConfiguration
func (a *AsteriskAPIService) ListAsteriskRtpIceHostCandidatesExecute(r AsteriskAPIListAsteriskRtpIceHostCandidatesRequest) (*RTPConfiguration, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *RTPConfiguration
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AsteriskAPIService.ListAsteriskRtpIceHostCandidates")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/asterisk/rtp/ice_host_candidates"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["accent_auth_token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Auth-Token"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type AsteriskAPIListAsteriskSccpGeneralRequest struct {
	ctx        context.Context
	ApiService AsteriskAPI
}

func (r AsteriskAPIListAsteriskSccpGeneralRequest) Execute() (*SCCPGeneral, *http.Response, error) {
	return r.ApiService.ListAsteriskSccpGeneralExecute(r)
}

/*
ListAsteriskSccpGeneral List SCCP general options

**Required ACL:** `confd.asterisk.sccp.general.read`

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return AsteriskAPIListAsteriskSccpGeneralRequest
*/
func (a *AsteriskAPIService) ListAsteriskSccpGeneral(ctx context.Context) AsteriskAPIListAsteriskSccpGeneralRequest {
	return AsteriskAPIListAsteriskSccpGeneralRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return SCCPGeneral
func (a *AsteriskAPIService) ListAsteriskSccpGeneralExecute(r AsteriskAPIListAsteriskSccpGeneralRequest) (*SCCPGeneral, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *SCCPGeneral
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AsteriskAPIService.ListAsteriskSccpGeneral")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/asterisk/sccp/general"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["accent_auth_token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Auth-Token"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type AsteriskAPIListAsteriskVoicemailGeneralRequest struct {
	ctx        context.Context
	ApiService AsteriskAPI
}

func (r AsteriskAPIListAsteriskVoicemailGeneralRequest) Execute() (*VoicemailGeneral, *http.Response, error) {
	return r.ApiService.ListAsteriskVoicemailGeneralExecute(r)
}

/*
ListAsteriskVoicemailGeneral List Voicemail general options

**Required ACL:** `confd.asterisk.voicemail.general.read`

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return AsteriskAPIListAsteriskVoicemailGeneralRequest
*/
func (a *AsteriskAPIService) ListAsteriskVoicemailGeneral(ctx context.Context) AsteriskAPIListAsteriskVoicemailGeneralRequest {
	return AsteriskAPIListAsteriskVoicemailGeneralRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return VoicemailGeneral
func (a *AsteriskAPIService) ListAsteriskVoicemailGeneralExecute(r AsteriskAPIListAsteriskVoicemailGeneralRequest) (*VoicemailGeneral, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *VoicemailGeneral
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AsteriskAPIService.ListAsteriskVoicemailGeneral")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/asterisk/voicemail/general"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["accent_auth_token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Auth-Token"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type AsteriskAPIListAsteriskVoicemailZonemessagesRequest struct {
	ctx        context.Context
	ApiService AsteriskAPI
}

func (r AsteriskAPIListAsteriskVoicemailZonemessagesRequest) Execute() (*VoicemailZoneMessages, *http.Response, error) {
	return r.ApiService.ListAsteriskVoicemailZonemessagesExecute(r)
}

/*
ListAsteriskVoicemailZonemessages List Voicemail zonemessages options

**Required ACL:** `confd.asterisk.voicemail.zonemessages.read`

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return AsteriskAPIListAsteriskVoicemailZonemessagesRequest
*/
func (a *AsteriskAPIService) ListAsteriskVoicemailZonemessages(ctx context.Context) AsteriskAPIListAsteriskVoicemailZonemessagesRequest {
	return AsteriskAPIListAsteriskVoicemailZonemessagesRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return VoicemailZoneMessages
func (a *AsteriskAPIService) ListAsteriskVoicemailZonemessagesExecute(r AsteriskAPIListAsteriskVoicemailZonemessagesRequest) (*VoicemailZoneMessages, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *VoicemailZoneMessages
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AsteriskAPIService.ListAsteriskVoicemailZonemessages")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/asterisk/voicemail/zonemessages"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["accent_auth_token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Auth-Token"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type AsteriskAPIShowPjsipDocRequest struct {
	ctx        context.Context
	ApiService AsteriskAPI
}

func (r AsteriskAPIShowPjsipDocRequest) Execute() (*PJSIPConfigurationOptions, *http.Response, error) {
	return r.ApiService.ShowPjsipDocExecute(r)
}

/*
ShowPjsipDoc List all PJSIP configuration options

**Required ACL:**: `confd.asterisk.pjsip.doc.read` List all available configuration options for PJSIP, those values are used to validate to content of POST and PUT requests.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return AsteriskAPIShowPjsipDocRequest
*/
func (a *AsteriskAPIService) ShowPjsipDoc(ctx context.Context) AsteriskAPIShowPjsipDocRequest {
	return AsteriskAPIShowPjsipDocRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return PJSIPConfigurationOptions
func (a *AsteriskAPIService) ShowPjsipDocExecute(r AsteriskAPIShowPjsipDocRequest) (*PJSIPConfigurationOptions, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *PJSIPConfigurationOptions
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AsteriskAPIService.ShowPjsipDoc")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/asterisk/pjsip/doc"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["accent_auth_token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Auth-Token"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v []string
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type AsteriskAPIUpdateAsteriskConfbridgeAccentDefaultBridgeRequest struct {
	ctx        context.Context
	ApiService AsteriskAPI
	body       *ConfBridgeConfiguration
}

func (r AsteriskAPIUpdateAsteriskConfbridgeAccentDefaultBridgeRequest) Body(body ConfBridgeConfiguration) AsteriskAPIUpdateAsteriskConfbridgeAccentDefaultBridgeRequest {
	r.body = &body
	return r
}

func (r AsteriskAPIUpdateAsteriskConfbridgeAccentDefaultBridgeRequest) Execute() (*http.Response, error) {
	return r.ApiService.UpdateAsteriskConfbridgeAccentDefaultBridgeExecute(r)
}

/*
UpdateAsteriskConfbridgeAccentDefaultBridge Update ConfBridge accent_default_bridge option

**Required ACL:** `confd.asterisk.confbridge.accent_default_bridge.update` **WARNING** This endpoint restore to default value or delete all fields that are not defined. All available configuration options are listed in the [sample](https://raw.githubusercontent.com/asterisk/asterisk/master/configs/samples/confbridge.conf.sample) Asterisk configuration file.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return AsteriskAPIUpdateAsteriskConfbridgeAccentDefaultBridgeRequest
*/
func (a *AsteriskAPIService) UpdateAsteriskConfbridgeAccentDefaultBridge(ctx context.Context) AsteriskAPIUpdateAsteriskConfbridgeAccentDefaultBridgeRequest {
	return AsteriskAPIUpdateAsteriskConfbridgeAccentDefaultBridgeRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
func (a *AsteriskAPIService) UpdateAsteriskConfbridgeAccentDefaultBridgeExecute(r AsteriskAPIUpdateAsteriskConfbridgeAccentDefaultBridgeRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodPut
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AsteriskAPIService.UpdateAsteriskConfbridgeAccentDefaultBridge")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/asterisk/confbridge/accent_default_bridge"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return nil, reportError("body is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["accent_auth_token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Auth-Token"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v []string
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v []string
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type AsteriskAPIUpdateAsteriskConfbridgeAccentDefaultUserRequest struct {
	ctx        context.Context
	ApiService AsteriskAPI
	body       *ConfBridgeConfiguration
}

func (r AsteriskAPIUpdateAsteriskConfbridgeAccentDefaultUserRequest) Body(body ConfBridgeConfiguration) AsteriskAPIUpdateAsteriskConfbridgeAccentDefaultUserRequest {
	r.body = &body
	return r
}

func (r AsteriskAPIUpdateAsteriskConfbridgeAccentDefaultUserRequest) Execute() (*http.Response, error) {
	return r.ApiService.UpdateAsteriskConfbridgeAccentDefaultUserExecute(r)
}

/*
UpdateAsteriskConfbridgeAccentDefaultUser Update ConfBridge accent_default_user option

**Required ACL:** `confd.asterisk.confbridge.accent_default_user.update` **WARNING** This endpoint restore to default value or delete all fields that are not defined. All available configuration options are listed in the [sample](https://raw.githubusercontent.com/asterisk/asterisk/master/configs/samples/confbridge.conf.sample) Asterisk configuration file.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return AsteriskAPIUpdateAsteriskConfbridgeAccentDefaultUserRequest
*/
func (a *AsteriskAPIService) UpdateAsteriskConfbridgeAccentDefaultUser(ctx context.Context) AsteriskAPIUpdateAsteriskConfbridgeAccentDefaultUserRequest {
	return AsteriskAPIUpdateAsteriskConfbridgeAccentDefaultUserRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
func (a *AsteriskAPIService) UpdateAsteriskConfbridgeAccentDefaultUserExecute(r AsteriskAPIUpdateAsteriskConfbridgeAccentDefaultUserRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodPut
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AsteriskAPIService.UpdateAsteriskConfbridgeAccentDefaultUser")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/asterisk/confbridge/accent_default_user"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return nil, reportError("body is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["accent_auth_token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Auth-Token"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v []string
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v []string
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type AsteriskAPIUpdateAsteriskFeaturesApplicationmapRequest struct {
	ctx        context.Context
	ApiService AsteriskAPI
	body       *FeaturesConfiguration
}

func (r AsteriskAPIUpdateAsteriskFeaturesApplicationmapRequest) Body(body FeaturesConfiguration) AsteriskAPIUpdateAsteriskFeaturesApplicationmapRequest {
	r.body = &body
	return r
}

func (r AsteriskAPIUpdateAsteriskFeaturesApplicationmapRequest) Execute() (*http.Response, error) {
	return r.ApiService.UpdateAsteriskFeaturesApplicationmapExecute(r)
}

/*
UpdateAsteriskFeaturesApplicationmap Update Features applicationmap option

**Required ACL:** `confd.asterisk.features.applicationmap.update` **WARNING** This endpoint restore to default value or delete all fields that are not defined.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return AsteriskAPIUpdateAsteriskFeaturesApplicationmapRequest
*/
func (a *AsteriskAPIService) UpdateAsteriskFeaturesApplicationmap(ctx context.Context) AsteriskAPIUpdateAsteriskFeaturesApplicationmapRequest {
	return AsteriskAPIUpdateAsteriskFeaturesApplicationmapRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
func (a *AsteriskAPIService) UpdateAsteriskFeaturesApplicationmapExecute(r AsteriskAPIUpdateAsteriskFeaturesApplicationmapRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodPut
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AsteriskAPIService.UpdateAsteriskFeaturesApplicationmap")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/asterisk/features/applicationmap"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return nil, reportError("body is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["accent_auth_token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Auth-Token"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v []string
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v []string
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type AsteriskAPIUpdateAsteriskFeaturesFeaturemapRequest struct {
	ctx        context.Context
	ApiService AsteriskAPI
	body       *FeaturesConfiguration
}

func (r AsteriskAPIUpdateAsteriskFeaturesFeaturemapRequest) Body(body FeaturesConfiguration) AsteriskAPIUpdateAsteriskFeaturesFeaturemapRequest {
	r.body = &body
	return r
}

func (r AsteriskAPIUpdateAsteriskFeaturesFeaturemapRequest) Execute() (*http.Response, error) {
	return r.ApiService.UpdateAsteriskFeaturesFeaturemapExecute(r)
}

/*
UpdateAsteriskFeaturesFeaturemap Update Features featuremap option

**Required ACL:** `confd.asterisk.features.featuremap.update` **WARNING** This endpoint restore to default value or delete all fields that are not defined.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return AsteriskAPIUpdateAsteriskFeaturesFeaturemapRequest
*/
func (a *AsteriskAPIService) UpdateAsteriskFeaturesFeaturemap(ctx context.Context) AsteriskAPIUpdateAsteriskFeaturesFeaturemapRequest {
	return AsteriskAPIUpdateAsteriskFeaturesFeaturemapRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
func (a *AsteriskAPIService) UpdateAsteriskFeaturesFeaturemapExecute(r AsteriskAPIUpdateAsteriskFeaturesFeaturemapRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodPut
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AsteriskAPIService.UpdateAsteriskFeaturesFeaturemap")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/asterisk/features/featuremap"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return nil, reportError("body is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["accent_auth_token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Auth-Token"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v []string
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v []string
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type AsteriskAPIUpdateAsteriskFeaturesGeneralRequest struct {
	ctx        context.Context
	ApiService AsteriskAPI
	body       *FeaturesConfiguration
}

func (r AsteriskAPIUpdateAsteriskFeaturesGeneralRequest) Body(body FeaturesConfiguration) AsteriskAPIUpdateAsteriskFeaturesGeneralRequest {
	r.body = &body
	return r
}

func (r AsteriskAPIUpdateAsteriskFeaturesGeneralRequest) Execute() (*http.Response, error) {
	return r.ApiService.UpdateAsteriskFeaturesGeneralExecute(r)
}

/*
UpdateAsteriskFeaturesGeneral Update Features general option

**Required ACL:** `confd.asterisk.features.general.update` **WARNING** This endpoint restore to default value or delete all fields that are not defined.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return AsteriskAPIUpdateAsteriskFeaturesGeneralRequest
*/
func (a *AsteriskAPIService) UpdateAsteriskFeaturesGeneral(ctx context.Context) AsteriskAPIUpdateAsteriskFeaturesGeneralRequest {
	return AsteriskAPIUpdateAsteriskFeaturesGeneralRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
func (a *AsteriskAPIService) UpdateAsteriskFeaturesGeneralExecute(r AsteriskAPIUpdateAsteriskFeaturesGeneralRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodPut
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AsteriskAPIService.UpdateAsteriskFeaturesGeneral")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/asterisk/features/general"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return nil, reportError("body is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["accent_auth_token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Auth-Token"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v []string
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v []string
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type AsteriskAPIUpdateAsteriskHepGeneralRequest struct {
	ctx        context.Context
	ApiService AsteriskAPI
	body       *HEPConfiguration
}

func (r AsteriskAPIUpdateAsteriskHepGeneralRequest) Body(body HEPConfiguration) AsteriskAPIUpdateAsteriskHepGeneralRequest {
	r.body = &body
	return r
}

func (r AsteriskAPIUpdateAsteriskHepGeneralRequest) Execute() (*http.Response, error) {
	return r.ApiService.UpdateAsteriskHepGeneralExecute(r)
}

/*
UpdateAsteriskHepGeneral Update HEP general option

**Required ACL:** `confd.asterisk.hep.general.update`

**WARNING** This endpoint restore to default value or delete all fields that are not defined.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return AsteriskAPIUpdateAsteriskHepGeneralRequest
*/
func (a *AsteriskAPIService) UpdateAsteriskHepGeneral(ctx context.Context) AsteriskAPIUpdateAsteriskHepGeneralRequest {
	return AsteriskAPIUpdateAsteriskHepGeneralRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
func (a *AsteriskAPIService) UpdateAsteriskHepGeneralExecute(r AsteriskAPIUpdateAsteriskHepGeneralRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodPut
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AsteriskAPIService.UpdateAsteriskHepGeneral")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/asterisk/hep/general"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return nil, reportError("body is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["accent_auth_token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Auth-Token"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v []string
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type AsteriskAPIUpdateAsteriskIaxCallnumberlimitsRequest struct {
	ctx        context.Context
	ApiService AsteriskAPI
	body       *IAXCallNumberLimitss
}

func (r AsteriskAPIUpdateAsteriskIaxCallnumberlimitsRequest) Body(body IAXCallNumberLimitss) AsteriskAPIUpdateAsteriskIaxCallnumberlimitsRequest {
	r.body = &body
	return r
}

func (r AsteriskAPIUpdateAsteriskIaxCallnumberlimitsRequest) Execute() (*http.Response, error) {
	return r.ApiService.UpdateAsteriskIaxCallnumberlimitsExecute(r)
}

/*
UpdateAsteriskIaxCallnumberlimits Update IAX callnumberlimits option

**Required ACL:** `confd.asterisk.iax.callnumberlimits.update` **WARNING** This endpoint restore to default value or delete all fields that are not defined.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return AsteriskAPIUpdateAsteriskIaxCallnumberlimitsRequest
*/
func (a *AsteriskAPIService) UpdateAsteriskIaxCallnumberlimits(ctx context.Context) AsteriskAPIUpdateAsteriskIaxCallnumberlimitsRequest {
	return AsteriskAPIUpdateAsteriskIaxCallnumberlimitsRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
func (a *AsteriskAPIService) UpdateAsteriskIaxCallnumberlimitsExecute(r AsteriskAPIUpdateAsteriskIaxCallnumberlimitsRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodPut
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AsteriskAPIService.UpdateAsteriskIaxCallnumberlimits")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/asterisk/iax/callnumberlimits"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return nil, reportError("body is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["accent_auth_token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Auth-Token"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v []string
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v []string
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type AsteriskAPIUpdateAsteriskIaxGeneralRequest struct {
	ctx        context.Context
	ApiService AsteriskAPI
	body       *IAXGeneral
}

func (r AsteriskAPIUpdateAsteriskIaxGeneralRequest) Body(body IAXGeneral) AsteriskAPIUpdateAsteriskIaxGeneralRequest {
	r.body = &body
	return r
}

func (r AsteriskAPIUpdateAsteriskIaxGeneralRequest) Execute() (*http.Response, error) {
	return r.ApiService.UpdateAsteriskIaxGeneralExecute(r)
}

/*
UpdateAsteriskIaxGeneral Update IAX general option

**Required ACL:** `confd.asterisk.iax.general.update` **WARNING** This endpoint restore to default value or delete all fields that are not defined.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return AsteriskAPIUpdateAsteriskIaxGeneralRequest
*/
func (a *AsteriskAPIService) UpdateAsteriskIaxGeneral(ctx context.Context) AsteriskAPIUpdateAsteriskIaxGeneralRequest {
	return AsteriskAPIUpdateAsteriskIaxGeneralRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
func (a *AsteriskAPIService) UpdateAsteriskIaxGeneralExecute(r AsteriskAPIUpdateAsteriskIaxGeneralRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodPut
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AsteriskAPIService.UpdateAsteriskIaxGeneral")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/asterisk/iax/general"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return nil, reportError("body is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["accent_auth_token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Auth-Token"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v []string
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v []string
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type AsteriskAPIUpdateAsteriskPjsipGlobalRequest struct {
	ctx        context.Context
	ApiService AsteriskAPI
	body       *PJSIPGlobal
}

func (r AsteriskAPIUpdateAsteriskPjsipGlobalRequest) Body(body PJSIPGlobal) AsteriskAPIUpdateAsteriskPjsipGlobalRequest {
	r.body = &body
	return r
}

func (r AsteriskAPIUpdateAsteriskPjsipGlobalRequest) Execute() (*http.Response, error) {
	return r.ApiService.UpdateAsteriskPjsipGlobalExecute(r)
}

/*
UpdateAsteriskPjsipGlobal Update PJSIP section options

**Required ACL:** `confd.asterisk.pjsip.global.update` The PJSIP global configuration is shared among all tenants of an instance. **WARNING** This endpoint restore to default value or delete all fields that are not defined.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return AsteriskAPIUpdateAsteriskPjsipGlobalRequest
*/
func (a *AsteriskAPIService) UpdateAsteriskPjsipGlobal(ctx context.Context) AsteriskAPIUpdateAsteriskPjsipGlobalRequest {
	return AsteriskAPIUpdateAsteriskPjsipGlobalRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
func (a *AsteriskAPIService) UpdateAsteriskPjsipGlobalExecute(r AsteriskAPIUpdateAsteriskPjsipGlobalRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodPut
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AsteriskAPIService.UpdateAsteriskPjsipGlobal")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/asterisk/pjsip/global"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return nil, reportError("body is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["accent_auth_token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Auth-Token"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v []string
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v []string
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type AsteriskAPIUpdateAsteriskPjsipSystemRequest struct {
	ctx        context.Context
	ApiService AsteriskAPI
	body       *PJSIPSystem
}

func (r AsteriskAPIUpdateAsteriskPjsipSystemRequest) Body(body PJSIPSystem) AsteriskAPIUpdateAsteriskPjsipSystemRequest {
	r.body = &body
	return r
}

func (r AsteriskAPIUpdateAsteriskPjsipSystemRequest) Execute() (*http.Response, error) {
	return r.ApiService.UpdateAsteriskPjsipSystemExecute(r)
}

/*
UpdateAsteriskPjsipSystem Update PJSIP section options

**Required ACL:** `confd.asterisk.pjsip.system.update` The PJSIP system configuration is shared among all tenants of an instance. **WARNING** This endpoint restore to default value or delete all fields that are not defined.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return AsteriskAPIUpdateAsteriskPjsipSystemRequest
*/
func (a *AsteriskAPIService) UpdateAsteriskPjsipSystem(ctx context.Context) AsteriskAPIUpdateAsteriskPjsipSystemRequest {
	return AsteriskAPIUpdateAsteriskPjsipSystemRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
func (a *AsteriskAPIService) UpdateAsteriskPjsipSystemExecute(r AsteriskAPIUpdateAsteriskPjsipSystemRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodPut
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AsteriskAPIService.UpdateAsteriskPjsipSystem")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/asterisk/pjsip/system"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return nil, reportError("body is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["accent_auth_token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Auth-Token"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v []string
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v []string
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type AsteriskAPIUpdateAsteriskQueueGeneralRequest struct {
	ctx        context.Context
	ApiService AsteriskAPI
	body       *QueueGeneral
}

func (r AsteriskAPIUpdateAsteriskQueueGeneralRequest) Body(body QueueGeneral) AsteriskAPIUpdateAsteriskQueueGeneralRequest {
	r.body = &body
	return r
}

func (r AsteriskAPIUpdateAsteriskQueueGeneralRequest) Execute() (*http.Response, error) {
	return r.ApiService.UpdateAsteriskQueueGeneralExecute(r)
}

/*
UpdateAsteriskQueueGeneral Update Queue general option

**Required ACL:** `confd.asterisk.queue.general.update` **WARNING** This endpoint restore to default value or delete all fields that are not defined.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return AsteriskAPIUpdateAsteriskQueueGeneralRequest
*/
func (a *AsteriskAPIService) UpdateAsteriskQueueGeneral(ctx context.Context) AsteriskAPIUpdateAsteriskQueueGeneralRequest {
	return AsteriskAPIUpdateAsteriskQueueGeneralRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
func (a *AsteriskAPIService) UpdateAsteriskQueueGeneralExecute(r AsteriskAPIUpdateAsteriskQueueGeneralRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodPut
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AsteriskAPIService.UpdateAsteriskQueueGeneral")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/asterisk/queues/general"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return nil, reportError("body is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["accent_auth_token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Auth-Token"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v []string
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v []string
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type AsteriskAPIUpdateAsteriskRtpGeneralRequest struct {
	ctx        context.Context
	ApiService AsteriskAPI
	body       *RTPConfiguration
}

func (r AsteriskAPIUpdateAsteriskRtpGeneralRequest) Body(body RTPConfiguration) AsteriskAPIUpdateAsteriskRtpGeneralRequest {
	r.body = &body
	return r
}

func (r AsteriskAPIUpdateAsteriskRtpGeneralRequest) Execute() (*http.Response, error) {
	return r.ApiService.UpdateAsteriskRtpGeneralExecute(r)
}

/*
UpdateAsteriskRtpGeneral Update RTP general option

**Required ACL:** `confd.asterisk.rtp.general.update` **WARNING** This endpoint restore to default value or delete all fields that are not defined.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return AsteriskAPIUpdateAsteriskRtpGeneralRequest
*/
func (a *AsteriskAPIService) UpdateAsteriskRtpGeneral(ctx context.Context) AsteriskAPIUpdateAsteriskRtpGeneralRequest {
	return AsteriskAPIUpdateAsteriskRtpGeneralRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
func (a *AsteriskAPIService) UpdateAsteriskRtpGeneralExecute(r AsteriskAPIUpdateAsteriskRtpGeneralRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodPut
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AsteriskAPIService.UpdateAsteriskRtpGeneral")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/asterisk/rtp/general"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return nil, reportError("body is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["accent_auth_token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Auth-Token"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v []string
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v []string
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type AsteriskAPIUpdateAsteriskRtpIceHostCandidatesRequest struct {
	ctx        context.Context
	ApiService AsteriskAPI
	body       *RTPConfiguration
}

func (r AsteriskAPIUpdateAsteriskRtpIceHostCandidatesRequest) Body(body RTPConfiguration) AsteriskAPIUpdateAsteriskRtpIceHostCandidatesRequest {
	r.body = &body
	return r
}

func (r AsteriskAPIUpdateAsteriskRtpIceHostCandidatesRequest) Execute() (*http.Response, error) {
	return r.ApiService.UpdateAsteriskRtpIceHostCandidatesExecute(r)
}

/*
UpdateAsteriskRtpIceHostCandidates Update RTP ice_host_candidates option

**Required ACL:** `confd.asterisk.rtp.ice_host_candidates.update` **WARNING** This endpoint restore to default value or delete all fields that are not defined.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return AsteriskAPIUpdateAsteriskRtpIceHostCandidatesRequest
*/
func (a *AsteriskAPIService) UpdateAsteriskRtpIceHostCandidates(ctx context.Context) AsteriskAPIUpdateAsteriskRtpIceHostCandidatesRequest {
	return AsteriskAPIUpdateAsteriskRtpIceHostCandidatesRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
func (a *AsteriskAPIService) UpdateAsteriskRtpIceHostCandidatesExecute(r AsteriskAPIUpdateAsteriskRtpIceHostCandidatesRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodPut
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AsteriskAPIService.UpdateAsteriskRtpIceHostCandidates")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/asterisk/rtp/ice_host_candidates"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return nil, reportError("body is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["accent_auth_token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Auth-Token"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v []string
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v []string
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type AsteriskAPIUpdateAsteriskSccpGeneralRequest struct {
	ctx        context.Context
	ApiService AsteriskAPI
	body       *SCCPGeneral
}

func (r AsteriskAPIUpdateAsteriskSccpGeneralRequest) Body(body SCCPGeneral) AsteriskAPIUpdateAsteriskSccpGeneralRequest {
	r.body = &body
	return r
}

func (r AsteriskAPIUpdateAsteriskSccpGeneralRequest) Execute() (*http.Response, error) {
	return r.ApiService.UpdateAsteriskSccpGeneralExecute(r)
}

/*
UpdateAsteriskSccpGeneral Update SCCP general option

**Required ACL:** `confd.asterisk.sccp.general.update` **WARNING** This endpoint restore to default value or delete all fields that are not defined.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return AsteriskAPIUpdateAsteriskSccpGeneralRequest
*/
func (a *AsteriskAPIService) UpdateAsteriskSccpGeneral(ctx context.Context) AsteriskAPIUpdateAsteriskSccpGeneralRequest {
	return AsteriskAPIUpdateAsteriskSccpGeneralRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
func (a *AsteriskAPIService) UpdateAsteriskSccpGeneralExecute(r AsteriskAPIUpdateAsteriskSccpGeneralRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodPut
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AsteriskAPIService.UpdateAsteriskSccpGeneral")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/asterisk/sccp/general"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return nil, reportError("body is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["accent_auth_token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Auth-Token"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v []string
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v []string
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type AsteriskAPIUpdateAsteriskVoicemailGeneralRequest struct {
	ctx        context.Context
	ApiService AsteriskAPI
	body       *VoicemailGeneral
}

func (r AsteriskAPIUpdateAsteriskVoicemailGeneralRequest) Body(body VoicemailGeneral) AsteriskAPIUpdateAsteriskVoicemailGeneralRequest {
	r.body = &body
	return r
}

func (r AsteriskAPIUpdateAsteriskVoicemailGeneralRequest) Execute() (*http.Response, error) {
	return r.ApiService.UpdateAsteriskVoicemailGeneralExecute(r)
}

/*
UpdateAsteriskVoicemailGeneral Update Voicemail general option

**Required ACL:** `confd.asterisk.voicemail.general.update` **WARNING** This endpoint restore to default value or delete all fields that are not defined.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return AsteriskAPIUpdateAsteriskVoicemailGeneralRequest
*/
func (a *AsteriskAPIService) UpdateAsteriskVoicemailGeneral(ctx context.Context) AsteriskAPIUpdateAsteriskVoicemailGeneralRequest {
	return AsteriskAPIUpdateAsteriskVoicemailGeneralRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
func (a *AsteriskAPIService) UpdateAsteriskVoicemailGeneralExecute(r AsteriskAPIUpdateAsteriskVoicemailGeneralRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodPut
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AsteriskAPIService.UpdateAsteriskVoicemailGeneral")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/asterisk/voicemail/general"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return nil, reportError("body is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["accent_auth_token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Auth-Token"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v []string
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v []string
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type AsteriskAPIUpdateAsteriskVoicemailZonemessagesRequest struct {
	ctx        context.Context
	ApiService AsteriskAPI
	body       *VoicemailZoneMessages
}

func (r AsteriskAPIUpdateAsteriskVoicemailZonemessagesRequest) Body(body VoicemailZoneMessages) AsteriskAPIUpdateAsteriskVoicemailZonemessagesRequest {
	r.body = &body
	return r
}

func (r AsteriskAPIUpdateAsteriskVoicemailZonemessagesRequest) Execute() (*http.Response, error) {
	return r.ApiService.UpdateAsteriskVoicemailZonemessagesExecute(r)
}

/*
UpdateAsteriskVoicemailZonemessages Update Voicemail zonemessages option

**Required ACL:** `confd.asterisk.voicemail.zonemessages.update` **WARNING** This endpoint restore to default value or delete all fields that are not defined.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return AsteriskAPIUpdateAsteriskVoicemailZonemessagesRequest
*/
func (a *AsteriskAPIService) UpdateAsteriskVoicemailZonemessages(ctx context.Context) AsteriskAPIUpdateAsteriskVoicemailZonemessagesRequest {
	return AsteriskAPIUpdateAsteriskVoicemailZonemessagesRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
func (a *AsteriskAPIService) UpdateAsteriskVoicemailZonemessagesExecute(r AsteriskAPIUpdateAsteriskVoicemailZonemessagesRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodPut
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AsteriskAPIService.UpdateAsteriskVoicemailZonemessages")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/asterisk/voicemail/zonemessages"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return nil, reportError("body is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["accent_auth_token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Auth-Token"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v []string
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v []string
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

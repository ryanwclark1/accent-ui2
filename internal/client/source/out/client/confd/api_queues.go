/*
accent-confd

Confd exposes an API for managing core resources on a Accent server such as users, extensions, devices, voicemails, queues, etc. Resources can be associated together to provide additional functionality. For example: By associating a voicemail with a user, calls will automatically fallback on to the voicemail when the user cannot answer.  Implementation notes ====================  Errors ------  Responses containing errors will have a status code in the 400 or 500 class. A list of error messages will be returned in the body of the response as a JSON-encoded array:  ~~~ [     \"Input error - User not found\",     \"Resource error - User not associated to a line\" ] ~~~   Updating resources via PUT --------------------------  When updating a resource, all fields become optional. In other words, only values that have been changed need to be sent to the server. Please note that this behavior may change in future versions of the API.

API version: 1.1
Contact: help@accentvoice.io
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package confd

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"strings"
)

type QueuesAPI interface {

	/*
		AssociateQueueExtension Associate queue and extension

		**Required ACL:** `confd.queues.{queue_id}.extensions.{extension_id}.update`

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param queueId queue's ID
		@param extensionId
		@return ApiAssociateQueueExtensionRequest
	*/
	AssociateQueueExtension(ctx context.Context, queueId int32, extensionId int32) ApiAssociateQueueExtensionRequest

	// AssociateQueueExtensionExecute executes the request
	AssociateQueueExtensionExecute(r ApiAssociateQueueExtensionRequest) (*http.Response, error)

	/*
		AssociateQueueSchedule Associate queue and schedule

		**Required ACL:** `confd.queues.{queue_id}.schedules.{schedule_id}.update`

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param queueId queue's ID
		@param scheduleId Schedule's ID
		@return ApiAssociateQueueScheduleRequest
	*/
	AssociateQueueSchedule(ctx context.Context, queueId int32, scheduleId int32) ApiAssociateQueueScheduleRequest

	// AssociateQueueScheduleExecute executes the request
	AssociateQueueScheduleExecute(r ApiAssociateQueueScheduleRequest) (*http.Response, error)

	/*
		CreateQueue Create queue

		**Required ACL:** `confd.queues.create`

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@return ApiCreateQueueRequest
	*/
	CreateQueue(ctx context.Context) ApiCreateQueueRequest

	// CreateQueueExecute executes the request
	//  @return Queue
	CreateQueueExecute(r ApiCreateQueueRequest) (*Queue, *http.Response, error)

	/*
		CreateSkillRule Create skill rule

		**Required ACL:** `confd.queues.skillrules.create`

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@return ApiCreateSkillRuleRequest
	*/
	CreateSkillRule(ctx context.Context) ApiCreateSkillRuleRequest

	// CreateSkillRuleExecute executes the request
	//  @return SkillRule
	CreateSkillRuleExecute(r ApiCreateSkillRuleRequest) (*SkillRule, *http.Response, error)

	/*
		DeleteQueue Delete queue

		**Required ACL:** `confd.queues.{queue_id}.delete`

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param queueId queue's ID
		@return ApiDeleteQueueRequest
	*/
	DeleteQueue(ctx context.Context, queueId int32) ApiDeleteQueueRequest

	// DeleteQueueExecute executes the request
	DeleteQueueExecute(r ApiDeleteQueueRequest) (*http.Response, error)

	/*
		DeleteSkillRule Delete skill rule

		**Required ACL:** `confd.queues.skillrules.{skillrule_id}.delete`

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param skillruleId Skill's ID
		@return ApiDeleteSkillRuleRequest
	*/
	DeleteSkillRule(ctx context.Context, skillruleId int32) ApiDeleteSkillRuleRequest

	// DeleteSkillRuleExecute executes the request
	DeleteSkillRuleExecute(r ApiDeleteSkillRuleRequest) (*http.Response, error)

	/*
		DissociateAgentQueue Dissociate agent and queue

		**Required ACL:** `confd.queues.{queue_id}.members.agents.{agent_id}.delete`

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param queueId queue's ID
		@param agentId Agent’s ID
		@return ApiDissociateAgentQueueRequest
	*/
	DissociateAgentQueue(ctx context.Context, queueId int32, agentId int32) ApiDissociateAgentQueueRequest

	// DissociateAgentQueueExecute executes the request
	DissociateAgentQueueExecute(r ApiDissociateAgentQueueRequest) (*http.Response, error)

	/*
		DissociateQueueExtension Dissociate queue and extension

		**Required ACL:** `confd.queues.{queue_id}.extensions.{extension_id}.delete`

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param queueId queue's ID
		@param extensionId
		@return ApiDissociateQueueExtensionRequest
	*/
	DissociateQueueExtension(ctx context.Context, queueId int32, extensionId int32) ApiDissociateQueueExtensionRequest

	// DissociateQueueExtensionExecute executes the request
	DissociateQueueExtensionExecute(r ApiDissociateQueueExtensionRequest) (*http.Response, error)

	/*
		DissociateQueueSchedule Dissociate queue and schedule

		**Required ACL:** `confd.queues.{queue_id}.schedules.{schedule_id}.delete`

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param queueId queue's ID
		@param scheduleId Schedule's ID
		@return ApiDissociateQueueScheduleRequest
	*/
	DissociateQueueSchedule(ctx context.Context, queueId int32, scheduleId int32) ApiDissociateQueueScheduleRequest

	// DissociateQueueScheduleExecute executes the request
	DissociateQueueScheduleExecute(r ApiDissociateQueueScheduleRequest) (*http.Response, error)

	/*
		DissociateUserQueue Dissociate user and queue

		**Required ACL:** `confd.queues.{queue_id}.members.users.{user_id}.delete`

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param queueId queue's ID
		@param userId the user's ID or UUID
		@return ApiDissociateUserQueueRequest
	*/
	DissociateUserQueue(ctx context.Context, queueId int32, userId string) ApiDissociateUserQueueRequest

	// DissociateUserQueueExecute executes the request
	DissociateUserQueueExecute(r ApiDissociateUserQueueRequest) (*http.Response, error)

	/*
		GetQueue Get queue

		**Required ACL:** `confd.queues.{queue_id}.read`

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param queueId queue's ID
		@return ApiGetQueueRequest
	*/
	GetQueue(ctx context.Context, queueId int32) ApiGetQueueRequest

	// GetQueueExecute executes the request
	//  @return Queue
	GetQueueExecute(r ApiGetQueueRequest) (*Queue, *http.Response, error)

	/*
		GetQueueFallback List all fallbacks for queue

		**Required ACL:** `confd.queues.{queue_id}.fallbacks.read`

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param queueId queue's ID
		@return ApiGetQueueFallbackRequest
	*/
	GetQueueFallback(ctx context.Context, queueId int32) ApiGetQueueFallbackRequest

	// GetQueueFallbackExecute executes the request
	//  @return QueueFallbacks
	GetQueueFallbackExecute(r ApiGetQueueFallbackRequest) (*QueueFallbacks, *http.Response, error)

	/*
		GetSkillRule Get skill rule

		**Required ACL:** `confd.queues.skillrules.{skillrule_id}.read`

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param skillruleId Skill's ID
		@return ApiGetSkillRuleRequest
	*/
	GetSkillRule(ctx context.Context, skillruleId int32) ApiGetSkillRuleRequest

	// GetSkillRuleExecute executes the request
	//  @return SkillRule
	GetSkillRuleExecute(r ApiGetSkillRuleRequest) (*SkillRule, *http.Response, error)

	/*
		ListQueues List queues

		**Required ACL:** `confd.queues.read`

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@return ApiListQueuesRequest
	*/
	ListQueues(ctx context.Context) ApiListQueuesRequest

	// ListQueuesExecute executes the request
	//  @return QueueItems
	ListQueuesExecute(r ApiListQueuesRequest) (*QueueItems, *http.Response, error)

	/*
		ListSkillRules List skill rule

		**Required ACL:** `confd.queues.skillrules.read`

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@return ApiListSkillRulesRequest
	*/
	ListSkillRules(ctx context.Context) ApiListSkillRulesRequest

	// ListSkillRulesExecute executes the request
	//  @return SkillRuleItems
	ListSkillRulesExecute(r ApiListSkillRulesRequest) (*SkillRuleItems, *http.Response, error)

	/*
		UpdateAgentQueueAssociation Update Agent-Queue association

		**Required ACL:** `confd.queues.{queue_id}.members.agents.{agent_id}.update`

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param queueId queue's ID
		@param agentId Agent’s ID
		@return ApiUpdateAgentQueueAssociationRequest
	*/
	UpdateAgentQueueAssociation(ctx context.Context, queueId int32, agentId int32) ApiUpdateAgentQueueAssociationRequest

	// UpdateAgentQueueAssociationExecute executes the request
	UpdateAgentQueueAssociationExecute(r ApiUpdateAgentQueueAssociationRequest) (*http.Response, error)

	/*
		UpdateQueue Update queue

		**Required ACL:** `confd.queues.{queue_id}.update`

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param queueId queue's ID
		@return ApiUpdateQueueRequest
	*/
	UpdateQueue(ctx context.Context, queueId int32) ApiUpdateQueueRequest

	// UpdateQueueExecute executes the request
	UpdateQueueExecute(r ApiUpdateQueueRequest) (*http.Response, error)

	/*
		UpdateQueueFallback Update queue's fallbacks

		**Required ACL:** `confd.queues.{queue_id}.fallbacks.update`

	**WARNING** This endpoint delete all fields that are not defined.

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param queueId queue's ID
		@return ApiUpdateQueueFallbackRequest
	*/
	UpdateQueueFallback(ctx context.Context, queueId int32) ApiUpdateQueueFallbackRequest

	// UpdateQueueFallbackExecute executes the request
	UpdateQueueFallbackExecute(r ApiUpdateQueueFallbackRequest) (*http.Response, error)

	/*
		UpdateSkillRule Update skill rule

		**Required ACL:** `confd.queues.skillrules.{skillrule_id}.update`

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param skillruleId Skill's ID
		@return ApiUpdateSkillRuleRequest
	*/
	UpdateSkillRule(ctx context.Context, skillruleId int32) ApiUpdateSkillRuleRequest

	// UpdateSkillRuleExecute executes the request
	UpdateSkillRuleExecute(r ApiUpdateSkillRuleRequest) (*http.Response, error)

	/*
		UpdateUserQueueAssociation Update User-Queue association

		**Required ACL:** `confd.queues.{queue_id}.members.users.{user_id}.update`

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param queueId queue's ID
		@param userId the user's ID or UUID
		@return ApiUpdateUserQueueAssociationRequest
	*/
	UpdateUserQueueAssociation(ctx context.Context, queueId int32, userId string) ApiUpdateUserQueueAssociationRequest

	// UpdateUserQueueAssociationExecute executes the request
	UpdateUserQueueAssociationExecute(r ApiUpdateUserQueueAssociationRequest) (*http.Response, error)
}

// QueuesAPIService QueuesAPI service
type QueuesAPIService service

type ApiAssociateQueueExtensionRequest struct {
	ctx          context.Context
	ApiService   QueuesAPI
	queueId      int32
	extensionId  int32
	accentTenant *string
}

// The tenant&#39;s UUID, defining the ownership of a given resource.
func (r ApiAssociateQueueExtensionRequest) AccentTenant(accentTenant string) ApiAssociateQueueExtensionRequest {
	r.accentTenant = &accentTenant
	return r
}

func (r ApiAssociateQueueExtensionRequest) Execute() (*http.Response, error) {
	return r.ApiService.AssociateQueueExtensionExecute(r)
}

/*
AssociateQueueExtension Associate queue and extension

**Required ACL:** `confd.queues.{queue_id}.extensions.{extension_id}.update`

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param queueId queue's ID
	@param extensionId
	@return ApiAssociateQueueExtensionRequest
*/
func (a *QueuesAPIService) AssociateQueueExtension(ctx context.Context, queueId int32, extensionId int32) ApiAssociateQueueExtensionRequest {
	return ApiAssociateQueueExtensionRequest{
		ApiService:  a,
		ctx:         ctx,
		queueId:     queueId,
		extensionId: extensionId,
	}
}

// Execute executes the request
func (a *QueuesAPIService) AssociateQueueExtensionExecute(r ApiAssociateQueueExtensionRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodPut
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "QueuesAPIService.AssociateQueueExtension")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/queues/{queue_id}/extensions/{extension_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"queue_id"+"}", url.PathEscape(parameterValueToString(r.queueId, "queueId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"extension_id"+"}", url.PathEscape(parameterValueToString(r.extensionId, "extensionId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.accentTenant != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accent-Tenant", r.accentTenant, "")
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["accent_auth_token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Auth-Token"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v []string
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v []string
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiAssociateQueueScheduleRequest struct {
	ctx          context.Context
	ApiService   QueuesAPI
	queueId      int32
	scheduleId   int32
	accentTenant *string
}

// The tenant&#39;s UUID, defining the ownership of a given resource.
func (r ApiAssociateQueueScheduleRequest) AccentTenant(accentTenant string) ApiAssociateQueueScheduleRequest {
	r.accentTenant = &accentTenant
	return r
}

func (r ApiAssociateQueueScheduleRequest) Execute() (*http.Response, error) {
	return r.ApiService.AssociateQueueScheduleExecute(r)
}

/*
AssociateQueueSchedule Associate queue and schedule

**Required ACL:** `confd.queues.{queue_id}.schedules.{schedule_id}.update`

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param queueId queue's ID
	@param scheduleId Schedule's ID
	@return ApiAssociateQueueScheduleRequest
*/
func (a *QueuesAPIService) AssociateQueueSchedule(ctx context.Context, queueId int32, scheduleId int32) ApiAssociateQueueScheduleRequest {
	return ApiAssociateQueueScheduleRequest{
		ApiService: a,
		ctx:        ctx,
		queueId:    queueId,
		scheduleId: scheduleId,
	}
}

// Execute executes the request
func (a *QueuesAPIService) AssociateQueueScheduleExecute(r ApiAssociateQueueScheduleRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodPut
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "QueuesAPIService.AssociateQueueSchedule")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/queues/{queue_id}/schedules/{schedule_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"queue_id"+"}", url.PathEscape(parameterValueToString(r.queueId, "queueId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"schedule_id"+"}", url.PathEscape(parameterValueToString(r.scheduleId, "scheduleId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.accentTenant != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accent-Tenant", r.accentTenant, "")
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["accent_auth_token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Auth-Token"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v []string
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v []string
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiCreateQueueRequest struct {
	ctx          context.Context
	ApiService   QueuesAPI
	body         *Queue
	accentTenant *string
}

// Queue to create
func (r ApiCreateQueueRequest) Body(body Queue) ApiCreateQueueRequest {
	r.body = &body
	return r
}

// The tenant&#39;s UUID, defining the ownership of a given resource.
func (r ApiCreateQueueRequest) AccentTenant(accentTenant string) ApiCreateQueueRequest {
	r.accentTenant = &accentTenant
	return r
}

func (r ApiCreateQueueRequest) Execute() (*Queue, *http.Response, error) {
	return r.ApiService.CreateQueueExecute(r)
}

/*
CreateQueue Create queue

**Required ACL:** `confd.queues.create`

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiCreateQueueRequest
*/
func (a *QueuesAPIService) CreateQueue(ctx context.Context) ApiCreateQueueRequest {
	return ApiCreateQueueRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return Queue
func (a *QueuesAPIService) CreateQueueExecute(r ApiCreateQueueRequest) (*Queue, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *Queue
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "QueuesAPIService.CreateQueue")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/queues"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("body is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.accentTenant != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accent-Tenant", r.accentTenant, "")
	}
	// body params
	localVarPostBody = r.body
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["accent_auth_token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Auth-Token"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v []string
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCreateSkillRuleRequest struct {
	ctx          context.Context
	ApiService   QueuesAPI
	body         *SkillRule
	accentTenant *string
}

// Skill rule to create
func (r ApiCreateSkillRuleRequest) Body(body SkillRule) ApiCreateSkillRuleRequest {
	r.body = &body
	return r
}

// The tenant&#39;s UUID, defining the ownership of a given resource.
func (r ApiCreateSkillRuleRequest) AccentTenant(accentTenant string) ApiCreateSkillRuleRequest {
	r.accentTenant = &accentTenant
	return r
}

func (r ApiCreateSkillRuleRequest) Execute() (*SkillRule, *http.Response, error) {
	return r.ApiService.CreateSkillRuleExecute(r)
}

/*
CreateSkillRule Create skill rule

**Required ACL:** `confd.queues.skillrules.create`

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiCreateSkillRuleRequest
*/
func (a *QueuesAPIService) CreateSkillRule(ctx context.Context) ApiCreateSkillRuleRequest {
	return ApiCreateSkillRuleRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return SkillRule
func (a *QueuesAPIService) CreateSkillRuleExecute(r ApiCreateSkillRuleRequest) (*SkillRule, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *SkillRule
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "QueuesAPIService.CreateSkillRule")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/queues/skillrules"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("body is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.accentTenant != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accent-Tenant", r.accentTenant, "")
	}
	// body params
	localVarPostBody = r.body
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["accent_auth_token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Auth-Token"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v []string
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDeleteQueueRequest struct {
	ctx          context.Context
	ApiService   QueuesAPI
	queueId      int32
	accentTenant *string
}

// The tenant&#39;s UUID, defining the ownership of a given resource.
func (r ApiDeleteQueueRequest) AccentTenant(accentTenant string) ApiDeleteQueueRequest {
	r.accentTenant = &accentTenant
	return r
}

func (r ApiDeleteQueueRequest) Execute() (*http.Response, error) {
	return r.ApiService.DeleteQueueExecute(r)
}

/*
DeleteQueue Delete queue

**Required ACL:** `confd.queues.{queue_id}.delete`

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param queueId queue's ID
	@return ApiDeleteQueueRequest
*/
func (a *QueuesAPIService) DeleteQueue(ctx context.Context, queueId int32) ApiDeleteQueueRequest {
	return ApiDeleteQueueRequest{
		ApiService: a,
		ctx:        ctx,
		queueId:    queueId,
	}
}

// Execute executes the request
func (a *QueuesAPIService) DeleteQueueExecute(r ApiDeleteQueueRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodDelete
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "QueuesAPIService.DeleteQueue")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/queues/{queue_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"queue_id"+"}", url.PathEscape(parameterValueToString(r.queueId, "queueId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.accentTenant != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accent-Tenant", r.accentTenant, "")
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["accent_auth_token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Auth-Token"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v []string
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v []string
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiDeleteSkillRuleRequest struct {
	ctx          context.Context
	ApiService   QueuesAPI
	skillruleId  int32
	accentTenant *string
}

// The tenant&#39;s UUID, defining the ownership of a given resource.
func (r ApiDeleteSkillRuleRequest) AccentTenant(accentTenant string) ApiDeleteSkillRuleRequest {
	r.accentTenant = &accentTenant
	return r
}

func (r ApiDeleteSkillRuleRequest) Execute() (*http.Response, error) {
	return r.ApiService.DeleteSkillRuleExecute(r)
}

/*
DeleteSkillRule Delete skill rule

**Required ACL:** `confd.queues.skillrules.{skillrule_id}.delete`

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param skillruleId Skill's ID
	@return ApiDeleteSkillRuleRequest
*/
func (a *QueuesAPIService) DeleteSkillRule(ctx context.Context, skillruleId int32) ApiDeleteSkillRuleRequest {
	return ApiDeleteSkillRuleRequest{
		ApiService:  a,
		ctx:         ctx,
		skillruleId: skillruleId,
	}
}

// Execute executes the request
func (a *QueuesAPIService) DeleteSkillRuleExecute(r ApiDeleteSkillRuleRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodDelete
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "QueuesAPIService.DeleteSkillRule")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/queues/skillrules/{skillrule_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"skillrule_id"+"}", url.PathEscape(parameterValueToString(r.skillruleId, "skillruleId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.accentTenant != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accent-Tenant", r.accentTenant, "")
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["accent_auth_token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Auth-Token"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v []string
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v []string
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiDissociateAgentQueueRequest struct {
	ctx          context.Context
	ApiService   QueuesAPI
	queueId      int32
	agentId      int32
	accentTenant *string
}

// The tenant&#39;s UUID, defining the ownership of a given resource.
func (r ApiDissociateAgentQueueRequest) AccentTenant(accentTenant string) ApiDissociateAgentQueueRequest {
	r.accentTenant = &accentTenant
	return r
}

func (r ApiDissociateAgentQueueRequest) Execute() (*http.Response, error) {
	return r.ApiService.DissociateAgentQueueExecute(r)
}

/*
DissociateAgentQueue Dissociate agent and queue

**Required ACL:** `confd.queues.{queue_id}.members.agents.{agent_id}.delete`

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param queueId queue's ID
	@param agentId Agent’s ID
	@return ApiDissociateAgentQueueRequest
*/
func (a *QueuesAPIService) DissociateAgentQueue(ctx context.Context, queueId int32, agentId int32) ApiDissociateAgentQueueRequest {
	return ApiDissociateAgentQueueRequest{
		ApiService: a,
		ctx:        ctx,
		queueId:    queueId,
		agentId:    agentId,
	}
}

// Execute executes the request
func (a *QueuesAPIService) DissociateAgentQueueExecute(r ApiDissociateAgentQueueRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodDelete
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "QueuesAPIService.DissociateAgentQueue")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/queues/{queue_id}/members/agents/{agent_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"queue_id"+"}", url.PathEscape(parameterValueToString(r.queueId, "queueId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"agent_id"+"}", url.PathEscape(parameterValueToString(r.agentId, "agentId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.accentTenant != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accent-Tenant", r.accentTenant, "")
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["accent_auth_token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Auth-Token"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v []string
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v []string
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiDissociateQueueExtensionRequest struct {
	ctx          context.Context
	ApiService   QueuesAPI
	queueId      int32
	extensionId  int32
	accentTenant *string
}

// The tenant&#39;s UUID, defining the ownership of a given resource.
func (r ApiDissociateQueueExtensionRequest) AccentTenant(accentTenant string) ApiDissociateQueueExtensionRequest {
	r.accentTenant = &accentTenant
	return r
}

func (r ApiDissociateQueueExtensionRequest) Execute() (*http.Response, error) {
	return r.ApiService.DissociateQueueExtensionExecute(r)
}

/*
DissociateQueueExtension Dissociate queue and extension

**Required ACL:** `confd.queues.{queue_id}.extensions.{extension_id}.delete`

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param queueId queue's ID
	@param extensionId
	@return ApiDissociateQueueExtensionRequest
*/
func (a *QueuesAPIService) DissociateQueueExtension(ctx context.Context, queueId int32, extensionId int32) ApiDissociateQueueExtensionRequest {
	return ApiDissociateQueueExtensionRequest{
		ApiService:  a,
		ctx:         ctx,
		queueId:     queueId,
		extensionId: extensionId,
	}
}

// Execute executes the request
func (a *QueuesAPIService) DissociateQueueExtensionExecute(r ApiDissociateQueueExtensionRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodDelete
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "QueuesAPIService.DissociateQueueExtension")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/queues/{queue_id}/extensions/{extension_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"queue_id"+"}", url.PathEscape(parameterValueToString(r.queueId, "queueId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"extension_id"+"}", url.PathEscape(parameterValueToString(r.extensionId, "extensionId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.accentTenant != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accent-Tenant", r.accentTenant, "")
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["accent_auth_token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Auth-Token"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v []string
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v []string
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiDissociateQueueScheduleRequest struct {
	ctx          context.Context
	ApiService   QueuesAPI
	queueId      int32
	scheduleId   int32
	accentTenant *string
}

// The tenant&#39;s UUID, defining the ownership of a given resource.
func (r ApiDissociateQueueScheduleRequest) AccentTenant(accentTenant string) ApiDissociateQueueScheduleRequest {
	r.accentTenant = &accentTenant
	return r
}

func (r ApiDissociateQueueScheduleRequest) Execute() (*http.Response, error) {
	return r.ApiService.DissociateQueueScheduleExecute(r)
}

/*
DissociateQueueSchedule Dissociate queue and schedule

**Required ACL:** `confd.queues.{queue_id}.schedules.{schedule_id}.delete`

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param queueId queue's ID
	@param scheduleId Schedule's ID
	@return ApiDissociateQueueScheduleRequest
*/
func (a *QueuesAPIService) DissociateQueueSchedule(ctx context.Context, queueId int32, scheduleId int32) ApiDissociateQueueScheduleRequest {
	return ApiDissociateQueueScheduleRequest{
		ApiService: a,
		ctx:        ctx,
		queueId:    queueId,
		scheduleId: scheduleId,
	}
}

// Execute executes the request
func (a *QueuesAPIService) DissociateQueueScheduleExecute(r ApiDissociateQueueScheduleRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodDelete
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "QueuesAPIService.DissociateQueueSchedule")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/queues/{queue_id}/schedules/{schedule_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"queue_id"+"}", url.PathEscape(parameterValueToString(r.queueId, "queueId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"schedule_id"+"}", url.PathEscape(parameterValueToString(r.scheduleId, "scheduleId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.accentTenant != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accent-Tenant", r.accentTenant, "")
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["accent_auth_token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Auth-Token"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v []string
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v []string
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiDissociateUserQueueRequest struct {
	ctx          context.Context
	ApiService   QueuesAPI
	queueId      int32
	userId       string
	accentTenant *string
}

// The tenant&#39;s UUID, defining the ownership of a given resource.
func (r ApiDissociateUserQueueRequest) AccentTenant(accentTenant string) ApiDissociateUserQueueRequest {
	r.accentTenant = &accentTenant
	return r
}

func (r ApiDissociateUserQueueRequest) Execute() (*http.Response, error) {
	return r.ApiService.DissociateUserQueueExecute(r)
}

/*
DissociateUserQueue Dissociate user and queue

**Required ACL:** `confd.queues.{queue_id}.members.users.{user_id}.delete`

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param queueId queue's ID
	@param userId the user's ID or UUID
	@return ApiDissociateUserQueueRequest
*/
func (a *QueuesAPIService) DissociateUserQueue(ctx context.Context, queueId int32, userId string) ApiDissociateUserQueueRequest {
	return ApiDissociateUserQueueRequest{
		ApiService: a,
		ctx:        ctx,
		queueId:    queueId,
		userId:     userId,
	}
}

// Execute executes the request
func (a *QueuesAPIService) DissociateUserQueueExecute(r ApiDissociateUserQueueRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodDelete
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "QueuesAPIService.DissociateUserQueue")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/queues/{queue_id}/members/users/{user_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"queue_id"+"}", url.PathEscape(parameterValueToString(r.queueId, "queueId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"user_id"+"}", url.PathEscape(parameterValueToString(r.userId, "userId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.accentTenant != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accent-Tenant", r.accentTenant, "")
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["accent_auth_token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Auth-Token"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v []string
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v []string
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiGetQueueRequest struct {
	ctx          context.Context
	ApiService   QueuesAPI
	queueId      int32
	accentTenant *string
}

// The tenant&#39;s UUID, defining the ownership of a given resource.
func (r ApiGetQueueRequest) AccentTenant(accentTenant string) ApiGetQueueRequest {
	r.accentTenant = &accentTenant
	return r
}

func (r ApiGetQueueRequest) Execute() (*Queue, *http.Response, error) {
	return r.ApiService.GetQueueExecute(r)
}

/*
GetQueue Get queue

**Required ACL:** `confd.queues.{queue_id}.read`

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param queueId queue's ID
	@return ApiGetQueueRequest
*/
func (a *QueuesAPIService) GetQueue(ctx context.Context, queueId int32) ApiGetQueueRequest {
	return ApiGetQueueRequest{
		ApiService: a,
		ctx:        ctx,
		queueId:    queueId,
	}
}

// Execute executes the request
//
//	@return Queue
func (a *QueuesAPIService) GetQueueExecute(r ApiGetQueueRequest) (*Queue, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *Queue
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "QueuesAPIService.GetQueue")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/queues/{queue_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"queue_id"+"}", url.PathEscape(parameterValueToString(r.queueId, "queueId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.accentTenant != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accent-Tenant", r.accentTenant, "")
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["accent_auth_token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Auth-Token"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v []string
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetQueueFallbackRequest struct {
	ctx          context.Context
	ApiService   QueuesAPI
	queueId      int32
	accentTenant *string
}

// The tenant&#39;s UUID, defining the ownership of a given resource.
func (r ApiGetQueueFallbackRequest) AccentTenant(accentTenant string) ApiGetQueueFallbackRequest {
	r.accentTenant = &accentTenant
	return r
}

func (r ApiGetQueueFallbackRequest) Execute() (*QueueFallbacks, *http.Response, error) {
	return r.ApiService.GetQueueFallbackExecute(r)
}

/*
GetQueueFallback List all fallbacks for queue

**Required ACL:** `confd.queues.{queue_id}.fallbacks.read`

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param queueId queue's ID
	@return ApiGetQueueFallbackRequest
*/
func (a *QueuesAPIService) GetQueueFallback(ctx context.Context, queueId int32) ApiGetQueueFallbackRequest {
	return ApiGetQueueFallbackRequest{
		ApiService: a,
		ctx:        ctx,
		queueId:    queueId,
	}
}

// Execute executes the request
//
//	@return QueueFallbacks
func (a *QueuesAPIService) GetQueueFallbackExecute(r ApiGetQueueFallbackRequest) (*QueueFallbacks, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *QueueFallbacks
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "QueuesAPIService.GetQueueFallback")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/queues/{queue_id}/fallbacks"
	localVarPath = strings.Replace(localVarPath, "{"+"queue_id"+"}", url.PathEscape(parameterValueToString(r.queueId, "queueId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.accentTenant != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accent-Tenant", r.accentTenant, "")
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["accent_auth_token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Auth-Token"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetSkillRuleRequest struct {
	ctx          context.Context
	ApiService   QueuesAPI
	skillruleId  int32
	accentTenant *string
}

// The tenant&#39;s UUID, defining the ownership of a given resource.
func (r ApiGetSkillRuleRequest) AccentTenant(accentTenant string) ApiGetSkillRuleRequest {
	r.accentTenant = &accentTenant
	return r
}

func (r ApiGetSkillRuleRequest) Execute() (*SkillRule, *http.Response, error) {
	return r.ApiService.GetSkillRuleExecute(r)
}

/*
GetSkillRule Get skill rule

**Required ACL:** `confd.queues.skillrules.{skillrule_id}.read`

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param skillruleId Skill's ID
	@return ApiGetSkillRuleRequest
*/
func (a *QueuesAPIService) GetSkillRule(ctx context.Context, skillruleId int32) ApiGetSkillRuleRequest {
	return ApiGetSkillRuleRequest{
		ApiService:  a,
		ctx:         ctx,
		skillruleId: skillruleId,
	}
}

// Execute executes the request
//
//	@return SkillRule
func (a *QueuesAPIService) GetSkillRuleExecute(r ApiGetSkillRuleRequest) (*SkillRule, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *SkillRule
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "QueuesAPIService.GetSkillRule")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/queues/skillrules/{skillrule_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"skillrule_id"+"}", url.PathEscape(parameterValueToString(r.skillruleId, "skillruleId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.accentTenant != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accent-Tenant", r.accentTenant, "")
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["accent_auth_token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Auth-Token"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v []string
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiListQueuesRequest struct {
	ctx          context.Context
	ApiService   QueuesAPI
	accentTenant *string
	recurse      *bool
	order        *string
	direction    *string
	limit        *int32
	offset       *int32
	search       *string
}

// The tenant&#39;s UUID, defining the ownership of a given resource.
func (r ApiListQueuesRequest) AccentTenant(accentTenant string) ApiListQueuesRequest {
	r.accentTenant = &accentTenant
	return r
}

// Should the query include sub-tenants
func (r ApiListQueuesRequest) Recurse(recurse bool) ApiListQueuesRequest {
	r.recurse = &recurse
	return r
}

// Name of the field to use for sorting the list of items returned.
func (r ApiListQueuesRequest) Order(order string) ApiListQueuesRequest {
	r.order = &order
	return r
}

// Sort list of items in &#39;asc&#39; (ascending) or &#39;desc&#39; (descending) order
func (r ApiListQueuesRequest) Direction(direction string) ApiListQueuesRequest {
	r.direction = &direction
	return r
}

// Maximum number of items to return in the list
func (r ApiListQueuesRequest) Limit(limit int32) ApiListQueuesRequest {
	r.limit = &limit
	return r
}

// Number of items to skip over in the list. Useful for pagination.
func (r ApiListQueuesRequest) Offset(offset int32) ApiListQueuesRequest {
	r.offset = &offset
	return r
}

// Search term for filtering a list of items. Only items with a field containing the search term will be returned.
func (r ApiListQueuesRequest) Search(search string) ApiListQueuesRequest {
	r.search = &search
	return r
}

func (r ApiListQueuesRequest) Execute() (*QueueItems, *http.Response, error) {
	return r.ApiService.ListQueuesExecute(r)
}

/*
ListQueues List queues

**Required ACL:** `confd.queues.read`

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiListQueuesRequest
*/
func (a *QueuesAPIService) ListQueues(ctx context.Context) ApiListQueuesRequest {
	return ApiListQueuesRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return QueueItems
func (a *QueuesAPIService) ListQueuesExecute(r ApiListQueuesRequest) (*QueueItems, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *QueueItems
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "QueuesAPIService.ListQueues")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/queues"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.recurse != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "recurse", r.recurse, "")
	} else {
		var defaultValue bool = false
		r.recurse = &defaultValue
	}
	if r.order != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "order", r.order, "")
	}
	if r.direction != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "direction", r.direction, "")
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "")
	}
	if r.offset != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "offset", r.offset, "")
	}
	if r.search != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "search", r.search, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.accentTenant != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accent-Tenant", r.accentTenant, "")
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["accent_auth_token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Auth-Token"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiListSkillRulesRequest struct {
	ctx          context.Context
	ApiService   QueuesAPI
	accentTenant *string
	recurse      *bool
	order        *string
	direction    *string
	limit        *int32
	offset       *int32
	search       *string
}

// The tenant&#39;s UUID, defining the ownership of a given resource.
func (r ApiListSkillRulesRequest) AccentTenant(accentTenant string) ApiListSkillRulesRequest {
	r.accentTenant = &accentTenant
	return r
}

// Should the query include sub-tenants
func (r ApiListSkillRulesRequest) Recurse(recurse bool) ApiListSkillRulesRequest {
	r.recurse = &recurse
	return r
}

// Name of the field to use for sorting the list of items returned.
func (r ApiListSkillRulesRequest) Order(order string) ApiListSkillRulesRequest {
	r.order = &order
	return r
}

// Sort list of items in &#39;asc&#39; (ascending) or &#39;desc&#39; (descending) order
func (r ApiListSkillRulesRequest) Direction(direction string) ApiListSkillRulesRequest {
	r.direction = &direction
	return r
}

// Maximum number of items to return in the list
func (r ApiListSkillRulesRequest) Limit(limit int32) ApiListSkillRulesRequest {
	r.limit = &limit
	return r
}

// Number of items to skip over in the list. Useful for pagination.
func (r ApiListSkillRulesRequest) Offset(offset int32) ApiListSkillRulesRequest {
	r.offset = &offset
	return r
}

// Search term for filtering a list of items. Only items with a field containing the search term will be returned.
func (r ApiListSkillRulesRequest) Search(search string) ApiListSkillRulesRequest {
	r.search = &search
	return r
}

func (r ApiListSkillRulesRequest) Execute() (*SkillRuleItems, *http.Response, error) {
	return r.ApiService.ListSkillRulesExecute(r)
}

/*
ListSkillRules List skill rule

**Required ACL:** `confd.queues.skillrules.read`

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiListSkillRulesRequest
*/
func (a *QueuesAPIService) ListSkillRules(ctx context.Context) ApiListSkillRulesRequest {
	return ApiListSkillRulesRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return SkillRuleItems
func (a *QueuesAPIService) ListSkillRulesExecute(r ApiListSkillRulesRequest) (*SkillRuleItems, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *SkillRuleItems
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "QueuesAPIService.ListSkillRules")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/queues/skillrules"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.recurse != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "recurse", r.recurse, "")
	} else {
		var defaultValue bool = false
		r.recurse = &defaultValue
	}
	if r.order != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "order", r.order, "")
	}
	if r.direction != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "direction", r.direction, "")
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "")
	}
	if r.offset != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "offset", r.offset, "")
	}
	if r.search != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "search", r.search, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.accentTenant != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accent-Tenant", r.accentTenant, "")
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["accent_auth_token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Auth-Token"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUpdateAgentQueueAssociationRequest struct {
	ctx          context.Context
	ApiService   QueuesAPI
	queueId      int32
	agentId      int32
	body         *QueueMemberAgent
	accentTenant *string
}

func (r ApiUpdateAgentQueueAssociationRequest) Body(body QueueMemberAgent) ApiUpdateAgentQueueAssociationRequest {
	r.body = &body
	return r
}

// The tenant&#39;s UUID, defining the ownership of a given resource.
func (r ApiUpdateAgentQueueAssociationRequest) AccentTenant(accentTenant string) ApiUpdateAgentQueueAssociationRequest {
	r.accentTenant = &accentTenant
	return r
}

func (r ApiUpdateAgentQueueAssociationRequest) Execute() (*http.Response, error) {
	return r.ApiService.UpdateAgentQueueAssociationExecute(r)
}

/*
UpdateAgentQueueAssociation Update Agent-Queue association

**Required ACL:** `confd.queues.{queue_id}.members.agents.{agent_id}.update`

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param queueId queue's ID
	@param agentId Agent’s ID
	@return ApiUpdateAgentQueueAssociationRequest
*/
func (a *QueuesAPIService) UpdateAgentQueueAssociation(ctx context.Context, queueId int32, agentId int32) ApiUpdateAgentQueueAssociationRequest {
	return ApiUpdateAgentQueueAssociationRequest{
		ApiService: a,
		ctx:        ctx,
		queueId:    queueId,
		agentId:    agentId,
	}
}

// Execute executes the request
func (a *QueuesAPIService) UpdateAgentQueueAssociationExecute(r ApiUpdateAgentQueueAssociationRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodPut
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "QueuesAPIService.UpdateAgentQueueAssociation")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/queues/{queue_id}/members/agents/{agent_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"queue_id"+"}", url.PathEscape(parameterValueToString(r.queueId, "queueId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"agent_id"+"}", url.PathEscape(parameterValueToString(r.agentId, "agentId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.accentTenant != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accent-Tenant", r.accentTenant, "")
	}
	// body params
	localVarPostBody = r.body
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["accent_auth_token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Auth-Token"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v []string
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v []string
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiUpdateQueueRequest struct {
	ctx          context.Context
	ApiService   QueuesAPI
	body         *Queue
	queueId      int32
	accentTenant *string
}

func (r ApiUpdateQueueRequest) Body(body Queue) ApiUpdateQueueRequest {
	r.body = &body
	return r
}

// The tenant&#39;s UUID, defining the ownership of a given resource.
func (r ApiUpdateQueueRequest) AccentTenant(accentTenant string) ApiUpdateQueueRequest {
	r.accentTenant = &accentTenant
	return r
}

func (r ApiUpdateQueueRequest) Execute() (*http.Response, error) {
	return r.ApiService.UpdateQueueExecute(r)
}

/*
UpdateQueue Update queue

**Required ACL:** `confd.queues.{queue_id}.update`

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param queueId queue's ID
	@return ApiUpdateQueueRequest
*/
func (a *QueuesAPIService) UpdateQueue(ctx context.Context, queueId int32) ApiUpdateQueueRequest {
	return ApiUpdateQueueRequest{
		ApiService: a,
		ctx:        ctx,
		queueId:    queueId,
	}
}

// Execute executes the request
func (a *QueuesAPIService) UpdateQueueExecute(r ApiUpdateQueueRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodPut
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "QueuesAPIService.UpdateQueue")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/queues/{queue_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"queue_id"+"}", url.PathEscape(parameterValueToString(r.queueId, "queueId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return nil, reportError("body is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.accentTenant != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accent-Tenant", r.accentTenant, "")
	}
	// body params
	localVarPostBody = r.body
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["accent_auth_token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Auth-Token"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v []string
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v []string
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiUpdateQueueFallbackRequest struct {
	ctx          context.Context
	ApiService   QueuesAPI
	queueId      int32
	body         *QueueFallbacks
	accentTenant *string
}

// Fallbacks for queue
func (r ApiUpdateQueueFallbackRequest) Body(body QueueFallbacks) ApiUpdateQueueFallbackRequest {
	r.body = &body
	return r
}

// The tenant&#39;s UUID, defining the ownership of a given resource.
func (r ApiUpdateQueueFallbackRequest) AccentTenant(accentTenant string) ApiUpdateQueueFallbackRequest {
	r.accentTenant = &accentTenant
	return r
}

func (r ApiUpdateQueueFallbackRequest) Execute() (*http.Response, error) {
	return r.ApiService.UpdateQueueFallbackExecute(r)
}

/*
UpdateQueueFallback Update queue's fallbacks

**Required ACL:** `confd.queues.{queue_id}.fallbacks.update`

**WARNING** This endpoint delete all fields that are not defined.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param queueId queue's ID
	@return ApiUpdateQueueFallbackRequest
*/
func (a *QueuesAPIService) UpdateQueueFallback(ctx context.Context, queueId int32) ApiUpdateQueueFallbackRequest {
	return ApiUpdateQueueFallbackRequest{
		ApiService: a,
		ctx:        ctx,
		queueId:    queueId,
	}
}

// Execute executes the request
func (a *QueuesAPIService) UpdateQueueFallbackExecute(r ApiUpdateQueueFallbackRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodPut
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "QueuesAPIService.UpdateQueueFallback")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/queues/{queue_id}/fallbacks"
	localVarPath = strings.Replace(localVarPath, "{"+"queue_id"+"}", url.PathEscape(parameterValueToString(r.queueId, "queueId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.accentTenant != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accent-Tenant", r.accentTenant, "")
	}
	// body params
	localVarPostBody = r.body
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["accent_auth_token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Auth-Token"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v []string
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v []string
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiUpdateSkillRuleRequest struct {
	ctx          context.Context
	ApiService   QueuesAPI
	body         *SkillRule
	skillruleId  int32
	accentTenant *string
}

func (r ApiUpdateSkillRuleRequest) Body(body SkillRule) ApiUpdateSkillRuleRequest {
	r.body = &body
	return r
}

// The tenant&#39;s UUID, defining the ownership of a given resource.
func (r ApiUpdateSkillRuleRequest) AccentTenant(accentTenant string) ApiUpdateSkillRuleRequest {
	r.accentTenant = &accentTenant
	return r
}

func (r ApiUpdateSkillRuleRequest) Execute() (*http.Response, error) {
	return r.ApiService.UpdateSkillRuleExecute(r)
}

/*
UpdateSkillRule Update skill rule

**Required ACL:** `confd.queues.skillrules.{skillrule_id}.update`

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param skillruleId Skill's ID
	@return ApiUpdateSkillRuleRequest
*/
func (a *QueuesAPIService) UpdateSkillRule(ctx context.Context, skillruleId int32) ApiUpdateSkillRuleRequest {
	return ApiUpdateSkillRuleRequest{
		ApiService:  a,
		ctx:         ctx,
		skillruleId: skillruleId,
	}
}

// Execute executes the request
func (a *QueuesAPIService) UpdateSkillRuleExecute(r ApiUpdateSkillRuleRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodPut
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "QueuesAPIService.UpdateSkillRule")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/queues/skillrules/{skillrule_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"skillrule_id"+"}", url.PathEscape(parameterValueToString(r.skillruleId, "skillruleId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return nil, reportError("body is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.accentTenant != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accent-Tenant", r.accentTenant, "")
	}
	// body params
	localVarPostBody = r.body
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["accent_auth_token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Auth-Token"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v []string
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v []string
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiUpdateUserQueueAssociationRequest struct {
	ctx          context.Context
	ApiService   QueuesAPI
	queueId      int32
	userId       string
	body         *QueueMemberUser
	accentTenant *string
}

func (r ApiUpdateUserQueueAssociationRequest) Body(body QueueMemberUser) ApiUpdateUserQueueAssociationRequest {
	r.body = &body
	return r
}

// The tenant&#39;s UUID, defining the ownership of a given resource.
func (r ApiUpdateUserQueueAssociationRequest) AccentTenant(accentTenant string) ApiUpdateUserQueueAssociationRequest {
	r.accentTenant = &accentTenant
	return r
}

func (r ApiUpdateUserQueueAssociationRequest) Execute() (*http.Response, error) {
	return r.ApiService.UpdateUserQueueAssociationExecute(r)
}

/*
UpdateUserQueueAssociation Update User-Queue association

**Required ACL:** `confd.queues.{queue_id}.members.users.{user_id}.update`

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param queueId queue's ID
	@param userId the user's ID or UUID
	@return ApiUpdateUserQueueAssociationRequest
*/
func (a *QueuesAPIService) UpdateUserQueueAssociation(ctx context.Context, queueId int32, userId string) ApiUpdateUserQueueAssociationRequest {
	return ApiUpdateUserQueueAssociationRequest{
		ApiService: a,
		ctx:        ctx,
		queueId:    queueId,
		userId:     userId,
	}
}

// Execute executes the request
func (a *QueuesAPIService) UpdateUserQueueAssociationExecute(r ApiUpdateUserQueueAssociationRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodPut
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "QueuesAPIService.UpdateUserQueueAssociation")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/queues/{queue_id}/members/users/{user_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"queue_id"+"}", url.PathEscape(parameterValueToString(r.queueId, "queueId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"user_id"+"}", url.PathEscape(parameterValueToString(r.userId, "userId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.accentTenant != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accent-Tenant", r.accentTenant, "")
	}
	// body params
	localVarPostBody = r.body
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["accent_auth_token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Auth-Token"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v []string
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v []string
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

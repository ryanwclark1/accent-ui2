/*
accent-confd

Confd exposes an API for managing core resources on a Accent server such as users, extensions, devices, voicemails, queues, etc. Resources can be associated together to provide additional functionality. For example: By associating a voicemail with a user, calls will automatically fallback on to the voicemail when the user cannot answer.  Implementation notes ====================  Errors ------  Responses containing errors will have a status code in the 400 or 500 class. A list of error messages will be returned in the body of the response as a JSON-encoded array:  ~~~ [     \"Input error - User not found\",     \"Resource error - User not associated to a line\" ] ~~~   Updating resources via PUT --------------------------  When updating a resource, all fields become optional. In other words, only values that have been changed need to be sent to the server. Please note that this behavior may change in future versions of the API.

API version: 1.1
Contact: help@accentvoice.io
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package confd

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"strings"
)

type FunckeysAPI interface {

	/*
		AssociateUserFuncKeyTemplate Associate a func key template to a user

		**Required ACL:** `confd.users.{user_id}.funckeys.templates.{template_id}.update`

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param userId the user's ID or UUID
		@param templateId
		@return FunckeysAPIAssociateUserFuncKeyTemplateRequest
	*/
	AssociateUserFuncKeyTemplate(ctx context.Context, userId string, templateId int32) FunckeysAPIAssociateUserFuncKeyTemplateRequest

	// AssociateUserFuncKeyTemplateExecute executes the request
	AssociateUserFuncKeyTemplateExecute(r FunckeysAPIAssociateUserFuncKeyTemplateRequest) (*http.Response, error)

	/*
		CreateFuncKeyTemplate Create a template of func keys

		**Required ACL:** `confd.funckeys.templates.create`

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@return FunckeysAPICreateFuncKeyTemplateRequest
	*/
	CreateFuncKeyTemplate(ctx context.Context) FunckeysAPICreateFuncKeyTemplateRequest

	// CreateFuncKeyTemplateExecute executes the request
	//  @return FuncKeyTemplate
	CreateFuncKeyTemplateExecute(r FunckeysAPICreateFuncKeyTemplateRequest) (*FuncKeyTemplate, *http.Response, error)

	/*
		DeleteFuncKey Remove func key from template

		**Required ACL:** `confd.funckeys.templates.{template_id}.{position}.delete`

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param templateId
		@param position position of the funckey
		@return FunckeysAPIDeleteFuncKeyRequest
	*/
	DeleteFuncKey(ctx context.Context, templateId int32, position int32) FunckeysAPIDeleteFuncKeyRequest

	// DeleteFuncKeyExecute executes the request
	DeleteFuncKeyExecute(r FunckeysAPIDeleteFuncKeyRequest) (*http.Response, error)

	/*
		DeleteFuncKeyTemplate Delete func key template

		**Required ACL:** `confd.funckeys.templates.{template_id}.delete`

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param templateId
		@return FunckeysAPIDeleteFuncKeyTemplateRequest
	*/
	DeleteFuncKeyTemplate(ctx context.Context, templateId int32) FunckeysAPIDeleteFuncKeyTemplateRequest

	// DeleteFuncKeyTemplateExecute executes the request
	DeleteFuncKeyTemplateExecute(r FunckeysAPIDeleteFuncKeyTemplateRequest) (*http.Response, error)

	/*
		DeleteUserFuncKey Remove func key for user

		**Required ACL:** `confd.users.{user_id}.funckeys.{position}.delete`

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param userId the user's ID or UUID
		@param position position of the funckey
		@return FunckeysAPIDeleteUserFuncKeyRequest
	*/
	DeleteUserFuncKey(ctx context.Context, userId string, position int32) FunckeysAPIDeleteUserFuncKeyRequest

	// DeleteUserFuncKeyExecute executes the request
	DeleteUserFuncKeyExecute(r FunckeysAPIDeleteUserFuncKeyRequest) (*http.Response, error)

	/*
		DissociateUserFuncKeyTemplate Dissociate a func key template to a user

		**Required ACL:** `confd.users.{user_id}.funckeys.templates.{template_id}.delete`

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param userId the user's ID or UUID
		@param templateId
		@return FunckeysAPIDissociateUserFuncKeyTemplateRequest
	*/
	DissociateUserFuncKeyTemplate(ctx context.Context, userId string, templateId int32) FunckeysAPIDissociateUserFuncKeyTemplateRequest

	// DissociateUserFuncKeyTemplateExecute executes the request
	DissociateUserFuncKeyTemplateExecute(r FunckeysAPIDissociateUserFuncKeyTemplateRequest) (*http.Response, error)

	/*
		GetFuncKey Get a func key inside template

		**Required ACL:** `confd.funckeys.templates.{template_id}.{position}.read`

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param templateId
		@param position position of the funckey
		@return FunckeysAPIGetFuncKeyRequest
	*/
	GetFuncKey(ctx context.Context, templateId int32, position int32) FunckeysAPIGetFuncKeyRequest

	// GetFuncKeyExecute executes the request
	//  @return FuncKey
	GetFuncKeyExecute(r FunckeysAPIGetFuncKeyRequest) (*FuncKey, *http.Response, error)

	/*
		GetFuncKeyTemplate Get a func key template

		**Required ACL:** `confd.funckeys.templates.{template_id}.read`

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param templateId
		@return FunckeysAPIGetFuncKeyTemplateRequest
	*/
	GetFuncKeyTemplate(ctx context.Context, templateId int32) FunckeysAPIGetFuncKeyTemplateRequest

	// GetFuncKeyTemplateExecute executes the request
	//  @return FuncKeyTemplate
	GetFuncKeyTemplateExecute(r FunckeysAPIGetFuncKeyTemplateRequest) (*FuncKeyTemplate, *http.Response, error)

	/*
		GetUserFuncKey Get a func key for a user

		**Required ACL:** `confd.users.{user_id}.funckeys.{position}.read`

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param userId the user's ID or UUID
		@param position position of the funckey
		@return FunckeysAPIGetUserFuncKeyRequest
	*/
	GetUserFuncKey(ctx context.Context, userId string, position int32) FunckeysAPIGetUserFuncKeyRequest

	// GetUserFuncKeyExecute executes the request
	//  @return FuncKey
	GetUserFuncKeyExecute(r FunckeysAPIGetUserFuncKeyRequest) (*FuncKey, *http.Response, error)

	/*
		ListFuncKeyDestinations List of possible func key destinations and their parameters

		**Required ACL:** `confd.funckeys.destinations.read`

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@return FunckeysAPIListFuncKeyDestinationsRequest
	*/
	ListFuncKeyDestinations(ctx context.Context) FunckeysAPIListFuncKeyDestinationsRequest

	// ListFuncKeyDestinationsExecute executes the request
	//  @return []FuncKeyDestination
	ListFuncKeyDestinationsExecute(r FunckeysAPIListFuncKeyDestinationsRequest) ([]FuncKeyDestination, *http.Response, error)

	/*
		ListFuncKeyTemplate List a func key template

		**Required ACL:** `confd.funckeys.templates.read`

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@return FunckeysAPIListFuncKeyTemplateRequest
	*/
	ListFuncKeyTemplate(ctx context.Context) FunckeysAPIListFuncKeyTemplateRequest

	// ListFuncKeyTemplateExecute executes the request
	//  @return FuncKeyTemplate
	ListFuncKeyTemplateExecute(r FunckeysAPIListFuncKeyTemplateRequest) (*FuncKeyTemplate, *http.Response, error)

	/*
		ListFuncKeyTemplateUserAssociations List users associated to template

		**Required ACL:** `confd.funckeys.templates.{template_id}.users.read`

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param templateId
		@return FunckeysAPIListFuncKeyTemplateUserAssociationsRequest
	*/
	ListFuncKeyTemplateUserAssociations(ctx context.Context, templateId int32) FunckeysAPIListFuncKeyTemplateUserAssociationsRequest

	// ListFuncKeyTemplateUserAssociationsExecute executes the request
	//  @return UserFuncKeyTemplate
	ListFuncKeyTemplateUserAssociationsExecute(r FunckeysAPIListFuncKeyTemplateUserAssociationsRequest) (*UserFuncKeyTemplate, *http.Response, error)

	/*
		ListUserFuncKeyTemplateAssociations List funckey templates associated to user

		**Required ACL:** `confd.users.{user_id}.funckeys.templates.read`

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param userId the user's ID or UUID
		@return FunckeysAPIListUserFuncKeyTemplateAssociationsRequest
	*/
	ListUserFuncKeyTemplateAssociations(ctx context.Context, userId string) FunckeysAPIListUserFuncKeyTemplateAssociationsRequest

	// ListUserFuncKeyTemplateAssociationsExecute executes the request
	//  @return UserFuncKeyTemplate
	ListUserFuncKeyTemplateAssociationsExecute(r FunckeysAPIListUserFuncKeyTemplateAssociationsRequest) (*UserFuncKeyTemplate, *http.Response, error)

	/*
		ListUserFuncKeys List func keys for a user

		**Required ACL:** `confd.users.{user_id}.funckeys.read`

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param userId the user's ID or UUID
		@return FunckeysAPIListUserFuncKeysRequest
	*/
	ListUserFuncKeys(ctx context.Context, userId string) FunckeysAPIListUserFuncKeysRequest

	// ListUserFuncKeysExecute executes the request
	//  @return FuncKeyTemplate
	ListUserFuncKeysExecute(r FunckeysAPIListUserFuncKeysRequest) (*FuncKeyTemplate, *http.Response, error)

	/*
		UpdateFuncKey Add/Replace a func key in a template

		**Required ACL:** `confd.funckeys.templates.{template_id}.{position}.update`

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param templateId
		@param position position of the funckey
		@return FunckeysAPIUpdateFuncKeyRequest
	*/
	UpdateFuncKey(ctx context.Context, templateId int32, position int32) FunckeysAPIUpdateFuncKeyRequest

	// UpdateFuncKeyExecute executes the request
	UpdateFuncKeyExecute(r FunckeysAPIUpdateFuncKeyRequest) (*http.Response, error)

	/*
		UpdateFuncKeyTemplate Update a func key template

		**Required ACL:** `confd.funckeys.templates.{template_id}.update`

	**WARNING** This endpoint restore to default value or delete all fields that are not defined.

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param templateId
		@return FunckeysAPIUpdateFuncKeyTemplateRequest
	*/
	UpdateFuncKeyTemplate(ctx context.Context, templateId int32) FunckeysAPIUpdateFuncKeyTemplateRequest

	// UpdateFuncKeyTemplateExecute executes the request
	UpdateFuncKeyTemplateExecute(r FunckeysAPIUpdateFuncKeyTemplateRequest) (*http.Response, error)

	/*
		UpdateUserFuncKey Add/Replace a func key for a user

		**Required ACL:** `confd.users.{user_id}.funckeys.{position}.update`

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param userId the user's ID or UUID
		@param position position of the funckey
		@return FunckeysAPIUpdateUserFuncKeyRequest
	*/
	UpdateUserFuncKey(ctx context.Context, userId string, position int32) FunckeysAPIUpdateUserFuncKeyRequest

	// UpdateUserFuncKeyExecute executes the request
	UpdateUserFuncKeyExecute(r FunckeysAPIUpdateUserFuncKeyRequest) (*http.Response, error)

	/*
		UpdateUserFuncKeys Update func keys for a user

		**Required ACL:** `confd.users.{user_id}.funckeys.update`

	**WARNING** This endpoint restore to default value or delete all fields that are not defined.

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param userId the user's ID or UUID
		@return FunckeysAPIUpdateUserFuncKeysRequest
	*/
	UpdateUserFuncKeys(ctx context.Context, userId string) FunckeysAPIUpdateUserFuncKeysRequest

	// UpdateUserFuncKeysExecute executes the request
	UpdateUserFuncKeysExecute(r FunckeysAPIUpdateUserFuncKeysRequest) (*http.Response, error)
}

// FunckeysAPIService FunckeysAPI service
type FunckeysAPIService service

type FunckeysAPIAssociateUserFuncKeyTemplateRequest struct {
	ctx          context.Context
	ApiService   FunckeysAPI
	userId       string
	templateId   int32
	accentTenant *string
}

// The tenant&#39;s UUID, defining the ownership of a given resource.
func (r FunckeysAPIAssociateUserFuncKeyTemplateRequest) AccentTenant(accentTenant string) FunckeysAPIAssociateUserFuncKeyTemplateRequest {
	r.accentTenant = &accentTenant
	return r
}

func (r FunckeysAPIAssociateUserFuncKeyTemplateRequest) Execute() (*http.Response, error) {
	return r.ApiService.AssociateUserFuncKeyTemplateExecute(r)
}

/*
AssociateUserFuncKeyTemplate Associate a func key template to a user

**Required ACL:** `confd.users.{user_id}.funckeys.templates.{template_id}.update`

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param userId the user's ID or UUID
	@param templateId
	@return FunckeysAPIAssociateUserFuncKeyTemplateRequest
*/
func (a *FunckeysAPIService) AssociateUserFuncKeyTemplate(ctx context.Context, userId string, templateId int32) FunckeysAPIAssociateUserFuncKeyTemplateRequest {
	return FunckeysAPIAssociateUserFuncKeyTemplateRequest{
		ApiService: a,
		ctx:        ctx,
		userId:     userId,
		templateId: templateId,
	}
}

// Execute executes the request
func (a *FunckeysAPIService) AssociateUserFuncKeyTemplateExecute(r FunckeysAPIAssociateUserFuncKeyTemplateRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodPut
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "FunckeysAPIService.AssociateUserFuncKeyTemplate")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/{user_id}/funckeys/templates/{template_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"user_id"+"}", url.PathEscape(parameterValueToString(r.userId, "userId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"template_id"+"}", url.PathEscape(parameterValueToString(r.templateId, "templateId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.accentTenant != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accent-Tenant", r.accentTenant, "")
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["accent_auth_token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Auth-Token"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v []string
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v []string
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type FunckeysAPICreateFuncKeyTemplateRequest struct {
	ctx          context.Context
	ApiService   FunckeysAPI
	body         *FuncKeyTemplate
	accentTenant *string
}

// Template to create
func (r FunckeysAPICreateFuncKeyTemplateRequest) Body(body FuncKeyTemplate) FunckeysAPICreateFuncKeyTemplateRequest {
	r.body = &body
	return r
}

// The tenant&#39;s UUID, defining the ownership of a given resource.
func (r FunckeysAPICreateFuncKeyTemplateRequest) AccentTenant(accentTenant string) FunckeysAPICreateFuncKeyTemplateRequest {
	r.accentTenant = &accentTenant
	return r
}

func (r FunckeysAPICreateFuncKeyTemplateRequest) Execute() (*FuncKeyTemplate, *http.Response, error) {
	return r.ApiService.CreateFuncKeyTemplateExecute(r)
}

/*
CreateFuncKeyTemplate Create a template of func keys

**Required ACL:** `confd.funckeys.templates.create`

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return FunckeysAPICreateFuncKeyTemplateRequest
*/
func (a *FunckeysAPIService) CreateFuncKeyTemplate(ctx context.Context) FunckeysAPICreateFuncKeyTemplateRequest {
	return FunckeysAPICreateFuncKeyTemplateRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return FuncKeyTemplate
func (a *FunckeysAPIService) CreateFuncKeyTemplateExecute(r FunckeysAPICreateFuncKeyTemplateRequest) (*FuncKeyTemplate, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *FuncKeyTemplate
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "FunckeysAPIService.CreateFuncKeyTemplate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/funckeys/templates"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.accentTenant != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accent-Tenant", r.accentTenant, "")
	}
	// body params
	localVarPostBody = r.body
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["accent_auth_token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Auth-Token"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v []string
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type FunckeysAPIDeleteFuncKeyRequest struct {
	ctx          context.Context
	ApiService   FunckeysAPI
	templateId   int32
	position     int32
	accentTenant *string
}

// The tenant&#39;s UUID, defining the ownership of a given resource.
func (r FunckeysAPIDeleteFuncKeyRequest) AccentTenant(accentTenant string) FunckeysAPIDeleteFuncKeyRequest {
	r.accentTenant = &accentTenant
	return r
}

func (r FunckeysAPIDeleteFuncKeyRequest) Execute() (*http.Response, error) {
	return r.ApiService.DeleteFuncKeyExecute(r)
}

/*
DeleteFuncKey Remove func key from template

**Required ACL:** `confd.funckeys.templates.{template_id}.{position}.delete`

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param templateId
	@param position position of the funckey
	@return FunckeysAPIDeleteFuncKeyRequest
*/
func (a *FunckeysAPIService) DeleteFuncKey(ctx context.Context, templateId int32, position int32) FunckeysAPIDeleteFuncKeyRequest {
	return FunckeysAPIDeleteFuncKeyRequest{
		ApiService: a,
		ctx:        ctx,
		templateId: templateId,
		position:   position,
	}
}

// Execute executes the request
func (a *FunckeysAPIService) DeleteFuncKeyExecute(r FunckeysAPIDeleteFuncKeyRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodDelete
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "FunckeysAPIService.DeleteFuncKey")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/funckeys/templates/{template_id}/{position}"
	localVarPath = strings.Replace(localVarPath, "{"+"template_id"+"}", url.PathEscape(parameterValueToString(r.templateId, "templateId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"position"+"}", url.PathEscape(parameterValueToString(r.position, "position")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.accentTenant != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accent-Tenant", r.accentTenant, "")
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["accent_auth_token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Auth-Token"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v []string
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v []string
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type FunckeysAPIDeleteFuncKeyTemplateRequest struct {
	ctx          context.Context
	ApiService   FunckeysAPI
	templateId   int32
	accentTenant *string
}

// The tenant&#39;s UUID, defining the ownership of a given resource.
func (r FunckeysAPIDeleteFuncKeyTemplateRequest) AccentTenant(accentTenant string) FunckeysAPIDeleteFuncKeyTemplateRequest {
	r.accentTenant = &accentTenant
	return r
}

func (r FunckeysAPIDeleteFuncKeyTemplateRequest) Execute() (*http.Response, error) {
	return r.ApiService.DeleteFuncKeyTemplateExecute(r)
}

/*
DeleteFuncKeyTemplate Delete func key template

**Required ACL:** `confd.funckeys.templates.{template_id}.delete`

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param templateId
	@return FunckeysAPIDeleteFuncKeyTemplateRequest
*/
func (a *FunckeysAPIService) DeleteFuncKeyTemplate(ctx context.Context, templateId int32) FunckeysAPIDeleteFuncKeyTemplateRequest {
	return FunckeysAPIDeleteFuncKeyTemplateRequest{
		ApiService: a,
		ctx:        ctx,
		templateId: templateId,
	}
}

// Execute executes the request
func (a *FunckeysAPIService) DeleteFuncKeyTemplateExecute(r FunckeysAPIDeleteFuncKeyTemplateRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodDelete
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "FunckeysAPIService.DeleteFuncKeyTemplate")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/funckeys/templates/{template_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"template_id"+"}", url.PathEscape(parameterValueToString(r.templateId, "templateId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.accentTenant != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accent-Tenant", r.accentTenant, "")
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["accent_auth_token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Auth-Token"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v []string
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v []string
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type FunckeysAPIDeleteUserFuncKeyRequest struct {
	ctx          context.Context
	ApiService   FunckeysAPI
	userId       string
	position     int32
	accentTenant *string
}

// The tenant&#39;s UUID, defining the ownership of a given resource.
func (r FunckeysAPIDeleteUserFuncKeyRequest) AccentTenant(accentTenant string) FunckeysAPIDeleteUserFuncKeyRequest {
	r.accentTenant = &accentTenant
	return r
}

func (r FunckeysAPIDeleteUserFuncKeyRequest) Execute() (*http.Response, error) {
	return r.ApiService.DeleteUserFuncKeyExecute(r)
}

/*
DeleteUserFuncKey Remove func key for user

**Required ACL:** `confd.users.{user_id}.funckeys.{position}.delete`

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param userId the user's ID or UUID
	@param position position of the funckey
	@return FunckeysAPIDeleteUserFuncKeyRequest
*/
func (a *FunckeysAPIService) DeleteUserFuncKey(ctx context.Context, userId string, position int32) FunckeysAPIDeleteUserFuncKeyRequest {
	return FunckeysAPIDeleteUserFuncKeyRequest{
		ApiService: a,
		ctx:        ctx,
		userId:     userId,
		position:   position,
	}
}

// Execute executes the request
func (a *FunckeysAPIService) DeleteUserFuncKeyExecute(r FunckeysAPIDeleteUserFuncKeyRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodDelete
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "FunckeysAPIService.DeleteUserFuncKey")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/{user_id}/funckeys/{position}"
	localVarPath = strings.Replace(localVarPath, "{"+"user_id"+"}", url.PathEscape(parameterValueToString(r.userId, "userId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"position"+"}", url.PathEscape(parameterValueToString(r.position, "position")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.accentTenant != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accent-Tenant", r.accentTenant, "")
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["accent_auth_token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Auth-Token"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v []string
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v []string
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type FunckeysAPIDissociateUserFuncKeyTemplateRequest struct {
	ctx          context.Context
	ApiService   FunckeysAPI
	userId       string
	templateId   int32
	accentTenant *string
}

// The tenant&#39;s UUID, defining the ownership of a given resource.
func (r FunckeysAPIDissociateUserFuncKeyTemplateRequest) AccentTenant(accentTenant string) FunckeysAPIDissociateUserFuncKeyTemplateRequest {
	r.accentTenant = &accentTenant
	return r
}

func (r FunckeysAPIDissociateUserFuncKeyTemplateRequest) Execute() (*http.Response, error) {
	return r.ApiService.DissociateUserFuncKeyTemplateExecute(r)
}

/*
DissociateUserFuncKeyTemplate Dissociate a func key template to a user

**Required ACL:** `confd.users.{user_id}.funckeys.templates.{template_id}.delete`

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param userId the user's ID or UUID
	@param templateId
	@return FunckeysAPIDissociateUserFuncKeyTemplateRequest
*/
func (a *FunckeysAPIService) DissociateUserFuncKeyTemplate(ctx context.Context, userId string, templateId int32) FunckeysAPIDissociateUserFuncKeyTemplateRequest {
	return FunckeysAPIDissociateUserFuncKeyTemplateRequest{
		ApiService: a,
		ctx:        ctx,
		userId:     userId,
		templateId: templateId,
	}
}

// Execute executes the request
func (a *FunckeysAPIService) DissociateUserFuncKeyTemplateExecute(r FunckeysAPIDissociateUserFuncKeyTemplateRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodDelete
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "FunckeysAPIService.DissociateUserFuncKeyTemplate")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/{user_id}/funckeys/templates/{template_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"user_id"+"}", url.PathEscape(parameterValueToString(r.userId, "userId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"template_id"+"}", url.PathEscape(parameterValueToString(r.templateId, "templateId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.accentTenant != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accent-Tenant", r.accentTenant, "")
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["accent_auth_token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Auth-Token"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v []string
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v []string
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type FunckeysAPIGetFuncKeyRequest struct {
	ctx          context.Context
	ApiService   FunckeysAPI
	templateId   int32
	position     int32
	accentTenant *string
}

// The tenant&#39;s UUID, defining the ownership of a given resource.
func (r FunckeysAPIGetFuncKeyRequest) AccentTenant(accentTenant string) FunckeysAPIGetFuncKeyRequest {
	r.accentTenant = &accentTenant
	return r
}

func (r FunckeysAPIGetFuncKeyRequest) Execute() (*FuncKey, *http.Response, error) {
	return r.ApiService.GetFuncKeyExecute(r)
}

/*
GetFuncKey Get a func key inside template

**Required ACL:** `confd.funckeys.templates.{template_id}.{position}.read`

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param templateId
	@param position position of the funckey
	@return FunckeysAPIGetFuncKeyRequest
*/
func (a *FunckeysAPIService) GetFuncKey(ctx context.Context, templateId int32, position int32) FunckeysAPIGetFuncKeyRequest {
	return FunckeysAPIGetFuncKeyRequest{
		ApiService: a,
		ctx:        ctx,
		templateId: templateId,
		position:   position,
	}
}

// Execute executes the request
//
//	@return FuncKey
func (a *FunckeysAPIService) GetFuncKeyExecute(r FunckeysAPIGetFuncKeyRequest) (*FuncKey, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *FuncKey
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "FunckeysAPIService.GetFuncKey")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/funckeys/templates/{template_id}/{position}"
	localVarPath = strings.Replace(localVarPath, "{"+"template_id"+"}", url.PathEscape(parameterValueToString(r.templateId, "templateId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"position"+"}", url.PathEscape(parameterValueToString(r.position, "position")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.accentTenant != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accent-Tenant", r.accentTenant, "")
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["accent_auth_token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Auth-Token"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v []string
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type FunckeysAPIGetFuncKeyTemplateRequest struct {
	ctx          context.Context
	ApiService   FunckeysAPI
	templateId   int32
	accentTenant *string
}

// The tenant&#39;s UUID, defining the ownership of a given resource.
func (r FunckeysAPIGetFuncKeyTemplateRequest) AccentTenant(accentTenant string) FunckeysAPIGetFuncKeyTemplateRequest {
	r.accentTenant = &accentTenant
	return r
}

func (r FunckeysAPIGetFuncKeyTemplateRequest) Execute() (*FuncKeyTemplate, *http.Response, error) {
	return r.ApiService.GetFuncKeyTemplateExecute(r)
}

/*
GetFuncKeyTemplate Get a func key template

**Required ACL:** `confd.funckeys.templates.{template_id}.read`

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param templateId
	@return FunckeysAPIGetFuncKeyTemplateRequest
*/
func (a *FunckeysAPIService) GetFuncKeyTemplate(ctx context.Context, templateId int32) FunckeysAPIGetFuncKeyTemplateRequest {
	return FunckeysAPIGetFuncKeyTemplateRequest{
		ApiService: a,
		ctx:        ctx,
		templateId: templateId,
	}
}

// Execute executes the request
//
//	@return FuncKeyTemplate
func (a *FunckeysAPIService) GetFuncKeyTemplateExecute(r FunckeysAPIGetFuncKeyTemplateRequest) (*FuncKeyTemplate, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *FuncKeyTemplate
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "FunckeysAPIService.GetFuncKeyTemplate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/funckeys/templates/{template_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"template_id"+"}", url.PathEscape(parameterValueToString(r.templateId, "templateId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.accentTenant != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accent-Tenant", r.accentTenant, "")
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["accent_auth_token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Auth-Token"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v []string
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type FunckeysAPIGetUserFuncKeyRequest struct {
	ctx          context.Context
	ApiService   FunckeysAPI
	userId       string
	position     int32
	accentTenant *string
}

// The tenant&#39;s UUID, defining the ownership of a given resource.
func (r FunckeysAPIGetUserFuncKeyRequest) AccentTenant(accentTenant string) FunckeysAPIGetUserFuncKeyRequest {
	r.accentTenant = &accentTenant
	return r
}

func (r FunckeysAPIGetUserFuncKeyRequest) Execute() (*FuncKey, *http.Response, error) {
	return r.ApiService.GetUserFuncKeyExecute(r)
}

/*
GetUserFuncKey Get a func key for a user

**Required ACL:** `confd.users.{user_id}.funckeys.{position}.read`

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param userId the user's ID or UUID
	@param position position of the funckey
	@return FunckeysAPIGetUserFuncKeyRequest
*/
func (a *FunckeysAPIService) GetUserFuncKey(ctx context.Context, userId string, position int32) FunckeysAPIGetUserFuncKeyRequest {
	return FunckeysAPIGetUserFuncKeyRequest{
		ApiService: a,
		ctx:        ctx,
		userId:     userId,
		position:   position,
	}
}

// Execute executes the request
//
//	@return FuncKey
func (a *FunckeysAPIService) GetUserFuncKeyExecute(r FunckeysAPIGetUserFuncKeyRequest) (*FuncKey, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *FuncKey
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "FunckeysAPIService.GetUserFuncKey")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/{user_id}/funckeys/{position}"
	localVarPath = strings.Replace(localVarPath, "{"+"user_id"+"}", url.PathEscape(parameterValueToString(r.userId, "userId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"position"+"}", url.PathEscape(parameterValueToString(r.position, "position")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.accentTenant != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accent-Tenant", r.accentTenant, "")
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["accent_auth_token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Auth-Token"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v []string
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type FunckeysAPIListFuncKeyDestinationsRequest struct {
	ctx        context.Context
	ApiService FunckeysAPI
}

func (r FunckeysAPIListFuncKeyDestinationsRequest) Execute() ([]FuncKeyDestination, *http.Response, error) {
	return r.ApiService.ListFuncKeyDestinationsExecute(r)
}

/*
ListFuncKeyDestinations List of possible func key destinations and their parameters

**Required ACL:** `confd.funckeys.destinations.read`

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return FunckeysAPIListFuncKeyDestinationsRequest
*/
func (a *FunckeysAPIService) ListFuncKeyDestinations(ctx context.Context) FunckeysAPIListFuncKeyDestinationsRequest {
	return FunckeysAPIListFuncKeyDestinationsRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return []FuncKeyDestination
func (a *FunckeysAPIService) ListFuncKeyDestinationsExecute(r FunckeysAPIListFuncKeyDestinationsRequest) ([]FuncKeyDestination, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue []FuncKeyDestination
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "FunckeysAPIService.ListFuncKeyDestinations")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/funckeys/destinations"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["accent_auth_token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Auth-Token"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type FunckeysAPIListFuncKeyTemplateRequest struct {
	ctx          context.Context
	ApiService   FunckeysAPI
	accentTenant *string
	recurse      *bool
}

// The tenant&#39;s UUID, defining the ownership of a given resource.
func (r FunckeysAPIListFuncKeyTemplateRequest) AccentTenant(accentTenant string) FunckeysAPIListFuncKeyTemplateRequest {
	r.accentTenant = &accentTenant
	return r
}

// Should the query include sub-tenants
func (r FunckeysAPIListFuncKeyTemplateRequest) Recurse(recurse bool) FunckeysAPIListFuncKeyTemplateRequest {
	r.recurse = &recurse
	return r
}

func (r FunckeysAPIListFuncKeyTemplateRequest) Execute() (*FuncKeyTemplate, *http.Response, error) {
	return r.ApiService.ListFuncKeyTemplateExecute(r)
}

/*
ListFuncKeyTemplate List a func key template

**Required ACL:** `confd.funckeys.templates.read`

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return FunckeysAPIListFuncKeyTemplateRequest
*/
func (a *FunckeysAPIService) ListFuncKeyTemplate(ctx context.Context) FunckeysAPIListFuncKeyTemplateRequest {
	return FunckeysAPIListFuncKeyTemplateRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return FuncKeyTemplate
func (a *FunckeysAPIService) ListFuncKeyTemplateExecute(r FunckeysAPIListFuncKeyTemplateRequest) (*FuncKeyTemplate, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *FuncKeyTemplate
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "FunckeysAPIService.ListFuncKeyTemplate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/funckeys/templates"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.recurse != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "recurse", r.recurse, "")
	} else {
		var defaultValue bool = false
		r.recurse = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.accentTenant != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accent-Tenant", r.accentTenant, "")
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["accent_auth_token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Auth-Token"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v []string
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type FunckeysAPIListFuncKeyTemplateUserAssociationsRequest struct {
	ctx          context.Context
	ApiService   FunckeysAPI
	templateId   int32
	accentTenant *string
}

// The tenant&#39;s UUID, defining the ownership of a given resource.
func (r FunckeysAPIListFuncKeyTemplateUserAssociationsRequest) AccentTenant(accentTenant string) FunckeysAPIListFuncKeyTemplateUserAssociationsRequest {
	r.accentTenant = &accentTenant
	return r
}

func (r FunckeysAPIListFuncKeyTemplateUserAssociationsRequest) Execute() (*UserFuncKeyTemplate, *http.Response, error) {
	return r.ApiService.ListFuncKeyTemplateUserAssociationsExecute(r)
}

/*
ListFuncKeyTemplateUserAssociations List users associated to template

**Required ACL:** `confd.funckeys.templates.{template_id}.users.read`

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param templateId
	@return FunckeysAPIListFuncKeyTemplateUserAssociationsRequest
*/
func (a *FunckeysAPIService) ListFuncKeyTemplateUserAssociations(ctx context.Context, templateId int32) FunckeysAPIListFuncKeyTemplateUserAssociationsRequest {
	return FunckeysAPIListFuncKeyTemplateUserAssociationsRequest{
		ApiService: a,
		ctx:        ctx,
		templateId: templateId,
	}
}

// Execute executes the request
//
//	@return UserFuncKeyTemplate
func (a *FunckeysAPIService) ListFuncKeyTemplateUserAssociationsExecute(r FunckeysAPIListFuncKeyTemplateUserAssociationsRequest) (*UserFuncKeyTemplate, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *UserFuncKeyTemplate
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "FunckeysAPIService.ListFuncKeyTemplateUserAssociations")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/funckeys/templates/{template_id}/users"
	localVarPath = strings.Replace(localVarPath, "{"+"template_id"+"}", url.PathEscape(parameterValueToString(r.templateId, "templateId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.accentTenant != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accent-Tenant", r.accentTenant, "")
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["accent_auth_token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Auth-Token"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v []string
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type FunckeysAPIListUserFuncKeyTemplateAssociationsRequest struct {
	ctx          context.Context
	ApiService   FunckeysAPI
	userId       string
	accentTenant *string
}

// The tenant&#39;s UUID, defining the ownership of a given resource.
func (r FunckeysAPIListUserFuncKeyTemplateAssociationsRequest) AccentTenant(accentTenant string) FunckeysAPIListUserFuncKeyTemplateAssociationsRequest {
	r.accentTenant = &accentTenant
	return r
}

func (r FunckeysAPIListUserFuncKeyTemplateAssociationsRequest) Execute() (*UserFuncKeyTemplate, *http.Response, error) {
	return r.ApiService.ListUserFuncKeyTemplateAssociationsExecute(r)
}

/*
ListUserFuncKeyTemplateAssociations List funckey templates associated to user

**Required ACL:** `confd.users.{user_id}.funckeys.templates.read`

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param userId the user's ID or UUID
	@return FunckeysAPIListUserFuncKeyTemplateAssociationsRequest
*/
func (a *FunckeysAPIService) ListUserFuncKeyTemplateAssociations(ctx context.Context, userId string) FunckeysAPIListUserFuncKeyTemplateAssociationsRequest {
	return FunckeysAPIListUserFuncKeyTemplateAssociationsRequest{
		ApiService: a,
		ctx:        ctx,
		userId:     userId,
	}
}

// Execute executes the request
//
//	@return UserFuncKeyTemplate
func (a *FunckeysAPIService) ListUserFuncKeyTemplateAssociationsExecute(r FunckeysAPIListUserFuncKeyTemplateAssociationsRequest) (*UserFuncKeyTemplate, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *UserFuncKeyTemplate
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "FunckeysAPIService.ListUserFuncKeyTemplateAssociations")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/{user_id}/funckeys/templates"
	localVarPath = strings.Replace(localVarPath, "{"+"user_id"+"}", url.PathEscape(parameterValueToString(r.userId, "userId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.accentTenant != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accent-Tenant", r.accentTenant, "")
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["accent_auth_token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Auth-Token"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v []string
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type FunckeysAPIListUserFuncKeysRequest struct {
	ctx          context.Context
	ApiService   FunckeysAPI
	userId       string
	accentTenant *string
}

// The tenant&#39;s UUID, defining the ownership of a given resource.
func (r FunckeysAPIListUserFuncKeysRequest) AccentTenant(accentTenant string) FunckeysAPIListUserFuncKeysRequest {
	r.accentTenant = &accentTenant
	return r
}

func (r FunckeysAPIListUserFuncKeysRequest) Execute() (*FuncKeyTemplate, *http.Response, error) {
	return r.ApiService.ListUserFuncKeysExecute(r)
}

/*
ListUserFuncKeys List func keys for a user

**Required ACL:** `confd.users.{user_id}.funckeys.read`

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param userId the user's ID or UUID
	@return FunckeysAPIListUserFuncKeysRequest
*/
func (a *FunckeysAPIService) ListUserFuncKeys(ctx context.Context, userId string) FunckeysAPIListUserFuncKeysRequest {
	return FunckeysAPIListUserFuncKeysRequest{
		ApiService: a,
		ctx:        ctx,
		userId:     userId,
	}
}

// Execute executes the request
//
//	@return FuncKeyTemplate
func (a *FunckeysAPIService) ListUserFuncKeysExecute(r FunckeysAPIListUserFuncKeysRequest) (*FuncKeyTemplate, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *FuncKeyTemplate
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "FunckeysAPIService.ListUserFuncKeys")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/{user_id}/funckeys"
	localVarPath = strings.Replace(localVarPath, "{"+"user_id"+"}", url.PathEscape(parameterValueToString(r.userId, "userId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.accentTenant != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accent-Tenant", r.accentTenant, "")
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["accent_auth_token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Auth-Token"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type FunckeysAPIUpdateFuncKeyRequest struct {
	ctx          context.Context
	ApiService   FunckeysAPI
	body         *FuncKey
	templateId   int32
	position     int32
	accentTenant *string
}

func (r FunckeysAPIUpdateFuncKeyRequest) Body(body FuncKey) FunckeysAPIUpdateFuncKeyRequest {
	r.body = &body
	return r
}

// The tenant&#39;s UUID, defining the ownership of a given resource.
func (r FunckeysAPIUpdateFuncKeyRequest) AccentTenant(accentTenant string) FunckeysAPIUpdateFuncKeyRequest {
	r.accentTenant = &accentTenant
	return r
}

func (r FunckeysAPIUpdateFuncKeyRequest) Execute() (*http.Response, error) {
	return r.ApiService.UpdateFuncKeyExecute(r)
}

/*
UpdateFuncKey Add/Replace a func key in a template

**Required ACL:** `confd.funckeys.templates.{template_id}.{position}.update`

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param templateId
	@param position position of the funckey
	@return FunckeysAPIUpdateFuncKeyRequest
*/
func (a *FunckeysAPIService) UpdateFuncKey(ctx context.Context, templateId int32, position int32) FunckeysAPIUpdateFuncKeyRequest {
	return FunckeysAPIUpdateFuncKeyRequest{
		ApiService: a,
		ctx:        ctx,
		templateId: templateId,
		position:   position,
	}
}

// Execute executes the request
func (a *FunckeysAPIService) UpdateFuncKeyExecute(r FunckeysAPIUpdateFuncKeyRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodPut
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "FunckeysAPIService.UpdateFuncKey")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/funckeys/templates/{template_id}/{position}"
	localVarPath = strings.Replace(localVarPath, "{"+"template_id"+"}", url.PathEscape(parameterValueToString(r.templateId, "templateId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"position"+"}", url.PathEscape(parameterValueToString(r.position, "position")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return nil, reportError("body is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.accentTenant != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accent-Tenant", r.accentTenant, "")
	}
	// body params
	localVarPostBody = r.body
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["accent_auth_token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Auth-Token"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v []string
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type FunckeysAPIUpdateFuncKeyTemplateRequest struct {
	ctx          context.Context
	ApiService   FunckeysAPI
	body         *FuncKeyTemplate
	templateId   int32
	accentTenant *string
}

func (r FunckeysAPIUpdateFuncKeyTemplateRequest) Body(body FuncKeyTemplate) FunckeysAPIUpdateFuncKeyTemplateRequest {
	r.body = &body
	return r
}

// The tenant&#39;s UUID, defining the ownership of a given resource.
func (r FunckeysAPIUpdateFuncKeyTemplateRequest) AccentTenant(accentTenant string) FunckeysAPIUpdateFuncKeyTemplateRequest {
	r.accentTenant = &accentTenant
	return r
}

func (r FunckeysAPIUpdateFuncKeyTemplateRequest) Execute() (*http.Response, error) {
	return r.ApiService.UpdateFuncKeyTemplateExecute(r)
}

/*
UpdateFuncKeyTemplate Update a func key template

**Required ACL:** `confd.funckeys.templates.{template_id}.update`

**WARNING** This endpoint restore to default value or delete all fields that are not defined.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param templateId
	@return FunckeysAPIUpdateFuncKeyTemplateRequest
*/
func (a *FunckeysAPIService) UpdateFuncKeyTemplate(ctx context.Context, templateId int32) FunckeysAPIUpdateFuncKeyTemplateRequest {
	return FunckeysAPIUpdateFuncKeyTemplateRequest{
		ApiService: a,
		ctx:        ctx,
		templateId: templateId,
	}
}

// Execute executes the request
func (a *FunckeysAPIService) UpdateFuncKeyTemplateExecute(r FunckeysAPIUpdateFuncKeyTemplateRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodPut
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "FunckeysAPIService.UpdateFuncKeyTemplate")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/funckeys/templates/{template_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"template_id"+"}", url.PathEscape(parameterValueToString(r.templateId, "templateId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return nil, reportError("body is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.accentTenant != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accent-Tenant", r.accentTenant, "")
	}
	// body params
	localVarPostBody = r.body
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["accent_auth_token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Auth-Token"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v []string
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type FunckeysAPIUpdateUserFuncKeyRequest struct {
	ctx          context.Context
	ApiService   FunckeysAPI
	body         *FuncKey
	userId       string
	position     int32
	accentTenant *string
}

func (r FunckeysAPIUpdateUserFuncKeyRequest) Body(body FuncKey) FunckeysAPIUpdateUserFuncKeyRequest {
	r.body = &body
	return r
}

// The tenant&#39;s UUID, defining the ownership of a given resource.
func (r FunckeysAPIUpdateUserFuncKeyRequest) AccentTenant(accentTenant string) FunckeysAPIUpdateUserFuncKeyRequest {
	r.accentTenant = &accentTenant
	return r
}

func (r FunckeysAPIUpdateUserFuncKeyRequest) Execute() (*http.Response, error) {
	return r.ApiService.UpdateUserFuncKeyExecute(r)
}

/*
UpdateUserFuncKey Add/Replace a func key for a user

**Required ACL:** `confd.users.{user_id}.funckeys.{position}.update`

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param userId the user's ID or UUID
	@param position position of the funckey
	@return FunckeysAPIUpdateUserFuncKeyRequest
*/
func (a *FunckeysAPIService) UpdateUserFuncKey(ctx context.Context, userId string, position int32) FunckeysAPIUpdateUserFuncKeyRequest {
	return FunckeysAPIUpdateUserFuncKeyRequest{
		ApiService: a,
		ctx:        ctx,
		userId:     userId,
		position:   position,
	}
}

// Execute executes the request
func (a *FunckeysAPIService) UpdateUserFuncKeyExecute(r FunckeysAPIUpdateUserFuncKeyRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodPut
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "FunckeysAPIService.UpdateUserFuncKey")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/{user_id}/funckeys/{position}"
	localVarPath = strings.Replace(localVarPath, "{"+"user_id"+"}", url.PathEscape(parameterValueToString(r.userId, "userId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"position"+"}", url.PathEscape(parameterValueToString(r.position, "position")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return nil, reportError("body is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.accentTenant != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accent-Tenant", r.accentTenant, "")
	}
	// body params
	localVarPostBody = r.body
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["accent_auth_token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Auth-Token"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v []string
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type FunckeysAPIUpdateUserFuncKeysRequest struct {
	ctx          context.Context
	ApiService   FunckeysAPI
	body         *FuncKeyTemplate
	userId       string
	accentTenant *string
}

func (r FunckeysAPIUpdateUserFuncKeysRequest) Body(body FuncKeyTemplate) FunckeysAPIUpdateUserFuncKeysRequest {
	r.body = &body
	return r
}

// The tenant&#39;s UUID, defining the ownership of a given resource.
func (r FunckeysAPIUpdateUserFuncKeysRequest) AccentTenant(accentTenant string) FunckeysAPIUpdateUserFuncKeysRequest {
	r.accentTenant = &accentTenant
	return r
}

func (r FunckeysAPIUpdateUserFuncKeysRequest) Execute() (*http.Response, error) {
	return r.ApiService.UpdateUserFuncKeysExecute(r)
}

/*
UpdateUserFuncKeys Update func keys for a user

**Required ACL:** `confd.users.{user_id}.funckeys.update`

**WARNING** This endpoint restore to default value or delete all fields that are not defined.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param userId the user's ID or UUID
	@return FunckeysAPIUpdateUserFuncKeysRequest
*/
func (a *FunckeysAPIService) UpdateUserFuncKeys(ctx context.Context, userId string) FunckeysAPIUpdateUserFuncKeysRequest {
	return FunckeysAPIUpdateUserFuncKeysRequest{
		ApiService: a,
		ctx:        ctx,
		userId:     userId,
	}
}

// Execute executes the request
func (a *FunckeysAPIService) UpdateUserFuncKeysExecute(r FunckeysAPIUpdateUserFuncKeysRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodPut
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "FunckeysAPIService.UpdateUserFuncKeys")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/{user_id}/funckeys"
	localVarPath = strings.Replace(localVarPath, "{"+"user_id"+"}", url.PathEscape(parameterValueToString(r.userId, "userId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return nil, reportError("body is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.accentTenant != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accent-Tenant", r.accentTenant, "")
	}
	// body params
	localVarPostBody = r.body
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["accent_auth_token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Auth-Token"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v []string
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}
